{"version":3,"file":"97379.js","mappings":"8hBAOO,kBAAgD,4DAAyD,EAChH,MAA8B,OAAW,EACzC,kCACA,cACA,gBACK,EACL,QAAwB,kBAAY,EACpC,WACA,2DACA,mBACK,EACL,uBAEA,SACA,kEAEA,UACA,iEAEA,WACA,kEAGA,mCACA,OACA,eACA,QACA,SACA,UACA,QACA,YACA,0BACA,EACA,OACA,uBACA,QACA,uBACA,gBACA,4BACqB,CACrB,UACA,6BACA,OAA6B,iBAA0C,CACtD,EACjB,EACA,CAGA,OACA,eACA,QACA,SACA,UACA,QACA,aAEA,OACA,uBACA,QACA,qCACA,iCACA,mBACA,4BACiB,CACjB,UACA,6BACA,sBAAyB,EAAgB,CAC5B,EACb,EACA,CACA,IAGA,eAAa,0BADb,SACa,CACb,CACA,OACA,CAAM,2BAA+B,CACrC,CAAM,yBAA6B,CACnC,CAAM,4BAAgC,CACtC,CAAM,0BAA8B,CACpC,CAAM,4BAAgC,CACtC,CAAM,yBAA6B,CACnC,CACA,GACA,CAAM,2BAA+B,CACrC,CAAM,yBAA6B,CACnC,CAAM,4BAAgC,CACtC,CAAM,0BAA8B,CACpC,CAAM,4BAAgC,CACtC,CAAM,yBAA6B,CACnC,CAAM,8BAAkC,CACxC,CAIO,oBACP,IAAY,qCAAkC,WAC9C,oCACA,cACA,KAAc,OAAS,EACvB,UACA,OACA,YACA,mDACS,CACT,CAAK,EACL,SAEA,MADA,iBACA,qCAAuD,eAAsB,GAE7E,qBACA,aACA,yCAAqD,UAAa,GAElE,kCACA,GAAQ,OAAK,IACb,OACA,kBACA,0BACA,4BAGA,4CAAmD,OAAS,IAAO,EACnE","sources":["webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/transaction/actions/gasless/providers/openzeppelin.js"],"sourcesContent":["import { getContract } from \"../../../../contract/contract.js\";\nimport { isHex } from \"../../../../utils/encoding/helpers/is-hex.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { readContract } from \"../../../read-contract.js\";\n/**\n * @internal - only exported for testing\n */\nexport async function prepareOpenZeppelinTransaction({ account, serializableTransaction, transaction, gasless, }) {\n    const forrwaderContract = getContract({\n        address: gasless.relayerForwarderAddress,\n        chain: transaction.chain,\n        client: transaction.client,\n    });\n    const nonce = await readContract({\n        contract: forrwaderContract,\n        method: \"function getNonce(address) view returns (uint256)\",\n        params: [account.address],\n    });\n    const [signature, message] = await (async () => {\n        // TODO: handle special case for `approve` -> `permit` transactions\n        if (!serializableTransaction.to) {\n            throw new Error(\"OpenZeppelin transactions must have a 'to' address\");\n        }\n        if (!serializableTransaction.gas) {\n            throw new Error(\"OpenZeppelin transactions must have a 'gas' value\");\n        }\n        if (!serializableTransaction.data) {\n            throw new Error(\"OpenZeppelin transactions must have a 'data' value\");\n        }\n        // chainless support!\n        if (gasless.experimentalChainlessSupport) {\n            const message = {\n                from: account.address,\n                to: serializableTransaction.to,\n                value: 0n,\n                gas: serializableTransaction.gas,\n                nonce: nonce,\n                data: serializableTransaction.data,\n                chainid: BigInt(transaction.chain.id),\n            };\n            return [\n                await account.signTypedData({\n                    domain: {\n                        name: \"GSNv2 Forwarder\",\n                        version: \"0.0.1\",\n                        verifyingContract: forrwaderContract.address,\n                    },\n                    message,\n                    primaryType: \"ForwardRequest\",\n                    types: { ForwardRequest: ChainAwareForwardRequest },\n                }),\n                message,\n            ];\n        }\n        // else non-chainless support\n        const message = {\n            from: account.address,\n            to: serializableTransaction.to,\n            value: 0n,\n            gas: serializableTransaction.gas,\n            nonce: nonce,\n            data: serializableTransaction.data,\n        };\n        return [\n            await account.signTypedData({\n                domain: {\n                    name: gasless.domainName ?? \"GSNv2 Forwarder\",\n                    version: gasless.domainVersion ?? \"0.0.1\",\n                    chainId: transaction.chain.id,\n                    verifyingContract: forrwaderContract.address,\n                },\n                message,\n                primaryType: \"ForwardRequest\",\n                types: { ForwardRequest },\n            }),\n            message,\n        ];\n    })();\n    // TODO: handle special case for `approve` -> `permit`\n    const messageType = \"forward\";\n    return { message, signature, messageType };\n}\nconst ForwardRequest = [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"gas\", type: \"uint256\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"data\", type: \"bytes\" },\n];\nconst ChainAwareForwardRequest = [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"gas\", type: \"uint256\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"data\", type: \"bytes\" },\n    { name: \"chainid\", type: \"uint256\" },\n];\n/**\n * @internal\n */\nexport async function relayOpenZeppelinTransaction(options) {\n    const { message, messageType, signature } = await prepareOpenZeppelinTransaction(options);\n    const response = await fetch(options.gasless.relayerUrl, {\n        method: \"POST\",\n        body: stringify({\n            request: message,\n            type: messageType,\n            signature,\n            forwarderAddress: options.gasless.relayerForwarderAddress,\n        }),\n    });\n    if (!response.ok) {\n        response.body?.cancel();\n        throw new Error(`Failed to send transaction: ${await response.text()}`);\n    }\n    const json = await response.json();\n    if (!json.result) {\n        throw new Error(`Relay transaction failed: ${json.message}`);\n    }\n    const transactionHash = JSON.parse(json.result).txHash;\n    if (isHex(transactionHash)) {\n        return {\n            transactionHash,\n            chain: options.transaction.chain,\n            client: options.transaction.client,\n        };\n    }\n    throw new Error(`Failed to send transaction: ${stringify(json)}`);\n}\n//# sourceMappingURL=openzeppelin.js.map"],"names":[],"sourceRoot":""}