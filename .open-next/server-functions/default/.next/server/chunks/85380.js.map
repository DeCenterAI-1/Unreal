{"version":3,"file":"85380.js","mappings":"oiBC0BO,YAAqC,6BAA2B,EACvE,MAAW,eAAS,EACZ,QAAmB,GAAI,eAAiB,EAAI,aAAe,EAAI,aAAe,WD5B/E,qEC8BP,CACA,uEG5BO,cACP,SACA,KACA,IACA,KACA,KACA,YAAoB,WAAsB,KAC1C,WAUA,GARA,2BACA,OAEA,SACA,IACA,SACA,IAEA,GAGA,UACA,wDACA,UAIA,GAFA,KAEA,SACA,KACA,KACA,CAEA,QACA,CAEA,YAEA,kCACA,KACA,MAEA,QACA,CACA,KACA,KACA,CACA,MACA,UAAkB,GAAgB,mCAClC,QACA,CCwRO,cACP,OAAW,IAAS,UACpB,CAqEO,oBACP,uCACA,OACW,IAAc,CAAC,IAAc,CArC7B,EAJX,gBAIsC,CAqCE,IAvCzB,GAAqB,CAuCI,KACxC,CAwCO,gBAA6B,GAAgB,CACpD,iBACA,wDACA,cAEA,KAAqB,OAAO,UAAU,EAA4B,GAAqB,aAAa,SACpG,KAAqB,OAAO,UAAU,EAA4B,GAAqB,aAAtB,EAAmC,EACpG,GACA,yEACA,gDACA,CACS,EACT,mCACA,cACA,gBACA,YACA,8BACA,CAAS,CACT,CACA,CAiCO,gBAA4B,GAAgB,CACnD,kBAAkB,uBAA4B,EAQ9C,aAAqB,EAAK,EAN1B,EACA,eAAsC,EAAK,GAC3C,EACA,eAAsC,EAAK,GAC3C,GAE4B,CAAU,aACtC,mCACA,cACA,gBACA,YACA,6BACA,CAAS,CACT,CACA,CA+B8C,GAAgB,gBEnDvD,SAAS,EAAO,OACvB,MF/QO,IE8QgB,GACS,EF/QzB,WAqBP,EApBA,SAAY,mBAA4B,GACxC,EAAU,CACV,EAAuB,IAAY,IAAS,UAAe,EAC3D,cACA,EACA,sCACA,OAAgD,IAAS,QACzD,kBACA,SAGA,wBAEA,gBACA,aAAkC,OAAY,EAC9C,gBACA,OACA,QACA,MAA4B,cAAsC,EAAI,EAGtE,gBACA,iBAEA,qBACA,kCACA,OACA,KACA,MAAoC,WAAkC,EAAI,EAE1E,QACA,CACA,aAEA,qBAEA,4BAEA,gBACA,sCACA,KAEmB,SDvNZ,ECuNgC,CDvNhC,IACP,eACA,SACA,UACA,cACA,OAAmB,IAAgB,IAAQ,UAAe,CAC1D,YACA,mBACA,gBAEA,aADA,kBAGA,SACA,iCACA,gDACA,0BAIA,0IACA,iCAGA,kDACA,4CAGA,gBAA6B,IAAI,SAAS,GAAG,eAC7C,yBACA,gBACA,KAEA,yBAAiE,GAAG,SACpE,CAAqB,GAErB,QAEA,CACA,ECiLuC,IACvC,CAAS,EACT,CAEA,MACA,cACA,UACA,MDtLO,iBCsL0D,CDrLjE,gBACA,WACA,OACA,qBACA,kBACA,kBACA,iBACA,yCACA,sBAcA,GAZA,+CAEA,6CAIA,6CAHuB,IAAgB,OACvC,SACA,CAAiB,EAQjB,QACA,CAEA,EC2JiE,qBACjE,KACA,aACA,UACA,UACqB,EACrB,UACA,UACqB,CACrB,CACA,GACA,EACA,CACA,YACA,KACA,SACA,cACA,OAAiB,iBACjB,EAAK,GACL,MACA,aAAkC,OAAY,EAC9C,OACA,KACA,MAAwB,WAAkC,EAAI,CAE9D,EEoMgC,OAChC,uBACA,UAAkB,EAAqB,MAAG,KAAH,EAAG,WAAwB,EAClE,QACA,gBC7eO,IAUA,GACP,CACA,QACA,CACA,eACA,cACA,CAAa,CACb,CACA,aACA,cACA,CAAa,CACb,CACA,kBACA,YACA,CAAa,CACb,CACA,6BACA,kBACA,CAAK,CACL,CACA,QACA,CACA,eACA,cACA,CAAa,CACb,CACA,aACA,cACA,CAAa,CACb,CACA,kBACA,YACA,CAAa,CACb,CACA,SACA,CACA,WACA,CAAa,CACb,CACA,6BACA,gBACA,iBACA,CAAK,CACL,OA+HO,UAA2C,GAAgB,CAClE,eACA,iBAAyB,EAAQ,+CACjC,mCACA,cACA,gBACA,YACA,qDACA,CAAS,CACT,CACA,0BCjMO,IACP,GACA,CACA,eACA,WACA,CAAK,CACL,CACA,aACA,gBACA,CAAK,CACL,CACA,GACA,CACA,aACA,CAAK,CACL,CAsFO,oBACP,MAAW,kBAAY,EACvB,oBACA,QAxGO,aAwGP,KACA,4BACK,CACL,iFEpEO,uBAA4B,0DAA0D,MAiD7F,EAhDA,YACA,GAAY,OAAK,IACjB,SACA,wCACA,O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","sources":["webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/auth/constants.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/auth/serialize-erc6492-signature.js","webpack://unreal/./node_modules/.pnpm/ox@0.6.10_typescript@5.8.2_zod@3.22.3/node_modules/ox/_esm/core/internal/abi.js","webpack://unreal/./node_modules/.pnpm/ox@0.6.10_typescript@5.8.2_zod@3.22.3/node_modules/ox/_esm/core/Abi.js","webpack://unreal/./node_modules/.pnpm/ox@0.6.10_typescript@5.8.2_zod@3.22.3/node_modules/ox/_esm/core/internal/abiItem.js","webpack://unreal/./node_modules/.pnpm/ox@0.6.10_typescript@5.8.2_zod@3.22.3/node_modules/ox/_esm/core/AbiItem.js","webpack://unreal/./node_modules/.pnpm/ox@0.6.10_typescript@5.8.2_zod@3.22.3/node_modules/ox/_esm/core/AbiConstructor.js","webpack://unreal/./node_modules/.pnpm/ox@0.6.10_typescript@5.8.2_zod@3.22.3/node_modules/ox/_esm/core/AbiFunction.js","webpack://unreal/./node_modules/.pnpm/ox@0.6.10_typescript@5.8.2_zod@3.22.3/node_modules/ox/_esm/erc6492/WrappedSignature.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/auth/verify-hash.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/hashing/hashMessage.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/hashing/hashTypedData.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/lib/signing.js"],"sourcesContent":["export const ERC_6492_MAGIC_VALUE = \"0x6492649264926492649264926492649264926492649264926492649264926492\";\n//# sourceMappingURL=constants.js.map","import { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { concatHex } from \"../utils/encoding/helpers/concat-hex.js\";\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\n/**\n * @description Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.\n *\n * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format\n * @param {string} signature.address The ERC-4337 Account Factory address\n * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification\n * @param {Hex} signature.signature The original signature\n *\n * @returns {Hex} The serialized signature\n *\n * @example\n * ```ts\n * import { serializeErc6492Signature } from 'thirdweb/auth';\n *\n * const serializedSignature = serializeErc6492Signature({\n *  address: '0x...',\n *  data: '0x...',\n *  signature: '0x...',\n * });\n * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492\n * ```\n * @auth\n */\nexport function serializeErc6492Signature({ address, data, signature, }) {\n    return concatHex([\n        encodeAbiParameters([{ type: \"address\" }, { type: \"bytes\" }, { type: \"bytes\" }], [address, data, signature]),\n        ERC_6492_MAGIC_VALUE,\n    ]);\n}\n//# sourceMappingURL=serialize-erc6492-signature.js.map","/** @internal */\nexport function isSignatures(value) {\n    for (const item of value) {\n        if (typeof item !== 'string')\n            return false;\n    }\n    return true;\n}\n//# sourceMappingURL=abi.js.map","import * as abitype from 'abitype';\nimport * as internal from './internal/abi.js';\n/** @internal */\nexport function format(abi) {\n    return abitype.formatAbi(abi);\n}\n/** @internal */\nexport function from(abi) {\n    if (internal.isSignatures(abi))\n        return abitype.parseAbi(abi);\n    return abi;\n}\n//# sourceMappingURL=Abi.js.map","import * as Address from '../Address.js';\nimport * as Errors from '../Errors.js';\n/** @internal */\nexport function normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new Errors.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return Address.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map","import * as abitype from 'abitype';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiItem.js';\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format(abiItem) {\n    return abitype.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = Hex.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === Hex.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return internal.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem) {\n    return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nexport function getSignature(abiItem) {\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype.formatAbiItem(abiItem);\n    })();\n    return internal.normalizeSignature(signature);\n}\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nexport function getSignatureHash(abiItem) {\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map","import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n/** @internal */\nexport function decode(abiConstructor, options) {\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return AbiParameters.decode(abiConstructor.inputs, data);\n}\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nexport function encode(abiConstructor, options) {\n    const { bytecode, args } = options;\n    return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? AbiParameters.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nexport function format(abiConstructor) {\n    return abitype.formatAbiItem(abiConstructor);\n}\n/** @internal */\nexport function from(abiConstructor) {\n    return AbiItem.from(abiConstructor);\n}\n/** @internal */\nexport function fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new AbiItem.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map","import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n/**\n * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n *\n * const input = AbiFunction.decodeData(approve, data) // [!code focus]\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @param abiFunction - The ABI Item to decode.\n * @param data - The data to decode.\n */\nexport function decodeData(abiFunction, data) {\n    const { overloads } = abiFunction;\n    if (Hex.size(data) < 4)\n        throw new AbiItem.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (Hex.size(data) <= 4)\n        return undefined;\n    return AbiParameters.decode(item.inputs, Hex.slice(data, 4));\n}\n/**\n * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   balanceOf,\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']\n * )\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output. // [!code focus]\n * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]\n * // @log: 42n\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to decode\n * @param data - ABI-encoded function output\n * @param options - Decoding options\n * @returns Decoded function output\n */\nexport function decodeResult(abiFunction, data, options = {}) {\n    const values = AbiParameters.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n/**\n * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.\n *\n * :::tip\n *\n * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input. // [!code focus]\n * const data = AbiFunction.encodeData( // [!code focus]\n *   balanceOf, // [!code focus]\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]\n * ) // [!code focus]\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output.\n * const balance = AbiFunction.decodeResult(balanceOf, response)\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to encode\n * @param args - Function arguments\n * @returns ABI-encoded function name and arguments\n */\nexport function encodeData(abiFunction, ...args) {\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args: args[0],\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0\n        ? AbiParameters.encode(item.inputs, args[0])\n        : undefined;\n    return data ? Hex.concat(selector, data) : selector;\n}\n/**\n * ABI-encodes a function's result (`outputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')\n * // 42n\n *\n * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @param abiFunction - The ABI item to encode the function output for.\n * @param output - The function output to encode.\n * @param options - Encoding options.\n * @returns The encoded function output.\n */\nexport function encodeResult(abiFunction, output, options = {}) {\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return AbiParameters.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nexport function format(abiFunction) {\n    return abitype.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nexport function from(abiFunction, options = {}) {\n    return AbiItem.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const item = AbiItem.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new AbiItem.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem) {\n    return AbiItem.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map","import * as AbiParameters from '../core/AbiParameters.js';\nimport * as Errors from '../core/Errors.js';\nimport * as Hex from '../core/Hex.js';\nimport * as Signature from '../core/Signature.js';\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nexport const magicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nexport const universalSignatureValidatorBytecode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nexport const universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        outputs: [\n            {\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n        name: 'isValidSig',\n    },\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * WrappedSignature.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nexport function assert(wrapped) {\n    if (Hex.slice(wrapped, -32) !== magicBytes)\n        throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = WrappedSignature.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = WrappedSignature.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function from(wrapped) {\n    if (typeof wrapped === 'string')\n        return fromHex(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const { data, signature, to } = WrappedSignature.fromHex('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function fromHex(wrapped) {\n    assert(wrapped);\n    const [to, data, signature_hex] = AbiParameters.decode(AbiParameters.from('address, bytes, bytes'), wrapped);\n    const signature = Signature.fromHex(signature_hex);\n    return { data, signature, to };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { WrappedSignature } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = WrappedSignature.toHex({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nexport function toHex(value) {\n    const { data, signature, to } = value;\n    return Hex.concat(AbiParameters.encode(AbiParameters.from('address, bytes, bytes'), [\n        to,\n        data,\n        Signature.toHex(signature),\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { WrappedSignature } from 'ox/erc6492'\n *\n * const valid = WrappedSignature.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nexport function validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WrappedSignature.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=WrappedSignature.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0x1626ba7e\";\nconst FN_INPUTS = [\n    {\n        type: \"bytes32\",\n        name: \"hash\",\n    },\n    {\n        type: \"bytes\",\n        name: \"signature\",\n    },\n];\nconst FN_OUTPUTS = [\n    {\n        type: \"bytes4\",\n    },\n];\n/**\n * Checks if the `isValidSignature` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isValidSignature` method is supported.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isIsValidSignatureSupported } from \"thirdweb/extensions/erc1271\";\n * const supported = isIsValidSignatureSupported([\"0x...\"]);\n * ```\n */\nexport function isIsValidSignatureSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Encodes the parameters for the \"isValidSignature\" function.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignatureParams } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignatureParams({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignatureParams(options) {\n    return encodeAbiParameters(FN_INPUTS, [options.hash, options.signature]);\n}\n/**\n * Encodes the \"isValidSignature\" function into a Hex string with its parameters.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignature } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignature({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignature(options) {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    return (FN_SELECTOR +\n        encodeIsValidSignatureParams(options).slice(2));\n}\n/**\n * Decodes the result of the isValidSignature function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1271\n * @example\n * ```ts\n * import { decodeIsValidSignatureResult } from \"thirdweb/extensions/erc1271\";\n * const result = decodeIsValidSignatureResultResult(\"...\");\n * ```\n */\nexport function decodeIsValidSignatureResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"isValidSignature\" function on the contract.\n * @param options - The options for the isValidSignature function.\n * @returns The parsed result of the function call.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isValidSignature } from \"thirdweb/extensions/erc1271\";\n *\n * const result = await isValidSignature({\n *  contract,\n *  hash: ...,\n *  signature: ...,\n * });\n *\n * ```\n */\nexport async function isValidSignature(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [options.hash, options.signature],\n    });\n}\n//# sourceMappingURL=isValidSignature.js.map","import * as ox__Bytes from \"ox/Bytes\";\nimport { uint8ArrayToHex } from \"./hex.js\";\n/**\n * Converts a Uint8Array to the specified type.\n * @param bytes - The Uint8Array to convert.\n * @param toOrOpts - The target type or conversion options.\n * @returns The converted value of the specified type.\n * @example\n * ```ts\n * import { fromBytes } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = fromBytes(bytes, \"number\");\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function fromBytes(bytes, toOrOpts) {\n    const opts = typeof toOrOpts === \"string\" ? { to: toOrOpts } : toOrOpts;\n    switch (opts.to) {\n        case \"number\":\n            return bytesToNumber(bytes, opts);\n        case \"bigint\":\n            return bytesToBigInt(bytes, opts);\n        case \"boolean\":\n            return bytesToBool(bytes, opts);\n        case \"string\":\n            return bytesToString(bytes, opts);\n        default:\n            return uint8ArrayToHex(bytes, opts);\n    }\n}\n/**\n * Converts a Uint8Array of bytes to a bigint.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The converted bigint.\n * @example\n * ```ts\n * import { bytesToBigInt } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const bigInt = bytesToBigInt(bytes);\n * console.log(bigInt); // 420n\n * ```\n * @utils\n */\nexport function bytesToBigInt(bytes, opts = {}) {\n    return ox__Bytes.toBigInt(bytes, opts);\n}\n/**\n * Converts a byte array to a boolean value.\n * @param bytes_ - The byte array to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The boolean value converted from the byte array.\n * @throws Error if the byte array is invalid or the boolean representation is invalid.\n * @example\n * ```ts\n * import { bytesToBool } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1]);\n * const bool = bytesToBool(bytes);\n * console.log(bool); // true\n * ```\n * @utils\n */\nexport function bytesToBool(bytes_, opts = {}) {\n    return ox__Bytes.toBoolean(bytes_, opts);\n}\n/**\n * Converts a Uint8Array of bytes to a number.\n * @param bytes - The Uint8Array of bytes to convert.\n * @param opts - Optional configuration options.\n * @returns The converted number.\n * @example\n * ```ts\n * import { bytesToNumber } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([1, 164]);\n * const number = bytesToNumber(bytes);\n * console.log(number); // 420\n * ```\n * @utils\n */\nexport function bytesToNumber(bytes, opts = {}) {\n    return ox__Bytes.toNumber(bytes, opts);\n}\n/**\n * Converts an array of bytes to a string using UTF-8 encoding.\n * @param bytes_ - The array of bytes to convert.\n * @param opts - Optional parameters for the conversion.\n * @returns The resulting string.\n * @example\n * ```ts\n * import { bytesToString } from \"thirdweb/utils\";\n * const bytes = new Uint8Array([72, 101, 108, 108, 111]);\n * const string = bytesToString(bytes);\n * console.log(string); // \"Hello\"\n * ```\n * @utils\n */\nexport function bytesToString(bytes_, opts = {}) {\n    return ox__Bytes.toString(bytes_, opts);\n}\n//# sourceMappingURL=from-bytes.js.map","import * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiConstructor from \"ox/AbiConstructor\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport * as ox__Signature from \"ox/Signature\";\nimport { WrappedSignature as ox__WrappedSignature } from \"ox/erc6492\";\nimport { getContract } from \"../contract/contract.js\";\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { isZkSyncChain } from \"../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { isContractDeployed } from \"../utils/bytecode/is-contract-deployed.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { hexToBool, isHex } from \"../utils/encoding/hex.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\nconst ZKSYNC_VALIDATOR_ADDRESS = \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n/**\n * @description Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash({ hash, signature, address, client, chain, accountFactory, }) {\n    const signatureHex = (() => {\n        if (isHex(signature))\n            return signature;\n        if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\n            return ox__Signature.toHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature, \"hex\");\n        // We should never hit this but TS doesn't know that\n        throw new Error(`Invalid signature type for signature ${signature}: ${typeof signature}`);\n    })();\n    const isDeployed = await isContractDeployed(getContract({\n        address,\n        client,\n        chain,\n    }));\n    if (isDeployed) {\n        const validEip1271 = await verifyEip1271Signature({\n            hash,\n            signature: signatureHex,\n            contract: getContract({\n                chain,\n                address,\n                client,\n            }),\n        }).catch((err) => {\n            console.error(\"Error verifying EIP-1271 signature\", err);\n            return false;\n        });\n        if (validEip1271) {\n            return true;\n        }\n    }\n    // contract not deployed, use erc6492 validator to verify signature\n    const wrappedSignature = await (async () => {\n        // If no factory is provided, we have to assume its already deployed or is an EOA\n        // TODO: Figure out how to automatically tell if our default factory was used\n        if (!accountFactory)\n            return signatureHex;\n        // If this sigature was already wrapped for ERC-6492, carry on\n        if (ox__WrappedSignature.validate(signatureHex))\n            return signatureHex;\n        // Otherwise, serialize the signature for ERC-6492 validation\n        return serializeErc6492Signature({\n            address: accountFactory.address,\n            data: accountFactory.verificationCalldata,\n            signature: signatureHex,\n        });\n    })();\n    let verificationData;\n    const zkSyncChain = await isZkSyncChain(chain);\n    const abi = ox__Abi.from(ox__WrappedSignature.universalSignatureValidatorAbi);\n    if (zkSyncChain) {\n        // zksync chains dont support deploying code with eth_call\n        // need to call a deployed contract instead\n        verificationData = {\n            to: ZKSYNC_VALIDATOR_ADDRESS,\n            data: ox__AbiFunction.encodeData(ox__AbiFunction.fromAbi(abi, \"isValidSig\"), [address, hash, wrappedSignature]),\n        };\n    }\n    else {\n        const validatorConstructor = ox__AbiConstructor.fromAbi(abi);\n        verificationData = {\n            data: ox__AbiConstructor.encode(validatorConstructor, {\n                args: [address, hash, wrappedSignature],\n                bytecode: ox__WrappedSignature.universalSignatureValidatorBytecode,\n            }),\n        };\n    }\n    const rpcRequest = getRpcClient({\n        chain,\n        client,\n    });\n    try {\n        const result = await eth_call(rpcRequest, verificationData);\n        return hexToBool(result);\n    }\n    catch {\n        // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n        const validEip1271 = await verifyEip1271Signature({\n            hash,\n            signature: signatureHex,\n            contract: getContract({\n                chain,\n                address,\n                client,\n            }),\n        }).catch((err) => {\n            console.error(\"Error verifying EIP-1271 signature\", err);\n            return false;\n        });\n        if (validEip1271) {\n            return true;\n        }\n        // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n        // Verification failed somehow\n        return false;\n    }\n}\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nexport async function verifyEip1271Signature({ hash, signature, contract, }) {\n    try {\n        const result = await isValidSignature({\n            hash,\n            signature,\n            contract,\n        });\n        return result === EIP_1271_MAGIC_VALUE;\n    }\n    catch (err) {\n        console.error(\"Error verifying EIP-1271 signature\", err);\n        return false;\n    }\n}\n//# sourceMappingURL=verify-hash.js.map","import * as ox__Bytes from \"ox/Bytes\";\nimport { stringToBytes, toBytes } from \"../encoding/to-bytes.js\";\nimport { keccak256 } from \"./keccak256.js\";\nconst presignMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n/**\n * Ethereum Signed Message hashing\n * @param message - The message to hash, either as a string, a Uint8Array, or an object with a `raw` property containing a Uint8Array.\n * @param to_ - The desired output format of the hash (optional). Defaults to 'hex'.\n * @example\n * ```ts\n * import { hashMessage } from \"thirdweb/utils\";\n * const hash = hashMessage(\"hello world\");\n * ```\n * @returns The Ethereum Signed Message hash of the message in the specified format.\n * @utils\n */\nexport function hashMessage(message, to_) {\n    const messageBytes = (() => {\n        if (typeof message === \"string\") {\n            return stringToBytes(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n            return message.raw;\n        }\n        return toBytes(message.raw);\n    })();\n    const prefixBytes = stringToBytes(`${presignMessagePrefix}${messageBytes.length}`);\n    return keccak256(ox__Bytes.concat(prefixBytes, messageBytes), to_);\n}\n//# sourceMappingURL=hashMessage.js.map","import * as ox__Bytes from \"ox/Bytes\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { encodeAbiParameters } from \"../abi/encodeAbiParameters.js\";\nimport { toHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"./keccak256.js\";\n/**\n * @internal\n */\nexport function hashTypedData(parameters) {\n    const { domain = {}, message, primaryType, } = parameters;\n    const types = {\n        EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n        ...parameters.types,\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    ox__TypedData.validate({\n        domain,\n        message,\n        primaryType,\n        types,\n    });\n    const parts = [\"0x1901\"];\n    if (domain)\n        parts.push(ox__TypedData.hashDomain({\n            domain,\n            types: types,\n        }));\n    if (primaryType !== \"EIP712Domain\") {\n        const hashedStruct = (() => {\n            const encoded = encodeData({\n                data: message,\n                primaryType,\n                types: types,\n            });\n            return keccak256(encoded);\n        })();\n        parts.push(hashedStruct);\n    }\n    return keccak256(ox__Bytes.concat(...parts.map((p) => ox__Bytes.fromHex(p))));\n}\nfunction encodeData({ data, primaryType, types, }) {\n    const encodedTypes = [{ type: \"bytes32\" }];\n    const encodedValues = [hashType({ primaryType, types })];\n    if (!types[primaryType])\n        throw new Error(\"Invalid types\");\n    for (const field of types[primaryType]) {\n        const [type, value] = encodeField({\n            types,\n            name: field.name,\n            type: field.type,\n            value: data[field.name],\n        });\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType({ primaryType, types, }) {\n    const encodedHashType = toHex(encodeType({ primaryType, types }));\n    return keccak256(encodedHashType);\n}\nfunction encodeType({ primaryType, types, }) {\n    let result = \"\";\n    const unsortedDeps = findTypeDependencies({ primaryType, types });\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        if (!types[type])\n            throw new Error(\"Invalid types\");\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(\",\")})`;\n    }\n    return result;\n}\nfunction findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {\n    const match = primaryType_.match(/^\\w*/u);\n    const primaryType = match?.[0];\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies({ primaryType: field.type, types }, results);\n    }\n    return results;\n}\nfunction encodeField({ types, name, type, value, }) {\n    if (types[type] !== undefined) {\n        return [\n            { type: \"bytes32\" },\n            keccak256(encodeData({ data: value, primaryType: type, types })),\n        ];\n    }\n    if (type === \"bytes\") {\n        const prepend = value.length % 2 ? \"0\" : \"\";\n        value = `0x${prepend + value.slice(2)}`;\n        return [{ type: \"bytes32\" }, keccak256(value)];\n    }\n    if (type === \"string\")\n        return [{ type: \"bytes32\" }, keccak256(toHex(value))];\n    if (type.lastIndexOf(\"]\") === type.length - 1) {\n        const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n        const typeValuePairs = \n        // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n        value.map((item) => encodeField({\n            name,\n            type: parsedType,\n            types,\n            value: item,\n        }));\n        return [\n            { type: \"bytes32\" },\n            keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),\n        ];\n    }\n    return [{ type }, value];\n}\n//# sourceMappingURL=hashTypedData.js.map","import { serializeErc6492Signature } from \"../../../auth/serialize-erc6492-signature.js\";\nimport { verifyEip1271Signature, verifyHash, } from \"../../../auth/verify-hash.js\";\nimport { getContract, } from \"../../../contract/contract.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { hashMessage } from \"../../../utils/hashing/hashMessage.js\";\nimport { hashTypedData } from \"../../../utils/hashing/hashTypedData.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\n/**\n * If the account is already deployed, generate an ERC-1271 signature.\n * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.\n *\n * @internal\n */\nexport async function smartAccountSignMessage({ accountContract, factoryContract, options, message, }) {\n    const originalMsgHash = hashMessage(message);\n    const is712Factory = await checkFor712Factory({\n        factoryContract,\n        accountContract,\n        originalMsgHash,\n    });\n    let sig;\n    if (is712Factory) {\n        const wrappedMessageHash = encodeAbiParameters([{ type: \"bytes32\" }], [originalMsgHash]);\n        sig = await options.personalAccount.signTypedData({\n            domain: {\n                name: \"Account\",\n                version: \"1\",\n                chainId: options.chain.id,\n                verifyingContract: accountContract.address,\n            },\n            primaryType: \"AccountMessage\",\n            types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n            message: { message: wrappedMessageHash },\n        });\n    }\n    else {\n        sig = await options.personalAccount.signMessage({ message });\n    }\n    const isDeployed = await isContractDeployed(accountContract);\n    if (isDeployed) {\n        const isValid = await verifyEip1271Signature({\n            hash: originalMsgHash,\n            signature: sig,\n            contract: accountContract,\n        });\n        if (isValid) {\n            return sig;\n        }\n        throw new Error(\"Failed to verify signature\");\n    }\n    else {\n        const deployTx = prepareCreateAccount({\n            factoryContract,\n            adminAddress: options.personalAccount.address,\n            accountSalt: options.overrides?.accountSalt,\n            createAccountOverride: options.overrides?.createAccount,\n        });\n        if (!deployTx) {\n            throw new Error(\"Create account override not provided\");\n        }\n        const initCode = await encode(deployTx);\n        const erc6492Sig = serializeErc6492Signature({\n            address: factoryContract.address,\n            data: initCode,\n            signature: sig,\n        });\n        // check if the signature is valid\n        const isValid = await verifyHash({\n            hash: originalMsgHash,\n            signature: erc6492Sig,\n            address: accountContract.address,\n            chain: accountContract.chain,\n            client: accountContract.client,\n        });\n        if (isValid) {\n            return erc6492Sig;\n        }\n        throw new Error(\"Unable to verify ERC-6492 signature after signing.\");\n    }\n}\nexport async function smartAccountSignTypedData({ accountContract, factoryContract, options, typedData, }) {\n    const isSelfVerifyingContract = typedData.domain?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n    if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n    }\n    const originalMsgHash = hashTypedData(typedData);\n    // check if the account contract supports EIP721 domain separator based signing\n    const is712Factory = await checkFor712Factory({\n        factoryContract,\n        accountContract,\n        originalMsgHash,\n    });\n    let sig;\n    if (is712Factory) {\n        const wrappedMessageHash = encodeAbiParameters([{ type: \"bytes32\" }], [originalMsgHash]);\n        sig = await options.personalAccount.signTypedData({\n            domain: {\n                name: \"Account\",\n                version: \"1\",\n                chainId: options.chain.id,\n                verifyingContract: accountContract.address,\n            },\n            primaryType: \"AccountMessage\",\n            types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n            message: { message: wrappedMessageHash },\n        });\n    }\n    else {\n        sig = await options.personalAccount.signTypedData(typedData);\n    }\n    const isDeployed = await isContractDeployed(accountContract);\n    if (isDeployed) {\n        const isValid = await verifyEip1271Signature({\n            hash: originalMsgHash,\n            signature: sig,\n            contract: accountContract,\n        });\n        if (isValid) {\n            return sig;\n        }\n        throw new Error(\"Failed to verify signature\");\n    }\n    else {\n        const deployTx = prepareCreateAccount({\n            factoryContract,\n            adminAddress: options.personalAccount.address,\n            accountSalt: options.overrides?.accountSalt,\n            createAccountOverride: options.overrides?.createAccount,\n        });\n        if (!deployTx) {\n            throw new Error(\"Create account override not provided\");\n        }\n        const initCode = await encode(deployTx);\n        const erc6492Sig = serializeErc6492Signature({\n            address: factoryContract.address,\n            data: initCode,\n            signature: sig,\n        });\n        // check if the signature is valid\n        const isValid = await verifyHash({\n            hash: originalMsgHash,\n            signature: erc6492Sig,\n            address: accountContract.address,\n            chain: accountContract.chain,\n            client: accountContract.client,\n        });\n        if (isValid) {\n            return erc6492Sig;\n        }\n        throw new Error(\"Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.\");\n    }\n}\nexport async function confirmContractDeployment(args) {\n    const { accountContract } = args;\n    const startTime = Date.now();\n    const timeout = 60000; // wait 1 minute max\n    const { isContractDeployed } = await import(\"../../../utils/bytecode/is-contract-deployed.js\");\n    let isDeployed = await isContractDeployed(accountContract);\n    while (!isDeployed) {\n        if (Date.now() - startTime > timeout) {\n            throw new Error(\"Timeout: Smart account deployment not confirmed after 1 minute\");\n        }\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        isDeployed = await isContractDeployed(accountContract);\n    }\n}\nasync function checkFor712Factory({ factoryContract, accountContract, originalMsgHash, }) {\n    try {\n        const implementationAccount = await readContract({\n            contract: factoryContract,\n            method: \"function accountImplementation() public view returns (address)\",\n        });\n        // check if the account contract supports EIP721 domain separator or modular based signing\n        const is712Factory = await readContract({\n            contract: getContract({\n                address: implementationAccount,\n                chain: accountContract.chain,\n                client: accountContract.client,\n            }),\n            method: \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n            params: [originalMsgHash],\n        })\n            .then((res) => res !== \"0x\")\n            .catch(() => false);\n        return is712Factory;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.\n *\n * @param args - Arguments for the deployment.\n * @param args.smartAccount - The smart account to deploy.\n * @param args.chain - The chain to deploy on.\n * @param args.client - The client to use for the deployment.\n * @param args.accountContract - The account contract to deploy.\n *\n * @example\n * ```ts\n * import { deploySmartAccount } from \"thirdweb\";\n *\n * const account = await deploySmartAccount({\n *   smartAccount,\n *   chain,\n *   client,\n *   accountContract,\n * });\n * ```\n *\n * @wallet\n */\nexport async function deploySmartAccount(args) {\n    const { chain, client, smartAccount, accountContract } = args;\n    const isDeployed = await isContractDeployed(accountContract);\n    if (isDeployed) {\n        return;\n    }\n    const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n        import(\"../../../transaction/actions/send-transaction.js\"),\n        import(\"../../../transaction/prepare-transaction.js\"),\n    ]);\n    const dummyTx = prepareTransaction({\n        client: client,\n        chain: chain,\n        to: accountContract.address,\n        value: 0n,\n        gas: 50000n, // force gas to avoid simulation error\n    });\n    const deployResult = await sendTransaction({\n        transaction: dummyTx,\n        account: smartAccount,\n    });\n    await confirmContractDeployment({\n        accountContract,\n    });\n    return deployResult;\n}\n//# sourceMappingURL=signing.js.map"],"names":[],"sourceRoot":""}