{"version":3,"file":"10772.js","mappings":"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","sources":["webpack://unreal/./node_modules/.pnpm/@walletconnect+jsonrpc-http-connection@1.0.8_encoding@0.1.13/node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js","webpack://unreal/./node_modules/.pnpm/@walletconnect+universal-provider@2.19.1_aws4fetch@1.0.20_encoding@0.1.13_typescript@5.8.2_zod@3.22.3/node_modules/@walletconnect/universal-provider/dist/index.es.js","webpack://unreal/./node_modules/.pnpm/@walletconnect+ethereum-provider@2.19.1_@types+react@19.0.12_aws4fetch@1.0.20_encoding@0.1.13_7zbxd2dymugbnqpjzm7w4fsmze/node_modules/@walletconnect/ethereum-provider/dist/index.es.js","webpack://unreal/./node_modules/.pnpm/cross-fetch@3.2.0_encoding@0.1.13/node_modules/cross-fetch/dist/node-ponyfill.js","webpack://unreal/./node_modules/.pnpm/node-fetch@2.7.0_encoding@0.1.13/node_modules/node-fetch/lib/index.mjs"],"sourcesContent":["import{EventEmitter as m}from\"events\";import o from\"cross-fetch\";import{safeJsonStringify as a,safeJsonParse as y}from\"@walletconnect/safe-json\";import{isHttpUrl as h,formatJsonRpcError as b,parseConnectionError as u}from\"@walletconnect/jsonrpc-utils\";var P=Object.defineProperty,w=Object.defineProperties,E=Object.getOwnPropertyDescriptors,c=Object.getOwnPropertySymbols,L=Object.prototype.hasOwnProperty,O=Object.prototype.propertyIsEnumerable,l=(r,t,e)=>t in r?P(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,p=(r,t)=>{for(var e in t||(t={}))L.call(t,e)&&l(r,e,t[e]);if(c)for(var e of c(t))O.call(t,e)&&l(r,e,t[e]);return r},v=(r,t)=>w(r,E(t));const j={Accept:\"application/json\",\"Content-Type\":\"application/json\"},T=\"POST\",d={headers:j,method:T},g=10;class f{constructor(t,e=!1){if(this.url=t,this.disableProviderPing=e,this.events=new m,this.isAvailable=!1,this.registering=!1,!h(t))throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);this.url=t,this.disableProviderPing=e}get connected(){return this.isAvailable}get connecting(){return this.registering}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}off(t,e){this.events.off(t,e)}removeListener(t,e){this.events.removeListener(t,e)}async open(t=this.url){await this.register(t)}async close(){if(!this.isAvailable)throw new Error(\"Connection already closed\");this.onClose()}async send(t){this.isAvailable||await this.register();try{const e=a(t),s=await(await o(this.url,v(p({},d),{body:e}))).json();this.onPayload({data:s})}catch(e){this.onError(t.id,e)}}async register(t=this.url){if(!h(t))throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);if(this.registering){const e=this.events.getMaxListeners();return(this.events.listenerCount(\"register_error\")>=e||this.events.listenerCount(\"open\")>=e)&&this.events.setMaxListeners(e+1),new Promise((s,i)=>{this.events.once(\"register_error\",n=>{this.resetMaxListeners(),i(n)}),this.events.once(\"open\",()=>{if(this.resetMaxListeners(),typeof this.isAvailable>\"u\")return i(new Error(\"HTTP connection is missing or invalid\"));s()})})}this.url=t,this.registering=!0;try{if(!this.disableProviderPing){const e=a({id:1,jsonrpc:\"2.0\",method:\"test\",params:[]});await o(t,v(p({},d),{body:e}))}this.onOpen()}catch(e){const s=this.parseError(e);throw this.events.emit(\"register_error\",s),this.onClose(),s}}onOpen(){this.isAvailable=!0,this.registering=!1,this.events.emit(\"open\")}onClose(){this.isAvailable=!1,this.registering=!1,this.events.emit(\"close\")}onPayload(t){if(typeof t.data>\"u\")return;const e=typeof t.data==\"string\"?y(t.data):t.data;this.events.emit(\"payload\",e)}onError(t,e){const s=this.parseError(e),i=s.message||s.toString(),n=b(t,i);this.events.emit(\"payload\",n)}parseError(t,e=this.url){return u(t,e,\"HTTP\")}resetMaxListeners(){this.events.getMaxListeners()>g&&this.events.setMaxListeners(g)}}export{f as HttpConnection,f as default};\n//# sourceMappingURL=index.es.js.map\n","import bt from\"@walletconnect/sign-client\";import{isValidObject as It,isCaipNamespace as Y,parseNamespaceKey as q,mergeArrays as M,parseChainId as Q,getSdkError as Z,isValidArray as T}from\"@walletconnect/utils\";import{pino as $t,getDefaultLoggerOptions as Ot}from\"@walletconnect/logger\";import m,{HttpConnection as At}from\"@walletconnect/jsonrpc-http-connection\";import{JsonRpcProvider as l}from\"@walletconnect/jsonrpc-provider\";import{formatJsonRpcRequest as Ht,formatJsonRpcResult as Et}from\"@walletconnect/jsonrpc-utils\";import Ct from\"events\";const tt=\"error\",Nt=\"wss://relay.walletconnect.org\",St=\"wc\",Dt=\"universal_provider\",_=`${St}@2:${Dt}:`,et=\"https://rpc.walletconnect.org/v1/\",w=\"generic\",qt=`${et}bundler`,d={DEFAULT_CHAIN_CHANGED:\"default_chain_changed\"};function jt(){}function B(s){return s==null||typeof s!=\"object\"&&typeof s!=\"function\"}function G(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)}function Rt(s){if(B(s))return s;if(Array.isArray(s)||G(s)||s instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&s instanceof SharedArrayBuffer)return s.slice(0);const t=Object.getPrototypeOf(s),e=t.constructor;if(s instanceof Date||s instanceof Map||s instanceof Set)return new e(s);if(s instanceof RegExp){const i=new e(s);return i.lastIndex=s.lastIndex,i}if(s instanceof DataView)return new e(s.buffer.slice(0));if(s instanceof Error){const i=new e(s.message);return i.stack=s.stack,i.name=s.name,i.cause=s.cause,i}if(typeof File<\"u\"&&s instanceof File)return new e([s],s.name,{type:s.type,lastModified:s.lastModified});if(typeof s==\"object\"){const i=Object.create(t);return Object.assign(i,s)}return s}function st(s){return typeof s==\"object\"&&s!==null}function it(s){return Object.getOwnPropertySymbols(s).filter(t=>Object.prototype.propertyIsEnumerable.call(s,t))}function rt(s){return s==null?s===void 0?\"[object Undefined]\":\"[object Null]\":Object.prototype.toString.call(s)}const _t=\"[object RegExp]\",nt=\"[object String]\",at=\"[object Number]\",ct=\"[object Boolean]\",ot=\"[object Arguments]\",Ut=\"[object Symbol]\",Ft=\"[object Date]\",Lt=\"[object Map]\",xt=\"[object Set]\",Mt=\"[object Array]\",Bt=\"[object ArrayBuffer]\",Gt=\"[object Object]\",Jt=\"[object DataView]\",zt=\"[object Uint8Array]\",kt=\"[object Uint8ClampedArray]\",Wt=\"[object Uint16Array]\",Kt=\"[object Uint32Array]\",Vt=\"[object Int8Array]\",Xt=\"[object Int16Array]\",Yt=\"[object Int32Array]\",Qt=\"[object Float32Array]\",Zt=\"[object Float64Array]\";function Tt(s,t){return y(s,void 0,s,new Map,t)}function y(s,t,e,i=new Map,r=void 0){const a=r?.(s,t,e,i);if(a!=null)return a;if(B(s))return s;if(i.has(s))return i.get(s);if(Array.isArray(s)){const n=new Array(s.length);i.set(s,n);for(let c=0;c<s.length;c++)n[c]=y(s[c],c,e,i,r);return Object.hasOwn(s,\"index\")&&(n.index=s.index),Object.hasOwn(s,\"input\")&&(n.input=s.input),n}if(s instanceof Date)return new Date(s.getTime());if(s instanceof RegExp){const n=new RegExp(s.source,s.flags);return n.lastIndex=s.lastIndex,n}if(s instanceof Map){const n=new Map;i.set(s,n);for(const[c,h]of s)n.set(c,y(h,c,e,i,r));return n}if(s instanceof Set){const n=new Set;i.set(s,n);for(const c of s)n.add(y(c,void 0,e,i,r));return n}if(typeof Buffer<\"u\"&&Buffer.isBuffer(s))return s.subarray();if(G(s)){const n=new(Object.getPrototypeOf(s)).constructor(s.length);i.set(s,n);for(let c=0;c<s.length;c++)n[c]=y(s[c],c,e,i,r);return n}if(s instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&s instanceof SharedArrayBuffer)return s.slice(0);if(s instanceof DataView){const n=new DataView(s.buffer.slice(0),s.byteOffset,s.byteLength);return i.set(s,n),g(n,s,e,i,r),n}if(typeof File<\"u\"&&s instanceof File){const n=new File([s],s.name,{type:s.type});return i.set(s,n),g(n,s,e,i,r),n}if(s instanceof Blob){const n=new Blob([s],{type:s.type});return i.set(s,n),g(n,s,e,i,r),n}if(s instanceof Error){const n=new s.constructor;return i.set(s,n),n.message=s.message,n.name=s.name,n.stack=s.stack,n.cause=s.cause,g(n,s,e,i,r),n}if(typeof s==\"object\"&&te(s)){const n=Object.create(Object.getPrototypeOf(s));return i.set(s,n),g(n,s,e,i,r),n}return s}function g(s,t,e=s,i,r){const a=[...Object.keys(t),...it(t)];for(let n=0;n<a.length;n++){const c=a[n],h=Object.getOwnPropertyDescriptor(s,c);(h==null||h.writable)&&(s[c]=y(t[c],c,e,i,r))}}function te(s){switch(rt(s)){case ot:case Mt:case Bt:case Jt:case ct:case Ft:case Qt:case Zt:case Vt:case Xt:case Yt:case Lt:case at:case Gt:case _t:case xt:case nt:case Ut:case zt:case kt:case Wt:case Kt:return!0;default:return!1}}function ee(s,t){return Tt(s,(e,i,r,a)=>{const n=t?.(e,i,r,a);if(n!=null)return n;if(typeof s==\"object\")switch(Object.prototype.toString.call(s)){case at:case nt:case ct:{const c=new s.constructor(s?.valueOf());return g(c,s),c}case ot:{const c={};return g(c,s),c.length=s.length,c[Symbol.iterator]=s[Symbol.iterator],c}default:return}})}function ht(s){return ee(s)}function pt(s){return s!==null&&typeof s==\"object\"&&rt(s)===\"[object Arguments]\"}function se(s){return G(s)}function ie(s){if(typeof s!=\"object\"||s==null)return!1;if(Object.getPrototypeOf(s)===null)return!0;if(Object.prototype.toString.call(s)!==\"[object Object]\"){const e=s[Symbol.toStringTag];return e==null||!Object.getOwnPropertyDescriptor(s,Symbol.toStringTag)?.writable?!1:s.toString()===`[object ${e}]`}let t=s;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(s)===t}function re(s,...t){const e=t.slice(0,-1),i=t[t.length-1];let r=s;for(let a=0;a<e.length;a++){const n=e[a];r=U(r,n,i,new Map)}return r}function U(s,t,e,i){if(B(s)&&(s=Object(s)),t==null||typeof t!=\"object\")return s;if(i.has(t))return Rt(i.get(t));if(i.set(t,s),Array.isArray(t)){t=t.slice();for(let a=0;a<t.length;a++)t[a]=t[a]??void 0}const r=[...Object.keys(t),...it(t)];for(let a=0;a<r.length;a++){const n=r[a];let c=t[n],h=s[n];if(pt(c)&&(c={...c}),pt(h)&&(h={...h}),typeof Buffer<\"u\"&&Buffer.isBuffer(c)&&(c=ht(c)),Array.isArray(c))if(typeof h==\"object\"&&h!=null){const j=[],R=Reflect.ownKeys(h);for(let f=0;f<R.length;f++){const X=R[f];j[X]=h[X]}h=j}else h=[];const v=e(h,c,n,s,t,i);v!=null?s[n]=v:Array.isArray(c)||st(h)&&st(c)?s[n]=U(h,c,e,i):h==null&&ie(c)?s[n]=U({},c,e,i):h==null&&se(c)?s[n]=ht(c):(h===void 0||c!==void 0)&&(s[n]=c)}return s}function ne(s,...t){return re(s,...t,jt)}var ae=Object.defineProperty,ce=Object.defineProperties,oe=Object.getOwnPropertyDescriptors,dt=Object.getOwnPropertySymbols,he=Object.prototype.hasOwnProperty,pe=Object.prototype.propertyIsEnumerable,ut=(s,t,e)=>t in s?ae(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,F=(s,t)=>{for(var e in t||(t={}))he.call(t,e)&&ut(s,e,t[e]);if(dt)for(var e of dt(t))pe.call(t,e)&&ut(s,e,t[e]);return s},de=(s,t)=>ce(s,oe(t));function p(s,t,e){var i;const r=Q(s);return((i=t.rpcMap)==null?void 0:i[r.reference])||`${et}?chainId=${r.namespace}:${r.reference}&projectId=${e}`}function P(s){return s.includes(\":\")?s.split(\":\")[1]:s}function lt(s){return s.map(t=>`${t.split(\":\")[0]}:${t.split(\":\")[1]}`)}function ue(s,t){const e=Object.keys(t.namespaces).filter(r=>r.includes(s));if(!e.length)return[];const i=[];return e.forEach(r=>{const a=t.namespaces[r].accounts;i.push(...a)}),i}function J(s={},t={}){const e=ft(s),i=ft(t);return ne(e,i)}function ft(s){var t,e,i,r;const a={};if(!It(s))return a;for(const[n,c]of Object.entries(s)){const h=Y(n)?[n]:c.chains,v=c.methods||[],j=c.events||[],R=c.rpcMap||{},f=q(n);a[f]=de(F(F({},a[f]),c),{chains:M(h,(t=a[f])==null?void 0:t.chains),methods:M(v,(e=a[f])==null?void 0:e.methods),events:M(j,(i=a[f])==null?void 0:i.events),rpcMap:F(F({},R),(r=a[f])==null?void 0:r.rpcMap)})}return a}function le(s){return s.includes(\":\")?s.split(\":\")[2]:s}function mt(s){const t={};for(const[e,i]of Object.entries(s)){const r=i.methods||[],a=i.events||[],n=i.accounts||[],c=Y(e)?[e]:i.chains?i.chains:lt(i.accounts);t[e]={chains:c,methods:r,events:a,accounts:n}}return t}function z(s){return typeof s==\"number\"?s:s.includes(\"0x\")?parseInt(s,16):(s=s.includes(\":\")?s.split(\":\")[1]:s,isNaN(Number(s))?s:Number(s))}const vt={},o=s=>vt[s],k=(s,t)=>{vt[s]=t};var fe=Object.defineProperty,me=(s,t,e)=>t in s?fe(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,b=(s,t,e)=>me(s,typeof t!=\"symbol\"?t+\"\":t,e);class ve{constructor(t){b(this,\"name\",\"polkadot\"),b(this,\"client\"),b(this,\"httpProviders\"),b(this,\"events\"),b(this,\"namespace\"),b(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const r=P(e);t[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new m(i,o(\"disableProviderPing\")))}}var ge=Object.defineProperty,Pe=Object.defineProperties,we=Object.getOwnPropertyDescriptors,gt=Object.getOwnPropertySymbols,ye=Object.prototype.hasOwnProperty,be=Object.prototype.propertyIsEnumerable,W=(s,t,e)=>t in s?ge(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,Pt=(s,t)=>{for(var e in t||(t={}))ye.call(t,e)&&W(s,e,t[e]);if(gt)for(var e of gt(t))be.call(t,e)&&W(s,e,t[e]);return s},wt=(s,t)=>Pe(s,we(t)),I=(s,t,e)=>W(s,typeof t!=\"symbol\"?t+\"\":t,e);class Ie{constructor(t){I(this,\"name\",\"eip155\"),I(this,\"client\"),I(this,\"chainId\"),I(this,\"namespace\"),I(this,\"httpProviders\"),I(this,\"events\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(t){switch(t.request.method){case\"eth_requestAccounts\":return this.getAccounts();case\"eth_accounts\":return this.getAccounts();case\"wallet_switchEthereumChain\":return await this.handleSwitchChain(t);case\"eth_chainId\":return parseInt(this.getDefaultChain());case\"wallet_getCapabilities\":return await this.getCapabilities(t);case\"wallet_getCallsStatus\":return await this.getCallStatus(t)}return this.namespace.methods.includes(t.request.method)?await this.client.request(t):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(parseInt(t),e),this.chainId=parseInt(t),this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}createHttpProvider(t,e){const i=e||p(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new At(i,o(\"disableProviderPing\")))}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const r=parseInt(P(e));t[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}getHttpProvider(){const t=this.chainId,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}async handleSwitchChain(t){var e,i;let r=t.request.params?(e=t.request.params[0])==null?void 0:e.chainId:\"0x0\";r=r.startsWith(\"0x\")?r:`0x${r}`;const a=parseInt(r,16);if(this.isChainApproved(a))this.setDefaultChain(`${a}`);else if(this.namespace.methods.includes(\"wallet_switchEthereumChain\"))await this.client.request({topic:t.topic,request:{method:t.request.method,params:[{chainId:r}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${a}`);else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(t){return this.namespace.chains.includes(`${this.name}:${t}`)}async getCapabilities(t){var e,i,r;const a=(i=(e=t.request)==null?void 0:e.params)==null?void 0:i[0];if(!a)throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");const n=this.client.session.get(t.topic),c=((r=n?.sessionProperties)==null?void 0:r.capabilities)||{};if(c!=null&&c[a])return c?.[a];const h=await this.client.request(t);try{await this.client.session.update(t.topic,{sessionProperties:wt(Pt({},n.sessionProperties||{}),{capabilities:wt(Pt({},c||{}),{[a]:h})})})}catch(v){console.warn(\"Failed to update session with capabilities\",v)}return h}async getCallStatus(t){var e,i;const r=this.client.session.get(t.topic),a=(e=r.sessionProperties)==null?void 0:e.bundler_name;if(a){const c=this.getBundlerUrl(t.chainId,a);try{return await this.getUserOperationReceipt(c,t)}catch(h){console.warn(\"Failed to fetch call status from bundler\",h,c)}}const n=(i=r.sessionProperties)==null?void 0:i.bundler_url;if(n)try{return await this.getUserOperationReceipt(n,t)}catch(c){console.warn(\"Failed to fetch call status from custom bundler\",c,n)}if(this.namespace.methods.includes(t.request.method))return await this.client.request(t);throw new Error(\"Fetching call status not approved by the wallet.\")}async getUserOperationReceipt(t,e){var i;const r=new URL(t),a=await fetch(r,{method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify(Ht(\"eth_getUserOperationReceipt\",[(i=e.request.params)==null?void 0:i[0]]))});if(!a.ok)throw new Error(`Failed to fetch user operation receipt - ${a.status}`);return await a.json()}getBundlerUrl(t,e){return`${qt}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`}}var $e=Object.defineProperty,Oe=(s,t,e)=>t in s?$e(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,$=(s,t,e)=>Oe(s,typeof t!=\"symbol\"?t+\"\":t,e);class Ae{constructor(t){$(this,\"name\",\"solana\"),$(this,\"client\"),$(this,\"httpProviders\"),$(this,\"events\"),$(this,\"namespace\"),$(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const r=P(e);t[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new m(i,o(\"disableProviderPing\")))}}var He=Object.defineProperty,Ee=(s,t,e)=>t in s?He(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,O=(s,t,e)=>Ee(s,typeof t!=\"symbol\"?t+\"\":t,e);class Ce{constructor(t){O(this,\"name\",\"cosmos\"),O(this,\"client\"),O(this,\"httpProviders\"),O(this,\"events\"),O(this,\"namespace\"),O(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const r=P(e);t[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new m(i,o(\"disableProviderPing\")))}}var Ne=Object.defineProperty,Se=(s,t,e)=>t in s?Ne(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,A=(s,t,e)=>Se(s,typeof t!=\"symbol\"?t+\"\":t,e);class De{constructor(t){A(this,\"name\",\"algorand\"),A(this,\"client\"),A(this,\"httpProviders\"),A(this,\"events\"),A(this,\"namespace\"),A(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(!this.httpProviders[t]){const i=e||p(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;t[e]=this.createHttpProvider(e,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace,this.client.core.projectId);return typeof i>\"u\"?void 0:new l(new m(i,o(\"disableProviderPing\")))}}var qe=Object.defineProperty,je=(s,t,e)=>t in s?qe(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,H=(s,t,e)=>je(s,typeof t!=\"symbol\"?t+\"\":t,e);class Re{constructor(t){H(this,\"name\",\"cip34\"),H(this,\"client\"),H(this,\"httpProviders\"),H(this,\"events\"),H(this,\"namespace\"),H(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{const i=this.getCardanoRPCUrl(e),r=P(e);t[r]=this.createHttpProvider(r,i)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}getCardanoRPCUrl(t){const e=this.namespace.rpcMap;if(e)return e[t]}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||this.getCardanoRPCUrl(t);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new m(i,o(\"disableProviderPing\")))}}var _e=Object.defineProperty,Ue=(s,t,e)=>t in s?_e(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,E=(s,t,e)=>Ue(s,typeof t!=\"symbol\"?t+\"\":t,e);class Fe{constructor(t){E(this,\"name\",\"elrond\"),E(this,\"client\"),E(this,\"httpProviders\"),E(this,\"events\"),E(this,\"namespace\"),E(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const r=P(e);t[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new m(i,o(\"disableProviderPing\")))}}var Le=Object.defineProperty,xe=(s,t,e)=>t in s?Le(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,C=(s,t,e)=>xe(s,typeof t!=\"symbol\"?t+\"\":t,e);class Me{constructor(t){C(this,\"name\",\"multiversx\"),C(this,\"client\"),C(this,\"httpProviders\"),C(this,\"events\"),C(this,\"namespace\"),C(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;const r=P(e);t[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new m(i,o(\"disableProviderPing\")))}}var Be=Object.defineProperty,Ge=(s,t,e)=>t in s?Be(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,N=(s,t,e)=>Ge(s,typeof t!=\"symbol\"?t+\"\":t,e);class Je{constructor(t){N(this,\"name\",\"near\"),N(this,\"client\"),N(this,\"httpProviders\"),N(this,\"events\"),N(this,\"namespace\"),N(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const i=e||p(`${this.name}:${t}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var i;t[e]=this.createHttpProvider(e,(i=this.namespace.rpcMap)==null?void 0:i[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace);return typeof i>\"u\"?void 0:new l(new m(i,o(\"disableProviderPing\")))}}var ze=Object.defineProperty,ke=(s,t,e)=>t in s?ze(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,S=(s,t,e)=>ke(s,typeof t!=\"symbol\"?t+\"\":t,e);class We{constructor(t){S(this,\"name\",\"tezos\"),S(this,\"client\"),S(this,\"httpProviders\"),S(this,\"events\"),S(this,\"namespace\"),S(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const i=e||p(`${this.name}:${t}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace);return typeof i>\"u\"?void 0:new l(new m(i))}}var Ke=Object.defineProperty,Ve=(s,t,e)=>t in s?Ke(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,D=(s,t,e)=>Ve(s,typeof t!=\"symbol\"?t+\"\":t,e);class Xe{constructor(t){D(this,\"name\",w),D(this,\"client\"),D(this,\"httpProviders\"),D(this,\"events\"),D(this,\"namespace\"),D(this,\"chainId\"),this.namespace=t.namespace,this.events=o(\"events\"),this.client=o(\"client\"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(t.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(t.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(t.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(t.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider(t.chainId).request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(d.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error(\"ChainId not found\");return t.split(\":\")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(\":\")[1]===this.chainId.toString()).map(e=>e.split(\":\")[2]))]:[]}createHttpProviders(){var t,e;const i={};return(e=(t=this.namespace)==null?void 0:t.accounts)==null||e.forEach(r=>{const a=Q(r);i[`${a.namespace}:${a.reference}`]=this.createHttpProvider(r)}),i}getHttpProvider(t){const e=this.httpProviders[t];if(typeof e>\"u\")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||p(t,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);return new l(new m(i,o(\"disableProviderPing\")))}}var Ye=Object.defineProperty,Qe=Object.defineProperties,Ze=Object.getOwnPropertyDescriptors,yt=Object.getOwnPropertySymbols,Te=Object.prototype.hasOwnProperty,ts=Object.prototype.propertyIsEnumerable,K=(s,t,e)=>t in s?Ye(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,L=(s,t)=>{for(var e in t||(t={}))Te.call(t,e)&&K(s,e,t[e]);if(yt)for(var e of yt(t))ts.call(t,e)&&K(s,e,t[e]);return s},V=(s,t)=>Qe(s,Ze(t)),u=(s,t,e)=>K(s,typeof t!=\"symbol\"?t+\"\":t,e);class x{constructor(t){u(this,\"client\"),u(this,\"namespaces\"),u(this,\"optionalNamespaces\"),u(this,\"sessionProperties\"),u(this,\"scopedProperties\"),u(this,\"events\",new Ct),u(this,\"rpcProviders\",{}),u(this,\"session\"),u(this,\"providerOpts\"),u(this,\"logger\"),u(this,\"uri\"),u(this,\"disableProviderPing\",!1),this.providerOpts=t,this.logger=typeof t?.logger<\"u\"&&typeof t?.logger!=\"string\"?t.logger:$t(Ot({level:t?.logger||tt})),this.disableProviderPing=t?.disableProviderPing||!1}static async init(t){const e=new x(t);return await e.initialize(),e}async request(t,e,i){const[r,a]=this.validateChain(e);if(!this.session)throw new Error(\"Please call connect() before request()\");return await this.getProvider(r).request({request:L({},t),chainId:`${r}:${a}`,topic:this.session.topic,expiry:i})}sendAsync(t,e,i,r){const a=new Date().getTime();this.request(t,i,r).then(n=>e(null,Et(a,n))).catch(n=>e(n,void 0))}async enable(){if(!this.client)throw new Error(\"Sign Client not initialized\");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error(\"Please call connect() before enable()\");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:Z(\"USER_DISCONNECTED\")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error(\"Sign Client not initialized\");if(this.setNamespaces(t),await this.cleanupPendingPairings(),!t.skipPairing)return await this.pair(t.pairingTopic)}async authenticate(t,e){if(!this.client)throw new Error(\"Sign Client not initialized\");this.setNamespaces(t),await this.cleanupPendingPairings();const{uri:i,response:r}=await this.client.authenticate(t,e);i&&(this.uri=i,this.events.emit(\"display_uri\",i));const a=await r();if(this.session=a.session,this.session){const n=mt(this.session.namespaces);this.namespaces=J(this.namespaces,n),await this.persist(\"namespaces\",this.namespaces),this.onConnect()}return a}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){const{uri:e,approval:i}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});e&&(this.uri=e,this.events.emit(\"display_uri\",e));const r=await i();this.session=r;const a=mt(r.namespaces);return this.namespaces=J(this.namespaces,a),await this.persist(\"namespaces\",this.namespaces),await this.persist(\"optionalNamespaces\",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(t,e){try{if(!this.session)return;const[i,r]=this.validateChain(t),a=this.getProvider(i);a.name===w?a.setDefaultChain(`${i}:${r}`,e):a.setDefaultChain(r,e)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(t={}){this.logger.info(\"Cleaning up inactive pairings...\");const e=this.client.pairing.getAll();if(T(e)){for(const i of e)t.deletePairings?this.client.core.expirer.set(i.topic,0):await this.client.core.relayer.subscriber.unsubscribe(i.topic);this.logger.info(`Inactive pairings cleared: ${e.length}`)}}abortPairingAttempt(){this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\")}async checkStorage(){this.namespaces=await this.getFromStore(\"namespaces\")||{},this.optionalNamespaces=await this.getFromStore(\"optionalNamespaces\")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace(\"Initialized\"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var t,e;if(this.client=this.providerOpts.client||await bt.init({core:this.providerOpts.core,logger:this.providerOpts.logger||tt,relayUrl:this.providerOpts.relayUrl||Nt,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(i){throw this.logger.error(\"Failed to get session\",i),new Error(`The provided session: ${(e=(t=this.providerOpts)==null?void 0:t.session)==null?void 0:e.topic} doesn't exist in the Sign client`)}else{const i=this.client.session.getAll();this.session=i[0]}this.logger.trace(\"SignClient Initialized\")}createProviders(){if(!this.client)throw new Error(\"Sign Client not initialized\");if(!this.session)throw new Error(\"Session not initialized. Please call connect() before enable()\");const t=[...new Set(Object.keys(this.session.namespaces).map(e=>q(e)))];k(\"client\",this.client),k(\"events\",this.events),k(\"disableProviderPing\",this.disableProviderPing),t.forEach(e=>{if(!this.session)return;const i=ue(e,this.session),r=lt(i),a=J(this.namespaces,this.optionalNamespaces),n=V(L({},a[e]),{accounts:i,chains:r});switch(e){case\"eip155\":this.rpcProviders[e]=new Ie({namespace:n});break;case\"algorand\":this.rpcProviders[e]=new De({namespace:n});break;case\"solana\":this.rpcProviders[e]=new Ae({namespace:n});break;case\"cosmos\":this.rpcProviders[e]=new Ce({namespace:n});break;case\"polkadot\":this.rpcProviders[e]=new ve({namespace:n});break;case\"cip34\":this.rpcProviders[e]=new Re({namespace:n});break;case\"elrond\":this.rpcProviders[e]=new Fe({namespace:n});break;case\"multiversx\":this.rpcProviders[e]=new Me({namespace:n});break;case\"near\":this.rpcProviders[e]=new Je({namespace:n});break;case\"tezos\":this.rpcProviders[e]=new We({namespace:n});break;default:this.rpcProviders[w]?this.rpcProviders[w].updateNamespace(n):this.rpcProviders[w]=new Xe({namespace:n})}})}registerEventListeners(){if(typeof this.client>\"u\")throw new Error(\"Sign Client is not initialized\");this.client.on(\"session_ping\",t=>{var e;const{topic:i}=t;i===((e=this.session)==null?void 0:e.topic)&&this.events.emit(\"session_ping\",t)}),this.client.on(\"session_event\",t=>{var e;const{params:i,topic:r}=t;if(r!==((e=this.session)==null?void 0:e.topic))return;const{event:a}=i;if(a.name===\"accountsChanged\"){const n=a.data;n&&T(n)&&this.events.emit(\"accountsChanged\",n.map(le))}else if(a.name===\"chainChanged\"){const n=i.chainId,c=i.event.data,h=q(n),v=z(n)!==z(c)?`${h}:${z(c)}`:n;this.onChainChanged(v)}else this.events.emit(a.name,a.data);this.events.emit(\"session_event\",t)}),this.client.on(\"session_update\",({topic:t,params:e})=>{var i,r;if(t!==((i=this.session)==null?void 0:i.topic))return;const{namespaces:a}=e,n=(r=this.client)==null?void 0:r.session.get(t);this.session=V(L({},n),{namespaces:a}),this.onSessionUpdate(),this.events.emit(\"session_update\",{topic:t,params:e})}),this.client.on(\"session_delete\",async t=>{var e;t.topic===((e=this.session)==null?void 0:e.topic)&&(await this.cleanup(),this.events.emit(\"session_delete\",t),this.events.emit(\"disconnect\",V(L({},Z(\"USER_DISCONNECTED\")),{data:t.topic})))}),this.on(d.DEFAULT_CHAIN_CHANGED,t=>{this.onChainChanged(t,!0)})}getProvider(t){return this.rpcProviders[t]||this.rpcProviders[w]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var e;this.getProvider(t).updateNamespace((e=this.session)==null?void 0:e.namespaces[t])})}setNamespaces(t){const{namespaces:e,optionalNamespaces:i,sessionProperties:r,scopedProperties:a}=t;e&&Object.keys(e).length&&(this.namespaces=e),i&&Object.keys(i).length&&(this.optionalNamespaces=i),this.sessionProperties=r,this.scopedProperties=a}validateChain(t){const[e,i]=t?.split(\":\")||[\"\",\"\"];if(!this.namespaces||!Object.keys(this.namespaces).length)return[e,i];if(e&&!Object.keys(this.namespaces||{}).map(n=>q(n)).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);if(e&&i)return[e,i];const r=q(Object.keys(this.namespaces)[0]),a=this.rpcProviders[r].getDefaultChain();return[r,a]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}async onChainChanged(t,e=!1){if(!this.namespaces)return;const[i,r]=this.validateChain(t);r&&(e||this.getProvider(i).setDefaultChain(r),this.namespaces[i]?this.namespaces[i].defaultChain=r:this.namespaces[`${i}:${r}`]?this.namespaces[`${i}:${r}`].defaultChain=r:this.namespaces[`${i}:${r}`]={defaultChain:r},this.events.emit(\"chainChanged\",r),await this.persist(\"namespaces\",this.namespaces))}onConnect(){this.createProviders(),this.events.emit(\"connect\",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore(\"namespaces\"),await this.deleteFromStore(\"optionalNamespaces\"),await this.deleteFromStore(\"sessionProperties\"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(t,e){var i;const r=((i=this.session)==null?void 0:i.topic)||\"\";await this.client.core.storage.setItem(`${_}/${t}${r}`,e)}async getFromStore(t){var e;const i=((e=this.session)==null?void 0:e.topic)||\"\";return await this.client.core.storage.getItem(`${_}/${t}${i}`)}async deleteFromStore(t){var e;const i=((e=this.session)==null?void 0:e.topic)||\"\";await this.client.core.storage.removeItem(`${_}/${t}${i}`)}async cleanupStorage(){var t;try{if(((t=this.client)==null?void 0:t.session.length)>0)return;const e=await this.client.core.storage.getKeys();for(const i of e)i.startsWith(_)&&await this.client.core.storage.removeItem(i)}catch(e){this.logger.warn(\"Failed to cleanup storage\",e)}}}const es=x;export{es as UniversalProvider,x as default};\n//# sourceMappingURL=index.es.js.map\n","import{EventEmitter as A}from\"events\";import{getAccountsFromNamespaces as b,getSdkError as S,isValidArray as E}from\"@walletconnect/utils\";import{UniversalProvider as R}from\"@walletconnect/universal-provider\";const T=\"wc\",$=\"ethereum_provider\",j=`${T}@2:${$}:`,q=\"https://rpc.walletconnect.org/v1/\",u=[\"eth_sendTransaction\",\"personal_sign\"],M=[\"eth_accounts\",\"eth_requestAccounts\",\"eth_sendRawTransaction\",\"eth_sign\",\"eth_signTransaction\",\"eth_signTypedData\",\"eth_signTypedData_v3\",\"eth_signTypedData_v4\",\"eth_sendTransaction\",\"personal_sign\",\"wallet_switchEthereumChain\",\"wallet_addEthereumChain\",\"wallet_getPermissions\",\"wallet_requestPermissions\",\"wallet_registerOnboarding\",\"wallet_watchAsset\",\"wallet_scanQRCode\",\"wallet_sendCalls\",\"wallet_getCapabilities\",\"wallet_getCallsStatus\",\"wallet_showCallsStatus\"],m=[\"chainChanged\",\"accountsChanged\"],O=[\"chainChanged\",\"accountsChanged\",\"message\",\"disconnect\",\"connect\"];var N=Object.defineProperty,D=Object.defineProperties,U=Object.getOwnPropertyDescriptors,P=Object.getOwnPropertySymbols,Q=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable,y=(a,t,s)=>t in a?N(a,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[t]=s,g=(a,t)=>{for(var s in t||(t={}))Q.call(t,s)&&y(a,s,t[s]);if(P)for(var s of P(t))L.call(t,s)&&y(a,s,t[s]);return a},_=(a,t)=>D(a,U(t)),o=(a,t,s)=>y(a,typeof t!=\"symbol\"?t+\"\":t,s);function v(a){return Number(a[0].split(\":\")[1])}function C(a){return`0x${a.toString(16)}`}function x(a){const{chains:t,optionalChains:s,methods:i,optionalMethods:e,events:n,optionalEvents:h,rpcMap:l}=a;if(!E(t))throw new Error(\"Invalid chains\");const r={chains:t,methods:i||u,events:n||m,rpcMap:g({},t.length?{[v(t)]:l[v(t)]}:{})},d=n?.filter(p=>!m.includes(p)),c=i?.filter(p=>!u.includes(p));if(!s&&!h&&!e&&!(d!=null&&d.length)&&!(c!=null&&c.length))return{required:t.length?r:void 0};const I=d?.length&&c?.length||!s,f={chains:[...new Set(I?r.chains.concat(s||[]):s)],methods:[...new Set(r.methods.concat(e!=null&&e.length?e:M))],events:[...new Set(r.events.concat(h!=null&&h.length?h:O))],rpcMap:l};return{required:t.length?r:void 0,optional:s.length?f:void 0}}class w{constructor(){o(this,\"events\",new A),o(this,\"namespace\",\"eip155\"),o(this,\"accounts\",[]),o(this,\"signer\"),o(this,\"chainId\",1),o(this,\"modal\"),o(this,\"rpc\"),o(this,\"STORAGE_KEY\",j),o(this,\"on\",(t,s)=>(this.events.on(t,s),this)),o(this,\"once\",(t,s)=>(this.events.once(t,s),this)),o(this,\"removeListener\",(t,s)=>(this.events.removeListener(t,s),this)),o(this,\"off\",(t,s)=>(this.events.off(t,s),this)),o(this,\"parseAccount\",t=>this.isCompatibleChainId(t)?this.parseAccountId(t).address:t),this.signer={},this.rpc={}}static async init(t){const s=new w;return await s.initialize(t),s}async request(t,s){return await this.signer.request(t,this.formatChainId(this.chainId),s)}sendAsync(t,s,i){this.signer.sendAsync(t,s,this.formatChainId(this.chainId),i)}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:\"eth_requestAccounts\"})}async connect(t){if(!this.signer.client)throw new Error(\"Provider not initialized. Call init() first\");this.loadConnectOpts(t);const{required:s,optional:i}=x(this.rpc);try{const e=await new Promise(async(h,l)=>{var r;this.rpc.showQrModal&&((r=this.modal)==null||r.subscribeModal(c=>{!c.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),l(new Error(\"Connection request reset. Please try again.\")))}));const d=t!=null&&t.scopedProperties?{[this.namespace]:t.scopedProperties}:void 0;await this.signer.connect(_(g({namespaces:g({},s&&{[this.namespace]:s})},i&&{optionalNamespaces:{[this.namespace]:i}}),{pairingTopic:t?.pairingTopic,scopedProperties:d})).then(c=>{h(c)}).catch(c=>{l(new Error(c.message))})});if(!e)return;const n=b(e.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:n),this.setAccounts(n),this.events.emit(\"connect\",{chainId:C(this.chainId)})}catch(e){throw this.signer.logger.error(e),e}finally{this.modal&&this.modal.closeModal()}}async authenticate(t,s){if(!this.signer.client)throw new Error(\"Provider not initialized. Call init() first\");this.loadConnectOpts({chains:t?.chains});try{const i=await new Promise(async(n,h)=>{var l;this.rpc.showQrModal&&((l=this.modal)==null||l.subscribeModal(r=>{!r.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),h(new Error(\"Connection request reset. Please try again.\")))})),await this.signer.authenticate(_(g({},t),{chains:this.rpc.chains}),s).then(r=>{n(r)}).catch(r=>{h(new Error(r.message))})}),e=i.session;if(e){const n=b(e.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:n),this.setAccounts(n),this.events.emit(\"connect\",{chainId:C(this.chainId)})}return i}catch(i){throw this.signer.logger.error(i),i}finally{this.modal&&this.modal.closeModal()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on(\"session_event\",t=>{const{params:s}=t,{event:i}=s;i.name===\"accountsChanged\"?(this.accounts=this.parseAccounts(i.data),this.events.emit(\"accountsChanged\",this.accounts)):i.name===\"chainChanged\"?this.setChainId(this.formatChainId(i.data)):this.events.emit(i.name,i.data),this.events.emit(\"session_event\",t)}),this.signer.on(\"chainChanged\",t=>{const s=parseInt(t);this.chainId=s,this.events.emit(\"chainChanged\",C(this.chainId)),this.persist()}),this.signer.on(\"session_update\",t=>{this.events.emit(\"session_update\",t)}),this.signer.on(\"session_delete\",t=>{this.reset(),this.events.emit(\"session_delete\",t),this.events.emit(\"disconnect\",_(g({},S(\"USER_DISCONNECTED\")),{data:t.topic,name:\"USER_DISCONNECTED\"}))}),this.signer.on(\"display_uri\",t=>{var s,i;this.rpc.showQrModal&&((s=this.modal)==null||s.closeModal(),(i=this.modal)==null||i.openModal({uri:t})),this.events.emit(\"display_uri\",t)})}switchEthereumChain(t){this.request({method:\"wallet_switchEthereumChain\",params:[{chainId:t.toString(16)}]})}isCompatibleChainId(t){return typeof t==\"string\"?t.startsWith(`${this.namespace}:`):!1}formatChainId(t){return`${this.namespace}:${t}`}parseChainId(t){return Number(t.split(\":\")[1])}setChainIds(t){const s=t.filter(i=>this.isCompatibleChainId(i)).map(i=>this.parseChainId(i));s.length&&(this.chainId=s[0],this.events.emit(\"chainChanged\",C(this.chainId)),this.persist())}setChainId(t){if(this.isCompatibleChainId(t)){const s=this.parseChainId(t);this.chainId=s,this.switchEthereumChain(s)}}parseAccountId(t){const[s,i,e]=t.split(\":\");return{chainId:`${s}:${i}`,address:e}}setAccounts(t){this.accounts=t.filter(s=>this.parseChainId(this.parseAccountId(s).chainId)===this.chainId).map(s=>this.parseAccountId(s).address),this.events.emit(\"accountsChanged\",this.accounts)}getRpcConfig(t){var s,i;const e=(s=t?.chains)!=null?s:[],n=(i=t?.optionalChains)!=null?i:[],h=e.concat(n);if(!h.length)throw new Error(\"No chains specified in either `chains` or `optionalChains`\");const l=e.length?t?.methods||u:[],r=e.length?t?.events||m:[],d=t?.optionalMethods||[],c=t?.optionalEvents||[],I=t?.rpcMap||this.buildRpcMap(h,t.projectId),f=t?.qrModalOptions||void 0;return{chains:e?.map(p=>this.formatChainId(p)),optionalChains:n.map(p=>this.formatChainId(p)),methods:l,events:r,optionalMethods:d,optionalEvents:c,rpcMap:I,showQrModal:!!(t!=null&&t.showQrModal),qrModalOptions:f,projectId:t.projectId,metadata:t.metadata}}buildRpcMap(t,s){const i={};return t.forEach(e=>{i[e]=this.getRpcUrl(e,s)}),i}async initialize(t){if(this.rpc=this.getRpcConfig(t),this.chainId=this.rpc.chains.length?v(this.rpc.chains):v(this.rpc.optionalChains),this.signer=await R.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:t.disableProviderPing,relayUrl:t.relayUrl,storage:t.storage,storageOptions:t.storageOptions,customStoragePrefix:t.customStoragePrefix,telemetryEnabled:t.telemetryEnabled,logger:t.logger}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let s;try{const{WalletConnectModal:i}=await import(\"@walletconnect/modal\");s=i}catch{throw new Error(\"To use QR modal, please install @walletconnect/modal package\")}if(s)try{this.modal=new s(g({projectId:this.rpc.projectId},this.rpc.qrModalOptions))}catch(i){throw this.signer.logger.error(i),new Error(\"Could not generate WalletConnectModal Instance\")}}}loadConnectOpts(t){if(!t)return;const{chains:s,optionalChains:i,rpcMap:e}=t;s&&E(s)&&(this.rpc.chains=s.map(n=>this.formatChainId(n)),s.forEach(n=>{this.rpc.rpcMap[n]=e?.[n]||this.getRpcUrl(n)})),i&&E(i)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=i?.map(n=>this.formatChainId(n)),i.forEach(n=>{this.rpc.rpcMap[n]=e?.[n]||this.getRpcUrl(n)}))}getRpcUrl(t,s){var i;return((i=this.rpc.rpcMap)==null?void 0:i[t])||`${q}?chainId=eip155:${t}&projectId=${s||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const t=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),s=this.session.namespaces[`${this.namespace}:${t}`]?this.session.namespaces[`${this.namespace}:${t}`]:this.session.namespaces[this.namespace];this.setChainIds(t?[this.formatChainId(t)]:s?.accounts),this.setAccounts(s?.accounts)}catch(t){this.signer.logger.error(\"Failed to load persisted session, clearing state...\"),this.signer.logger.error(t),await this.disconnect().catch(s=>this.signer.logger.warn(s))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(t){return typeof t==\"string\"||t instanceof String?[this.parseAccount(t)]:t.map(s=>this.parseAccount(s))}}const z=w;export{z as EthereumProvider,O as OPTIONAL_EVENTS,M as OPTIONAL_METHODS,m as REQUIRED_EVENTS,u as REQUIRED_METHODS,w as default};\n//# sourceMappingURL=index.es.js.map\n","const nodeFetch = require('node-fetch')\nconst realFetch = nodeFetch.default || nodeFetch\n\nconst fetch = function (url, options) {\n  // Support schemaless URIs on the server for parity with the browser.\n  // Ex: //github.com/ -> https://github.com/\n  if (/^\\/\\//.test(url)) {\n    url = 'https:' + url\n  }\n  return realFetch.call(this, url, options)\n}\n\nfetch.ponyfill = true\n\nmodule.exports = exports = fetch\nexports.fetch = fetch\nexports.Headers = nodeFetch.Headers\nexports.Request = nodeFetch.Request\nexports.Response = nodeFetch.Response\n\n// Needed for TypeScript consumers without esModuleInterop.\nexports.default = fetch\n","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport whatwgUrl from 'whatwg-url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n\tconst orig = new URL$1(original).protocol;\n\tconst dest = new URL$1(destination).protocol;\n\n\treturn orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\tdestroyStream(request.body, error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(req, function (err) {\n\t\t\tif (signal && signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (parseInt(process.version.substring(1)) < 14) {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\treq.on('socket', function (s) {\n\t\t\t\ts.addListener('close', function (hadError) {\n\t\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\t\tconst hasDataListener = s.listenerCount('data') > 0;\n\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n\t\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.on('end', function () {\n\t\t\t\t\t// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tlet socket;\n\n\trequest.on('socket', function (s) {\n\t\tsocket = s;\n\t});\n\n\trequest.on('response', function (response) {\n\t\tconst headers = response.headers;\n\n\t\tif (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n\t\t\tresponse.once('close', function (hadError) {\n\t\t\t\t// tests for socket presence, as in some situations the\n\t\t\t\t// the 'socket' event is not triggered for the request\n\t\t\t\t// (happens in deno), avoids `TypeError`\n\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\tconst hasDataListener = socket && socket.listenerCount('data') > 0;\n\n\t\t\t\tif (hasDataListener && !hadError) {\n\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\terrorCallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction destroyStream(stream, err) {\n\tif (stream.destroy) {\n\t\tstream.destroy(err);\n\t} else {\n\t\t// node < 8\n\t\tstream.emit('error', err);\n\t\tstream.end();\n\t}\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError, AbortError };\n"],"names":[],"sourceRoot":""}