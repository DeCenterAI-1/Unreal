{"version":3,"file":"58430.js","mappings":"ucEIA,EACA,EAMA,EAIA,EACA,EAEA,uCFlBO,mECCP,EAAa,EAAQ,OACrB,EAAsC,EAAQ,UAC9C,mCAA0E,QCG1E,QAIA,KAIA,IAGA,KAGA,GACA,cACA,gBACA,CAuDA,SACA,cACA,qBACA,CACA,aACA,QACA,CACA,eACA,kBACA,IAEA,IAGA,OACA,IAIA,IAEA,YACA,6DACA,CACA,SAGA,GADA,OACA,wBACA,OAEA,gEAA+E,sBAC/E,mBACA,SAAgC,EAChC,CAmBA,OAlBA,mBACA,OAEA,mBACA,WACA,iEACA,mBACA,kBACA,SAIA,IACA,kBACA,QAIA,WAIA,IACA,eAwCA,IACA,aACA,OAEA,GADA,QACA,IACA,GACA,KADA,EAEA,cAGA,6BAAiD,EAAM,GAGvD,UACA,OACA,QACA,QACA,QACA,YA4MA,EA3MA,OA2MA,EA3MA,EA4MA,cAEA,0CACA,kBA9MA,QACA,QACA,OA3GA,KA2GA,QAxLA,EAwLA,OAxLA,GA0LA,uBAEA,gBAyCA,YACA,QACA,WACA,YAAoB,IAAY,KAChC,aACA,cACA,IACA,MACA,CACA,MACA,CACA,wBACA,EArDA,GACA,YACA,QAEA,CACA,OAtLA,gBACA,EACA,SACA,SACA,SAEA,iBACA,0CACA,UACA,KAEA,IADA,KACA,MACA,aACA,cAEA,eAEA,iBAEA,gBACA,mBACA,MACA,iBAEA,gBACA,YACA,yBACA,MACA,iBAEA,gBACA,YAEA,uBADA,UAEA,UACA,SACA,0BACA,gBAEA,SACA,MAEA,SAEA,kBACA,qBACA,WAEA,CAIA,OAHA,YACA,uBAEA,CACA,EAiIA,EACA,SACA,CADkB,GAClB,WACA,YAA4B,IAAW,IACvC,SAEA,QACA,CACA,QACA,CADkB,GAClB,KACA,YAA4B,IAAW,IACvC,WAaA,GAEA,sBACA,mCAEA,sBACA,mBAGA,2CAAkD,SAAW,EAC7D,EAvBA,UAEA,QACA,CACA,QACA,oBACA,0CAEA,OADA,gBACA,CACA,CACA,kCAAkD,EAAM,EACxD,CACA,IA7FA,MACA,4BACA,yCAEA,OADA,gBACA,CACA,CAEA,uBACA,MACA,CACA,SAEA,OACA,OACA,GACA,cAGA,QAEA,0CAEA,OADA,gBACA,CACA,MAEA,wDAGA,QACA,CACA,SAMA,MA8RA,OACA,OACA,OApSA,0BACA,mDACA,kBAEA,CACA,CACA,GA3CA,CACA,CA6GA,0BAcA,cACA,QACA,QACA,SACA,SAEA,aACA,cACA,KACA,MACA,CACA,WACA,CACA,aACA,SACA,yBACA,KACA,MACA,CACA,OACA,cAEA,aACA,cACA,KACA,MACA,CACA,eACA,CACA,aACA,SACA,SACA,SACA,+CACA,KACA,MACA,CACA,QACA,SACA,kBAEA,aACA,cACA,KACA,MACA,CACA,mBACA,CACA,QACA,aACA,SACA,yBACA,KACA,MACA,CACA,OACA,sBAEA,aACA,cACA,KACA,MACA,CACA,uBACA,CACA,aACA,SACA,SACA,SACA,cACA,WACA,WACA,WACA,KACA,MACA,CACA,SACA,SACA,0BAEA,aACA,cACA,KACA,MACA,CACA,2BACA,CACA,SACA,aACA,SACA,yBACA,MACA,MACA,CACA,QACA,8BAEA,aACA,cACA,MACA,MACA,CACA,+BACA,CACA,aACA,SACA,SACA,SACA,cACA,WACA,WACA,WACA,MACA,MACA,CACA,SACA,UACA,kCAEA,aACA,cACA,MACA,MACA,CACA,mCACA,CACA,aACA,SACA,yBACA,MACA,MACA,CACA,QACA,sCAEA,aACA,cACA,MACA,MACA,CACA,uCACA,CAOA,OAAe,cACf,SAEA,4BAwBA,cAQA,EANA,GAEA,CADA,YACA,MAEA,aAWA,GAAuB,OALvB,EALA,MAIA,KACA,GAGA,EAEuB,EACvB,CADiC,CACjC,SACA,eAAsC,EACtC,OAEA,oBAEA,WACA,EACA,EAMA,YARwC,EACX,GAQ7B,CAD+B,GAC/B,QAAgB,MAAS,IACzB,iBAAmD,2BAAgC,GAG5E,MADP,QACO,sBElcA,cACP,MAA4B,QAAU,CDD9B,OAAK,CCC8C,EDD9C,CAAa,UAAe,ECCkB,EDE3D,KAAgB,EAAS,GCDzB,EAEA,kBAEA,cACA,eAEA,mBACA,OAGA,MAAqB,EADrB,IAC2B,GAD3B,QAEA,cACA,gBHdO,YGc8B,GHbrC,2BACA,uCAEA,gBACA,SAGA,QACA,IACA,IACA,WACA,sBACA,IACA,IAGA,oBACA,oBAEA,aACA,cAEA,IACA,cAAiC,qBAA2C,QAC5E,qBACA,aACA,UAEA,SACA,8BAEA,IACA,GACA,CAEA,UACA,sBACA,IAGA,kBACA,KAAW,IAAY,IACvB,GAAe,EAAQ,gBAEvB,QACA,EGhCqC,QAAgB,CAGrD","sources":["webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/base58/alphabet.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/base58/encode.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js"],"sourcesContent":["export const ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n//# sourceMappingURL=alphabet.js.map","import { ALPHABET } from \"./alphabet.js\";\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source) {\n    if (!(source instanceof Uint8Array)) {\n        throw new TypeError(\"Expected Uint8Array\");\n    }\n    if (source.length === 0) {\n        return \"\";\n    }\n    // Skip & count leading zeroes.\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n        pbegin++;\n        zeroes++;\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    const b58 = new Uint8Array(size);\n    // Process the bytes.\n    while (pbegin !== pend) {\n        let carry = source[pbegin] || 0;\n        // Apply \"b58 = b58 * 256 + ch\".\n        let i = 0;\n        for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n            carry += (256 * (b58[it1] || 0)) >>> 0;\n            b58[it1] = (carry % BASE) >>> 0;\n            carry = (carry / BASE) >>> 0;\n        }\n        if (carry !== 0) {\n            throw new Error(\"Non-zero carry\");\n        }\n        length = i;\n        pbegin++;\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n        it2++;\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n        str += ALPHABET.charAt(b58[it2] || 0);\n    }\n    return str;\n}\n//# sourceMappingURL=encode.js.map","// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n// TODO: re-enable typescript and properly type this\n// @ts-nocheck - TODO: re-enable typescript and properly type this\nlet src;\nlet srcEnd;\nlet position = 0;\nconst EMPTY_ARRAY = [];\nlet strings = EMPTY_ARRAY;\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\nlet packedValues;\nlet dataView;\nconst defaultOptions = {\n    useRecords: false,\n    mapsAsObjects: true,\n};\nfunction readFixedString(length) {\n    let result;\n    if (length < 16) {\n        if (result = shortStringInJS(length))\n            return result;\n    }\n    if (length > 64 && decoder)\n        return decoder.decode(src.subarray(position, position += length));\n    const end = position + length;\n    const units = [];\n    result = '';\n    while (position < end) {\n        const byte1 = src[position++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            const byte4 = src[position++] & 0x3f;\n            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= 0x1000) {\n            result += fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += fromCharCode.apply(String, units);\n    }\n    return result;\n}\nclass Decoder {\n    constructor() {\n        Object.assign(this, defaultOptions);\n    }\n    decodeKey(key) {\n        return key;\n    }\n    decode(source, end = -1) {\n        srcEnd = end > -1 ? end : source.length;\n        position = 0;\n        stringPosition = 0;\n        srcStringEnd = 0;\n        srcString = null;\n        strings = EMPTY_ARRAY;\n        bundledStrings = null;\n        src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            dataView =\n                source.dataView ||\n                    (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        }\n        catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            src = null;\n            if (source instanceof Uint8Array) {\n                throw error;\n            }\n            throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n                ? source.constructor.name\n                : typeof source}`);\n        }\n        if (this instanceof Decoder) {\n            currentDecoder = this;\n            packedValues =\n                this.sharedValues &&\n                    (this.pack\n                        ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues)\n                        : this.sharedValues);\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n        }\n        else {\n            currentDecoder = defaultOptions;\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n            packedValues = null;\n        }\n        return checkedRead();\n    }\n}\nfunction checkedRead() {\n    try {\n        const result = read();\n        if (bundledStrings) {\n            if (position >= bundledStrings.postBundlePosition) {\n                const error = new Error(\"Unexpected bundle position\");\n                error.incomplete = true;\n                throw error;\n            }\n            // bundled strings to skip past\n            position = bundledStrings.postBundlePosition;\n            bundledStrings = null;\n        }\n        if (position === srcEnd) {\n            // finished reading this source, cleanup references\n            currentStructures = null;\n            src = null;\n            if (referenceMap) {\n                referenceMap = null;\n            }\n        }\n        else if (position > srcEnd) {\n            // over read\n            const error = new Error(\"Unexpected end of CBOR data\");\n            error.incomplete = true;\n            throw error;\n        }\n        else {\n            throw new Error(\"Data read, but end of buffer not reached\");\n        }\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    }\n    catch (error) {\n        clearSource();\n        if (error instanceof RangeError ||\n            error.message.startsWith(\"Unexpected end of buffer\")) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n}\nfunction read() {\n    let token = src[position++];\n    const majorType = token >> 5;\n    token = token & 0x1f;\n    if (token > 0x17) {\n        switch (token) {\n            case 0x18:\n                token = src[position++];\n                break;\n            default:\n                throw new Error(`Unknown token ${token}`);\n        }\n    }\n    switch (majorType) {\n        case 0: // positive int\n            return token;\n        case 1: // negative int\n            return ~token;\n        case 2: // buffer\n            return readBin(token);\n        case 3: // string\n            if (srcStringEnd >= position) {\n                return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n            }\n            if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n                // for small blocks, avoiding the overhead of the extract call is helpful\n                const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n                if (string !== null) {\n                    return string;\n                }\n            }\n            return readFixedString(token);\n        case 4: { // array\n            const array = new Array(token);\n            for (let i = 0; i < token; i++) {\n                array[i] = read();\n            }\n            return array;\n        }\n        case 5: { // map\n            const object = {};\n            for (let i = 0; i < token; i++) {\n                object[safeKey(read())] = read();\n            }\n            return object;\n        }\n        default: // negative int\n            if (Number.isNaN(token)) {\n                const error = new Error(\"Unexpected end of CBOR data\");\n                error.incomplete = true;\n                throw error;\n            }\n            throw new Error(`Unknown CBOR token ${token}`);\n    }\n}\nfunction safeKey(key) {\n    // protect against prototype pollution\n    if (typeof key === \"string\") {\n        return key === \"__proto__\" ? \"__proto_\" : key;\n    }\n    if (typeof key !== \"object\") {\n        return key.toString();\n    }\n    // protect against expensive (DoS) string conversions\n    throw new Error(`Invalid property name type ${typeof key}`);\n}\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n    const start = position;\n    const bytes = new Array(length);\n    for (let i = 0; i < length; i++) {\n        const byte = src[position++];\n        if ((byte & 0x80) > 0) {\n            position = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) {\n                return \"\";\n            }\n            const a = src[position++];\n            if ((a & 0x80) > 1) {\n                position -= 1;\n                return;\n            }\n            return fromCharCode(a);\n        }\n        const a = src[position++];\n        const b = src[position++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n            position -= 2;\n            return;\n        }\n        if (length < 3) {\n            return fromCharCode(a, b);\n        }\n        const c = src[position++];\n        if ((c & 0x80) > 0) {\n            position -= 3;\n            return;\n        }\n        return fromCharCode(a, b, c);\n    }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n        position -= 4;\n        return;\n    }\n    if (length < 6) {\n        if (length === 4) {\n            return fromCharCode(a, b, c, d);\n        }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n            position -= 5;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }\n    if (length < 8) {\n        const e = src[position++];\n        const f = src[position++];\n        if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n            position -= 6;\n            return;\n        }\n        if (length < 7) {\n            return fromCharCode(a, b, c, d, e, f);\n        }\n        const g = src[position++];\n        if ((g & 0x80) > 0) {\n            position -= 7;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g);\n    }\n    const e = src[position++];\n    const f = src[position++];\n    const g = src[position++];\n    const h = src[position++];\n    if ((e & 0x80) > 0 ||\n        (f & 0x80) > 0 ||\n        (g & 0x80) > 0 ||\n        (h & 0x80) > 0) {\n        position -= 8;\n        return;\n    }\n    if (length < 10) {\n        if (length === 8) {\n            return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n        const i = src[position++];\n        if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i);\n    }\n    if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n            position -= 10;\n            return;\n        }\n        if (length < 11) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n            position -= 11;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n    }\n    const i = src[position++];\n    const j = src[position++];\n    const k = src[position++];\n    const l = src[position++];\n    if ((i & 0x80) > 0 ||\n        (j & 0x80) > 0 ||\n        (k & 0x80) > 0 ||\n        (l & 0x80) > 0) {\n        position -= 12;\n        return;\n    }\n    if (length < 14) {\n        if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n        }\n        const m = src[position++];\n        if ((m & 0x80) > 0) {\n            position -= 13;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n    }\n    const m = src[position++];\n    const n = src[position++];\n    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n        position -= 14;\n        return;\n    }\n    if (length < 15) {\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n    }\n    const o = src[position++];\n    if ((o & 0x80) > 0) {\n        position -= 15;\n        return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\nfunction readBin(length) {\n    return currentDecoder.copyBuffers\n        ? // specifically use the copying slice (not the node one)\n            Uint8Array.prototype.slice.call(src, position, (position += length))\n        : src.subarray(position, (position += length));\n}\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n    // http://cbor.schmorp.de/generic-object\n    return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n    if (src[position++] !== 0x84) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        if (src.length < position) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n    const newPackedValues = read_(); // packed values\n    if (!newPackedValues || !newPackedValues.length) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        error.incomplete = true;\n        throw error;\n    }\n    packedValues = packedValues\n        ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n        : newPackedValues;\n    packedValues.prefixes = read_();\n    packedValues.suffixes = read_();\n    return read_(); // read the rump\n};\npackedTable.handlesRead = true;\ncurrentExtensions[28] = (read_) => {\n    // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n    if (!referenceMap) {\n        referenceMap = new Map();\n        referenceMap.id = 0;\n    }\n    const id = referenceMap.id++;\n    const token = src[position];\n    let target;\n    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n    // ahead past references to record structure definitions\n    if (token >> 5 === 4) {\n        target = [];\n    }\n    else {\n        target = {};\n    }\n    const refEntry = { target }; // a placeholder object\n    referenceMap.set(id, refEntry);\n    const targetProperties = read_(); // read the next value as the target object to id\n    if (refEntry.used) {\n        // there is a cycle, so we have to assign properties to original target\n        return Object.assign(target, targetProperties);\n    }\n    refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n    return targetProperties; // no cycle, can just use the returned read object\n};\nfunction clearSource() {\n    src = null;\n    referenceMap = null;\n    currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n    mult10[i] = /* @__PURE__ */ (() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;\n//# sourceMappingURL=cbor-decode.js.map","import { isHex } from \"../encoding/hex.js\";\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nexport function ensureBytecodePrefix(bytecode) {\n    if (isHex(bytecode, { strict: false })) {\n        return bytecode;\n    }\n    return `0x${bytecode}`;\n}\n//# sourceMappingURL=prefix.js.map","import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode) {\n    const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n    const cborLength = \n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n        // @ts-expect-error - TS doesn't like this, but it's fine\n        numericBytecode[numericBytecode.length - 1];\n    const cborStart = numericBytecode.length - 2 - cborLength;\n    // if the cborStart is invalid, return undefined\n    if (cborStart < 0 || cborStart > numericBytecode.length) {\n        return undefined;\n    }\n    const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n    const cborData = decode(bytecodeBuffer);\n    if (\"ipfs\" in cborData) {\n        return `ipfs://${base58Encode(cborData.ipfs)}`;\n    }\n    return undefined;\n}\n//# sourceMappingURL=extractIPFS.js.map"],"names":[],"sourceRoot":""}