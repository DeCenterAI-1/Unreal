{"version":3,"file":"33814.js","mappings":"ohBAiBO,sBACP,gBACA,0BACA,QACY,QAAU,YACtB,WACA,qBACA,CACK,CACL,0BElBA,mDAaO,iBAEP,OAiBA,EAhBA,4BACQ,OAAW,IACnB,KACA,EAEA,EDjBO,YAMP,GALA,oBAEA,KCcsF,CDdtF,EAAwB,EAAS,GAGjC,wCACA,qBACA,WAAoB,EAAsB,EAG1C,uCAEA,uBACA,WAAoB,EAAsB,EAG1C,6CAEA,qBACA,WAAoB,EAAsB,EAG1C,qDACA,qBACA,WAAoB,EAAsB,EAE1C,iDACA,qBACA,WAAoB,EAAsB,EAG1C,yCACA,qBACA,WAAoB,EAAsB,EAG1C,4CACA,oBACA,WAAoB,EAAsB,EAG1C,ECzBsF,GACtF,KACA,OACA,UACA,eAA4B,OAAW,CAAC,OAAW,EACnD,KACA,SACA,CAAa,EACb,EAiBA,GAbA,UAIA,EAAmB,OAAW,EAC9B,KACA,SACA,CAAS,EACT,cAGA,aAEA,GACQ,QAAS,KACjB,OACA,YAA6C,OAAW,EACxD,KACA,SACA,CAAS,QAET,SACA,CACA,kBACA,UACA,EAEA,CACA,UACA,UACA,CACA,CACA,OAAa,6BACb,CACA,iBAEA,GAOA,MAAuB,kBAAY,EACnC,gBACA,cACK,EACL,IACA,YAAmC,EAAgB,GACnD,WADmD,MACnD,CACA,6EACA,CAAS,EACT,WAAoB,aAAwB,EAE5C,MACA,MACA,CACA,CACA,iBAEA,GACA,MAAuB,kBAAY,EACnC,gBACA,cACK,EACL,IACA,OACY,EAAgB,GAC5B,WAD4B,MAC5B,CACA,6EACA,CAAa,EACD,EAAgB,GAC5B,WAD4B,MAC5B,CACA,SAEA,oEACA,CAAa,EACD,EAAgB,GAC5B,WAD4B,MAC5B,CACA,SAEA,oEACA,CAAa,EACb,CAEA,EADA,uBACA,QArHA,uEAqHA,GACA,cAAmC,aAAwB,GAC3D,CACA,MACA,MACA,CACA,CACA,OACA,gBACA,sBACA,UACA,SACA,CACA,eACA,QACA,sBACA,CAAS,CACT,CACA,sBACA,EACA,iBAEA,GACA,IACA,aAAqB,kBAAY,WAAG,WAAyC,CAC7E,CACA,MACA,MACA,CACA","sources":["webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/rpc/actions/eth_getStorageAt.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/bytecode/extractMinimalProxyImplementationAddress.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/bytecode/resolveImplementation.js"],"sourcesContent":["import { getAddress } from \"../../utils/address.js\";\n/**\n * Retrieves the value stored at a specific position in the storage of a contract.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the eth_getStorageAt method.\n * @returns A promise that resolves to the value stored at the specified position.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getStorageAt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const storageValue = await eth_getStorageAt(rpcRequest, {\n * address: \"0x...\",\n *  position: 0n,\n * });\n * ```\n */\nexport async function eth_getStorageAt(request, params) {\n    return await request({\n        method: \"eth_getStorageAt\",\n        params: [\n            getAddress(params.address),\n            params.position,\n            params.blockTag ?? \"latest\",\n        ],\n    });\n}\n//# sourceMappingURL=eth_getStorageAt.js.map","/**\n * Extracts the implementation address from a given bytecode string if it matches any of the known minimal proxy patterns.\n * @param bytecode The bytecode string to extract the implementation address from.\n * @returns The implementation address as a string if a match is found, otherwise undefined.\n * @example\n * ```ts\n * import { extractMinimalProxyImplementationAddress } from \"thirdweb/utils\";\n * const bytecode = \"0x363d3d373d3d3d363d73...\";\n * const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n * ```\n * @utils\n */\nexport function extractMinimalProxyImplementationAddress(bytecode) {\n    if (!bytecode.startsWith(\"0x\")) {\n        // biome-ignore lint/style/noParameterAssign: perf\n        bytecode = `0x${bytecode}`;\n    }\n    // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n    if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n        const implementationAddress = bytecode.slice(22, 62);\n        return `0x${implementationAddress}`;\n    }\n    // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n    if (bytecode.startsWith(\"0x36603057343d5230\")) {\n        // +40 = size of addr\n        const implementationAddress = bytecode.slice(122, 122 + 40);\n        return `0x${implementationAddress}`;\n    }\n    // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n    if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n        // +40 = size of addr\n        const implementationAddress = bytecode.slice(24, 24 + 40);\n        return `0x${implementationAddress}`;\n    }\n    // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n    if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n        const implementationAddress = bytecode.slice(32, 32 + 40);\n        return `0x${implementationAddress}`;\n    }\n    if (bytecode.startsWith(\"0x36600080376020600036600073\")) {\n        const implementationAddress = bytecode.slice(28, 28 + 40);\n        return `0x${implementationAddress}`;\n    }\n    // EIP-7511 minimal proxy with PUSH0 opcode - https://eips.ethereum.org/EIPS/eip-7511\n    if (bytecode.startsWith(\"0x365f5f375f5f365f73\")) {\n        const implementationAddress = bytecode.slice(20, 60);\n        return `0x${implementationAddress}`;\n    }\n    // EIP-7702 - https://eips.ethereum.org/EIPS/eip-7702#abstract\n    if (bytecode.length === 48 && bytecode.startsWith(\"0xef0100\")) {\n        const implementationAddress = bytecode.slice(8, 48);\n        return `0x${implementationAddress}`;\n    }\n    return undefined;\n}\n//# sourceMappingURL=extractMinimalProxyImplementationAddress.js.map","import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMinimalProxyImplementationAddress.js\";\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst ZERO_BYTES32 = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n    const [originalBytecode, beacon] = await Promise.all([\n        getBytecode(contract),\n        getBeaconFromStorageSlot(contract),\n    ]);\n    // check minimal proxy first synchronously\n    const minimalProxyImplementationAddress = extractMinimalProxyImplementationAddress(originalBytecode);\n    if (minimalProxyImplementationAddress) {\n        return {\n            address: minimalProxyImplementationAddress,\n            bytecode: await getBytecode(getContract({\n                ...contract,\n                address: minimalProxyImplementationAddress,\n            })),\n        };\n    }\n    // check other proxy types\n    let implementationAddress;\n    if (beacon && beacon !== AddressZero) {\n        // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n        // Hence we replace the proxy address with Beacon address, and continue further resolving below\n        // biome-ignore lint/style/noParameterAssign: we purposefully mutate the contract object here\n        contract = getContract({\n            ...contract,\n            address: beacon,\n        });\n        implementationAddress = await getImplementationFromContractCall(contract);\n    }\n    else {\n        implementationAddress = await getImplementationFromStorageSlot(contract);\n    }\n    if (implementationAddress &&\n        isAddress(implementationAddress) &&\n        implementationAddress !== AddressZero) {\n        const implementationBytecode = await getBytecode({\n            ...contract,\n            address: implementationAddress,\n        });\n        // return the original contract bytecode if the implementation bytecode is empty\n        if (implementationBytecode === \"0x\") {\n            return {\n                address: contract.address,\n                bytecode: originalBytecode,\n            };\n        }\n        return {\n            address: implementationAddress,\n            bytecode: implementationBytecode,\n        };\n    }\n    return { address: contract.address, bytecode: originalBytecode };\n}\nasync function getBeaconFromStorageSlot(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n    /**\n     * The storage slot of the Beacon as defined in EIP-1967\n     * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n     *\n     * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n     */\n    const rpcRequest = getRpcClient({\n        client: contract.client,\n        chain: contract.chain,\n    });\n    try {\n        const proxyStorage = await eth_getStorageAt(rpcRequest, {\n            address: contract.address,\n            position: \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\",\n        });\n        return `0x${proxyStorage.slice(-40)}`;\n    }\n    catch {\n        return undefined;\n    }\n}\nasync function getImplementationFromStorageSlot(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n    const rpcRequest = getRpcClient({\n        client: contract.client,\n        chain: contract.chain,\n    });\n    try {\n        const proxyStoragePromises = [\n            eth_getStorageAt(rpcRequest, {\n                address: contract.address,\n                position: \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n            }),\n            eth_getStorageAt(rpcRequest, {\n                address: contract.address,\n                position: \n                // keccak256(\"matic.network.proxy.implementation\") - used in polygon USDT proxy: https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f#code\n                \"0xbaab7dbf64751104133af04abc7d9979f0fda3b059a322a8333f533d3f32bf7f\",\n            }),\n            eth_getStorageAt(rpcRequest, {\n                address: contract.address,\n                position: \n                // keccak256(\"org.zeppelinos.proxy.implementation\") - e.g. base USDC proxy: https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913#code\n                \"0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3\",\n            }),\n        ];\n        const proxyStorages = await Promise.all(proxyStoragePromises);\n        const proxyStorage = proxyStorages.find((storage) => storage !== ZERO_BYTES32);\n        return proxyStorage ? `0x${proxyStorage.slice(-40)}` : AddressZero;\n    }\n    catch {\n        return undefined;\n    }\n}\nconst UPGRADEABLE_PROXY_ABI = {\n    type: \"function\",\n    name: \"implementation\",\n    inputs: [],\n    outputs: [\n        {\n            type: \"address\",\n            name: \"\",\n            internalType: \"address\",\n        },\n    ],\n    stateMutability: \"view\",\n};\nasync function getImplementationFromContractCall(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n    try {\n        return await readContract({ contract, method: UPGRADEABLE_PROXY_ABI });\n    }\n    catch {\n        return undefined;\n    }\n}\n//# sourceMappingURL=resolveImplementation.js.map"],"names":[],"sourceRoot":""}