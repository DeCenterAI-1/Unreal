{"version":3,"file":"43796.js","mappings":"qhBACO,WCE+B,GAAS,CA0CJ,GAAS,OAa7C,UAA8B,GAAS,CAC9C,kBAAkB,gBAAmB,EACrC,6BACA,QACA,kBACA,sBAAmC,EAAM,GAAM,CAAN,CAAM,iBAAoB,OAAS,IAAO,GACnF,sBACA,CAAS,EACT,mCACA,cACA,gBACA,YACA,YACA,CAAS,EACT,mCACA,cACA,gBACA,YACA,YACA,CAAS,EACT,iBACA,iBAEA,CACuC,GAAS,CAQd,GAAS,OCvFpC,UAAuB,GAAS,CACvC,oBAAyB,kDAAmD,EAC5E,SACA,QACA,WACA,gCACA,kBACA,CAAS,EACT,mCACA,cACA,gBACA,YACA,YACA,CAAS,EACT,oBACA,uBAAsC,EAAe,UAhBrD,EAiBA,CADqD,CAG9C,kBACP,iBACA,WACA,mCACA,cACA,gBACA,YACA,YACA,CAAS,EACT,iBAEA,CACO,kBACP,eACA,SACA,YACA,qBACA,oHACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,8BACA,kDACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,sBAAyB,GAAS,EAAI,EACtC,SACA,YACA,8BACA,0BAAuC,OAAc,EAAO,OAAS,oCAC5D,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,6BACA,0HAIA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,wBACA,8CACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,4BACA,qGAIA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,WACA,CAAC,CACM,mBACP,eACA,SACA,YACA,gCACA,4CACA,CAAS,EACT,mCACA,cACA,gBACA,YACA,gCACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,mCACA,gDACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,mCACA,2CACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,sBAAyB,GAAS,EAAI,EACtC,SACA,YACA,kCACA,sBAAmC,OAAc,EAAO,OAAS,kBACjE,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,6BACA,6CACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,sCACA,6DACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,YACA,CAAC,CACM,mBACP,eACA,SACA,YACA,gCACA,yCACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,UACA,CAAC,CACM,mBACP,eACA,SACA,YACA,iCACA,uFACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,UACA,CAAC,CACM,mBACP,sBAAyB,GAAS,EAAI,EACtC,SACA,YACA,sCACA,kEAA+E,QAAe,EAAO,MAAQ,GACpG,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,UACA,CAAC,CACM,mBACP,eACA,SACA,YACA,iCACA,4DACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,UACA,CAAC,CACM,mBACP,eACA,SACA,YACA,8BACA,oEACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,UACA,CAAC,CACM,mBACP,eACA,SACA,YACA,wBACA,iEACA,CAAS,CACT,CACA,CACA,gCACA,cACA,gBACA,YACA,UACA,CAAC,oJC5SD,gCAEA,GACA,wCACA,uCACA,EAaO,4BACP,qBACA,kBACA,cAAU,GAAe,MAEzB,UACA,YAAiC,OAAa,IAW9C,EAVA,IACA,0CACA,OAEA,KACA,MACA,CAEA,EAD4B,QAAsB,eAElD,CAEA,CACA,GACA,sCAEA,wBACA,UAEA,oBACA,QAAoD,IAAc,EAClE,mBACA,YAGA,WAAY,oCAA0D,GACtE,gBACA,QACA,gBACA,CAAK,CACL,YACA,iBACA,mBACA,CAAoB,8BACpB,EAAoB,CACpB,iBACA,uBACA,QACA,CAAS,EAET,OAGA,MADA,kBACA,IACA,MACA,8CAEA,MAA4B,OAAgB,YAC5C,0BACA,QACU,QAAc,IACxB,MACA,OACA,+CACA,cACA,0CACA,EACA,GACY,QAA0B,OAEtC,CAIA,OAHA,iBACA,sDAEA,qBACA,CAKO,4BACP,QACA,MAAgB,QAAgC,MAChD,KACA,YACA,CACA,cACA,gBACA,eACA,4BACA,gCACa,EAEb,CACA,gBACA,gBACA,CAAS,SACT,gBACA,MACA,8CAEA,MAA4B,OAAgB,YAI5C,WAHA,wBACA,QACU,QAAc,IACxB,eACA,CAEA,6BACA,YAA6B,OAAa,IAC1C,kBACA,kBAAY,wCAAsD,MAAQ,gCAA0C,CACpH,oBACA,UAEA,oBACA,QAAoD,IAAc,EAClE,mBACA,YAGA,WAAY,oCAA0D,GACtE,gBACA,QACA,gBACA,CAAK,EACL,gBACA,qCACA,EAGA,cACA,wBAA2C,GAAkB,CAC7D,kBACA,iBACA,iBACA,uBACA,UACA,2BAAkD,OAAqB,QACvE,yCACgB,OAAqB,eACrC,yBAAgD,OAAqB,OACrE,OACA,yBAAmD,OAAqB,WACxE,CACS,CACT,SACA,iCACA,sBACA,CAAK,EASL,GARA,mDAEA,IAEA,WACA,qBAGA,qBACA,mBACA,mDACA,iBACA,mBACA,MAEA,UAEA,CACA,6CACA,uCACA,6CACA,CAAS,CACT,CACA,QACA,CACA,qBAAyB,qBAA4B,EAkErD,MAjEA,CACA,UACA,yBACA,uBACA,6BACA,QACA,CACA,UAAsC,QAAW,eACjD,cAA0C,QAAW,iBACrD,KAA8B,QAAU,IACxC,QACA,YACqB,CACrB,CACa,EAUb,MATY,OAAgB,EAC5B,SACA,cAA+B,QAAU,IACzC,2BACA,kBACA,kBACA,6BACA,oBACa,EACb,CACA,iBACA,CACA,CAAS,CACT,2BAA4B,EAAS,EACrC,MACA,mBAC2B,QAAW,IAEtC,4BAC2B,QAAe,QAE1C,MAEA,kBACA,uBACA,wBACa,CACb,CAAS,CACT,uBACA,MAAyB,OAAc,IACvC,QAAoB,2BAA+B,EACnD,GACA,aAA8B,QAAuB,SAAG,EAAQ,EAChE,YAIY,QAAiB,SAAG,kCAAqC,EACrE,MAA8B,QAAkB,EAChD,YAAoC,CACpC,UACA,cACA,OACA,CAAa,EACb,wBACA,8BACA,wBACa,CACb,CAAS,CAGT,CACA,wBACA,kBAAoC,qBAA2B,EAC/D,mBACA,sCACA,mCACA,iCACA,oBACA,CACA,aACA,QACA,iCACA,IACA,2BACA,CACA,cACA,SACA,SACA,WACA,QAAyB,QAAU,OACnC,QACA,CAAa,EACb,2BACA,2BACA,MAEA,GAEA,CACA,cACA,MAAyB,QAAc,CAAC,OAAgB,KACxD,yBACA,uCACA,CAKA,OAJA,0BACA,uBACA,qBACA,yBACA,CACA,EACA,EACA,EACA,YACA,CAUA,wBACA,WACA,IACA,QANA,oBAAkD,GAAS,yDAC3D,GAMA,EAVA,sBAAwC,GAAS,eAYjD,IADA,eACA,eACA,YAAmC,sBAAgB,IACnD,MACA,YACA,uCACA,+BACA,EACA,OACA,WACA,SACA,QACA,CACA,QAAiC,QAAW,YAC5C,iBACA,gCACA,QAAiC,OAAoB,IACrD,qCACA,CAAqB,CACrB,CACa,EACb,iBACA,UACA,MACA,CACA,iBACA,oCACA,SAAuB,QAAS,QAAW,IAAW,EAC7C,CACT,CACA,SACA,sCACA,oCACA,UAAsB,EAAwB,EAE9C,WAAkB,EAAgB,EAClC,CACA,CAKA,GAT8C,MAS9C,CAPkC,CAOlC,KACA,6BAAkD,IAAS,GAC3D,CAKA,oBACA,yCACA,yBACA,CACA,cACA,QACA,UACA,eAAmC,QAAiB,EACpD,cACA,iBACS,EAGT,0CACA,eACA,QAA2B,QAAiB,EAC5C,QACA,gBACS,EAKT,OAHA,uBACA,MAAoB,QAAc,SAElC,CACA,SACA,qCACA,0BACA,eACA,IAEA,CACA,OACA,EACA,SACA,MACA,MACA,KACA,WACA,MACA,GACA,MACA,IACA,GACA,IACA,KACA,IACA,OACA","sources":["webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/errors/utils.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/errors/request.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/errors/rpc.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/wallet-connect/controller.js"],"sourcesContent":["export const getContractAddress = (address) => address;\nexport const getUrl = (url) => url;\n//# sourceMappingURL=utils.js.map","import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class HttpRequestError extends BaseError {\n    constructor({ body, cause, details, headers, status, url, }) {\n        super('HTTP request failed.', {\n            cause,\n            details,\n            metaMessages: [\n                status && `Status: ${status}`,\n                `URL: ${getUrl(url)}`,\n                body && `Request body: ${stringify(body)}`,\n            ].filter(Boolean),\n            name: 'HttpRequestError',\n        });\n        Object.defineProperty(this, \"body\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"headers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.body = body;\n        this.headers = headers;\n        this.status = status;\n        this.url = url;\n    }\n}\nexport class WebSocketRequestError extends BaseError {\n    constructor({ body, cause, details, url, }) {\n        super('WebSocket request failed.', {\n            cause,\n            details,\n            metaMessages: [\n                `URL: ${getUrl(url)}`,\n                body && `Request body: ${stringify(body)}`,\n            ].filter(Boolean),\n            name: 'WebSocketRequestError',\n        });\n    }\n}\nexport class RpcRequestError extends BaseError {\n    constructor({ body, error, url, }) {\n        super('RPC Request failed.', {\n            cause: error,\n            details: error.message,\n            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n            name: 'RpcRequestError',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.code = error.code;\n        this.data = error.data;\n    }\n}\nexport class SocketClosedError extends BaseError {\n    constructor({ url, } = {}) {\n        super('The socket has been closed.', {\n            metaMessages: [url && `URL: ${getUrl(url)}`].filter(Boolean),\n            name: 'SocketClosedError',\n        });\n    }\n}\nexport class TimeoutError extends BaseError {\n    constructor({ body, url, }) {\n        super('The request took too long to respond.', {\n            details: 'The request timed out.',\n            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n            name: 'TimeoutError',\n        });\n    }\n}\n//# sourceMappingURL=request.js.map","import { BaseError } from './base.js';\nimport { RpcRequestError } from './request.js';\nconst unknownErrorCode = -1;\nexport class RpcError extends BaseError {\n    constructor(cause, { code, docsPath, metaMessages, name, shortMessage, }) {\n        super(shortMessage, {\n            cause,\n            docsPath,\n            metaMessages: metaMessages || cause?.metaMessages,\n            name: name || 'RpcError',\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = name || cause.name;\n        this.code = (cause instanceof RpcRequestError ? cause.code : (code ?? unknownErrorCode));\n    }\n}\nexport class ProviderRpcError extends RpcError {\n    constructor(cause, options) {\n        super(cause, options);\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = options.data;\n    }\n}\nexport class ParseRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: ParseRpcError.code,\n            name: 'ParseRpcError',\n            shortMessage: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n        });\n    }\n}\nObject.defineProperty(ParseRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32700\n});\nexport class InvalidRequestRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: InvalidRequestRpcError.code,\n            name: 'InvalidRequestRpcError',\n            shortMessage: 'JSON is not a valid request object.',\n        });\n    }\n}\nObject.defineProperty(InvalidRequestRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32600\n});\nexport class MethodNotFoundRpcError extends RpcError {\n    constructor(cause, { method } = {}) {\n        super(cause, {\n            code: MethodNotFoundRpcError.code,\n            name: 'MethodNotFoundRpcError',\n            shortMessage: `The method${method ? ` \"${method}\"` : ''} does not exist / is not available.`,\n        });\n    }\n}\nObject.defineProperty(MethodNotFoundRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32601\n});\nexport class InvalidParamsRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: InvalidParamsRpcError.code,\n            name: 'InvalidParamsRpcError',\n            shortMessage: [\n                'Invalid parameters were provided to the RPC method.',\n                'Double check you have provided the correct parameters.',\n            ].join('\\n'),\n        });\n    }\n}\nObject.defineProperty(InvalidParamsRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32602\n});\nexport class InternalRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: InternalRpcError.code,\n            name: 'InternalRpcError',\n            shortMessage: 'An internal error was received.',\n        });\n    }\n}\nObject.defineProperty(InternalRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32603\n});\nexport class InvalidInputRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: InvalidInputRpcError.code,\n            name: 'InvalidInputRpcError',\n            shortMessage: [\n                'Missing or invalid parameters.',\n                'Double check you have provided the correct parameters.',\n            ].join('\\n'),\n        });\n    }\n}\nObject.defineProperty(InvalidInputRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32000\n});\nexport class ResourceNotFoundRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: ResourceNotFoundRpcError.code,\n            name: 'ResourceNotFoundRpcError',\n            shortMessage: 'Requested resource not found.',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ResourceNotFoundRpcError'\n        });\n    }\n}\nObject.defineProperty(ResourceNotFoundRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32001\n});\nexport class ResourceUnavailableRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: ResourceUnavailableRpcError.code,\n            name: 'ResourceUnavailableRpcError',\n            shortMessage: 'Requested resource not available.',\n        });\n    }\n}\nObject.defineProperty(ResourceUnavailableRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32002\n});\nexport class TransactionRejectedRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: TransactionRejectedRpcError.code,\n            name: 'TransactionRejectedRpcError',\n            shortMessage: 'Transaction creation failed.',\n        });\n    }\n}\nObject.defineProperty(TransactionRejectedRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32003\n});\nexport class MethodNotSupportedRpcError extends RpcError {\n    constructor(cause, { method } = {}) {\n        super(cause, {\n            code: MethodNotSupportedRpcError.code,\n            name: 'MethodNotSupportedRpcError',\n            shortMessage: `Method${method ? ` \"${method}\"` : ''} is not supported.`,\n        });\n    }\n}\nObject.defineProperty(MethodNotSupportedRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32004\n});\nexport class LimitExceededRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: LimitExceededRpcError.code,\n            name: 'LimitExceededRpcError',\n            shortMessage: 'Request exceeds defined limit.',\n        });\n    }\n}\nObject.defineProperty(LimitExceededRpcError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32005\n});\nexport class JsonRpcVersionUnsupportedError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            code: JsonRpcVersionUnsupportedError.code,\n            name: 'JsonRpcVersionUnsupportedError',\n            shortMessage: 'Version of JSON-RPC protocol is not supported.',\n        });\n    }\n}\nObject.defineProperty(JsonRpcVersionUnsupportedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: -32006\n});\nexport class UserRejectedRequestError extends ProviderRpcError {\n    constructor(cause) {\n        super(cause, {\n            code: UserRejectedRequestError.code,\n            name: 'UserRejectedRequestError',\n            shortMessage: 'User rejected the request.',\n        });\n    }\n}\nObject.defineProperty(UserRejectedRequestError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4001\n});\nexport class UnauthorizedProviderError extends ProviderRpcError {\n    constructor(cause) {\n        super(cause, {\n            code: UnauthorizedProviderError.code,\n            name: 'UnauthorizedProviderError',\n            shortMessage: 'The requested method and/or account has not been authorized by the user.',\n        });\n    }\n}\nObject.defineProperty(UnauthorizedProviderError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4100\n});\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n    constructor(cause, { method } = {}) {\n        super(cause, {\n            code: UnsupportedProviderMethodError.code,\n            name: 'UnsupportedProviderMethodError',\n            shortMessage: `The Provider does not support the requested method${method ? ` \" ${method}\"` : ''}.`,\n        });\n    }\n}\nObject.defineProperty(UnsupportedProviderMethodError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4200\n});\nexport class ProviderDisconnectedError extends ProviderRpcError {\n    constructor(cause) {\n        super(cause, {\n            code: ProviderDisconnectedError.code,\n            name: 'ProviderDisconnectedError',\n            shortMessage: 'The Provider is disconnected from all chains.',\n        });\n    }\n}\nObject.defineProperty(ProviderDisconnectedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4900\n});\nexport class ChainDisconnectedError extends ProviderRpcError {\n    constructor(cause) {\n        super(cause, {\n            code: ChainDisconnectedError.code,\n            name: 'ChainDisconnectedError',\n            shortMessage: 'The Provider is not connected to the requested chain.',\n        });\n    }\n}\nObject.defineProperty(ChainDisconnectedError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4901\n});\nexport class SwitchChainError extends ProviderRpcError {\n    constructor(cause) {\n        super(cause, {\n            code: SwitchChainError.code,\n            name: 'SwitchChainError',\n            shortMessage: 'An error occurred when attempting to switch chain.',\n        });\n    }\n}\nObject.defineProperty(SwitchChainError, \"code\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: 4902\n});\nexport class UnknownRpcError extends RpcError {\n    constructor(cause) {\n        super(cause, {\n            name: 'UnknownRpcError',\n            shortMessage: 'An unknown RPC error occurred.',\n        });\n    }\n}\n//# sourceMappingURL=rpc.js.map","import { SwitchChainError, UserRejectedRequestError, getTypesForEIP712Domain, serializeTypedData, validateTypedData, } from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getChainMetadata, getRpcUrlForChain, } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex, } from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getSavedConnectParamsFromStorage, saveConnectParamsToStorage, } from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\nconst defaultShowQrModal = true;\nconst storageKeys = {\n    requestedChains: \"tw.wc.requestedChains\",\n    lastUsedChainId: \"tw.wc.lastUsedChainId\",\n};\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(wallet) {\n    return wallet.id === \"walletConnect\";\n}\n/**\n * @internal\n */\nexport async function connectWC(options, emitter, walletId, storage, sessionHandler) {\n    const provider = await initProvider(options, walletId, sessionHandler);\n    const wcOptions = options.walletConnect;\n    let { onDisplayUri } = wcOptions || {};\n    // use default sessionHandler unless onDisplayUri is explicitly provided\n    if (!onDisplayUri && sessionHandler) {\n        const walletInfo = await getWalletInfo(walletId);\n        const deeplinkHandler = (uri) => {\n            const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n            if (!appUrl) {\n                // generic wc uri\n                sessionHandler(uri);\n                return;\n            }\n            const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n            sessionHandler(fullUrl);\n        };\n        onDisplayUri = deeplinkHandler;\n    }\n    if (onDisplayUri) {\n        provider.events.addListener(\"display_uri\", onDisplayUri);\n    }\n    let optionalChains = wcOptions?.optionalChains;\n    let chainToRequest = options.chain;\n    // ignore the given options chains - and set the safe supported chains\n    if (walletId === \"global.safe\") {\n        optionalChains = chainsToRequestForSafe.map(getCachedChain);\n        if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n            chainToRequest = undefined;\n        }\n    }\n    const { rpcMap, requiredChain, optionalChains: chainsToRequest, } = getChainsToRequest({\n        client: options.client,\n        chain: chainToRequest,\n        optionalChains: optionalChains,\n    });\n    if (provider.session) {\n        await provider.connect({\n            ...(wcOptions?.pairingTopic\n                ? { pairingTopic: wcOptions?.pairingTopic }\n                : {}),\n            optionalChains: chainsToRequest,\n            chains: requiredChain ? [requiredChain.id] : undefined,\n            rpcMap: rpcMap,\n        });\n    }\n    setRequestedChainsIds(chainsToRequest, storage);\n    // If session exists and chains are authorized, enable provider for required chain\n    const addresses = await provider.enable();\n    const address = addresses[0];\n    if (!address) {\n        throw new Error(\"No accounts found on provider.\");\n    }\n    const providerChainId = normalizeChainId(provider.chainId);\n    const chain = options.chain && options.chain.id === providerChainId\n        ? options.chain\n        : getCachedChain(providerChainId);\n    if (options) {\n        const savedParams = {\n            optionalChains: options.walletConnect?.optionalChains,\n            chain: options.chain,\n            pairingTopic: options.walletConnect?.pairingTopic,\n        };\n        if (storage) {\n            saveConnectParamsToStorage(storage, walletId, savedParams);\n        }\n    }\n    if (wcOptions?.onDisplayUri) {\n        provider.events.removeListener(\"display_uri\", wcOptions.onDisplayUri);\n    }\n    return onConnect(address, chain, provider, emitter, storage, options.client);\n}\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {\n    const savedConnectParams = storage\n        ? await getSavedConnectParamsFromStorage(storage, walletId)\n        : null;\n    const provider = await initProvider(savedConnectParams\n        ? {\n            chain: savedConnectParams.chain,\n            client: options.client,\n            walletConnect: {\n                pairingTopic: savedConnectParams.pairingTopic,\n                optionalChains: savedConnectParams.optionalChains,\n            },\n        }\n        : {\n            client: options.client,\n            walletConnect: {},\n        }, walletId, sessionHandler, true);\n    const address = provider.accounts[0];\n    if (!address) {\n        throw new Error(\"No accounts found on provider.\");\n    }\n    const providerChainId = normalizeChainId(provider.chainId);\n    const chain = options.chain && options.chain.id === providerChainId\n        ? options.chain\n        : getCachedChain(providerChainId);\n    return onConnect(address, chain, provider, emitter, storage, options.client);\n}\n// Connection utils -----------------------------------------------------------------------------------------------\nasync function initProvider(options, walletId, sessionRequestHandler, isAutoConnect = false) {\n    const walletInfo = await getWalletInfo(walletId);\n    const wcOptions = options.walletConnect;\n    const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await import(\"@walletconnect/ethereum-provider\");\n    let optionalChains = wcOptions?.optionalChains;\n    let chainToRequest = options.chain;\n    // ignore the given options chains - and set the safe supported chains\n    if (walletId === \"global.safe\") {\n        optionalChains = chainsToRequestForSafe.map(getCachedChain);\n        if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n            chainToRequest = undefined;\n        }\n    }\n    const { rpcMap, requiredChain, optionalChains: chainsToRequest, } = getChainsToRequest({\n        client: options.client,\n        chain: chainToRequest,\n        optionalChains: optionalChains,\n    });\n    const provider = await EthereumProvider.init({\n        showQrModal: wcOptions?.showQrModal === undefined\n            ? sessionRequestHandler\n                ? false\n                : defaultShowQrModal\n            : wcOptions.showQrModal,\n        projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n        optionalMethods: OPTIONAL_METHODS,\n        optionalEvents: OPTIONAL_EVENTS,\n        optionalChains: chainsToRequest,\n        chains: requiredChain ? [requiredChain.id] : undefined,\n        metadata: {\n            name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n            description: wcOptions?.appMetadata?.description ||\n                getDefaultAppMetadata().description,\n            url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n            icons: [\n                wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n            ],\n        },\n        rpcMap: rpcMap,\n        qrModalOptions: wcOptions?.qrModalOptions,\n        disableProviderPing: true,\n    });\n    provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n    // disconnect the provider if chains are stale when (if not auto connecting)\n    if (!isAutoConnect) {\n        // const isStale = await isChainsStale(provider, chainsToRequest);\n        if (provider.session) {\n            await provider.disconnect();\n        }\n    }\n    if (walletId !== \"walletConnect\") {\n        async function handleSessionRequest() {\n            const walletLinkToOpen = provider.session?.peer?.metadata?.redirect?.native ||\n                walletInfo.mobile.native ||\n                walletInfo.mobile.universal;\n            if (sessionRequestHandler && walletLinkToOpen) {\n                // TODO: propagate error when this fails\n                await sessionRequestHandler(walletLinkToOpen);\n            }\n        }\n        provider.signer.client.on(\"session_request_sent\", handleSessionRequest);\n        provider.events.addListener(\"disconnect\", () => {\n            provider.signer.client.off(\"session_request_sent\", handleSessionRequest);\n        });\n    }\n    return provider;\n}\nfunction createAccount({ provider, address, client, }) {\n    const account = {\n        address: address,\n        async sendTransaction(tx) {\n            const transactionHash = (await provider.request({\n                method: \"eth_sendTransaction\",\n                params: [\n                    {\n                        gas: tx.gas ? numberToHex(tx.gas) : undefined,\n                        value: tx.value ? numberToHex(tx.value) : undefined,\n                        from: getAddress(address),\n                        to: tx.to,\n                        data: tx.data,\n                    },\n                ],\n            }));\n            trackTransaction({\n                client: client,\n                walletAddress: getAddress(address),\n                walletType: \"walletConnect\",\n                transactionHash,\n                chainId: tx.chainId,\n                contractAddress: tx.to ?? undefined,\n                gasPrice: tx.gasPrice,\n            });\n            return {\n                transactionHash,\n            };\n        },\n        async signMessage({ message }) {\n            const messageToSign = (() => {\n                if (typeof message === \"string\") {\n                    return stringToHex(message);\n                }\n                if (message.raw instanceof Uint8Array) {\n                    return uint8ArrayToHex(message.raw);\n                }\n                return message.raw;\n            })();\n            return provider.request({\n                method: \"personal_sign\",\n                params: [messageToSign, this.address],\n            });\n        },\n        async signTypedData(_data) {\n            const data = parseTypedData(_data);\n            const { domain, message, primaryType } = data;\n            const types = {\n                EIP712Domain: getTypesForEIP712Domain({ domain }),\n                ...data.types,\n            };\n            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n            // as we can't statically check this with TypeScript.\n            validateTypedData({ domain, message, primaryType, types });\n            const typedData = serializeTypedData({\n                domain: domain ?? {},\n                message,\n                primaryType,\n                types,\n            });\n            return await provider.request({\n                method: \"eth_signTypedData_v4\",\n                params: [this.address, typedData],\n            });\n        },\n    };\n    return account;\n}\nfunction onConnect(address, chain, provider, emitter, storage, client) {\n    const account = createAccount({ provider, address, client });\n    async function disconnect() {\n        provider.removeListener(\"accountsChanged\", onAccountsChanged);\n        provider.removeListener(\"chainChanged\", onChainChanged);\n        provider.removeListener(\"disconnect\", onDisconnect);\n        await provider.disconnect();\n    }\n    function onDisconnect() {\n        setRequestedChainsIds([], storage);\n        storage?.removeItem(storageKeys.lastUsedChainId);\n        disconnect();\n        emitter.emit(\"disconnect\", undefined);\n    }\n    function onAccountsChanged(accounts) {\n        if (accounts[0]) {\n            const newAccount = createAccount({\n                provider,\n                address: getAddress(accounts[0]),\n                client,\n            });\n            emitter.emit(\"accountChanged\", newAccount);\n            emitter.emit(\"accountsChanged\", accounts);\n        }\n        else {\n            onDisconnect();\n        }\n    }\n    function onChainChanged(newChainId) {\n        const newChain = getCachedChain(normalizeChainId(newChainId));\n        emitter.emit(\"chainChanged\", newChain);\n        storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n    }\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n    provider.on(\"session_delete\", onDisconnect);\n    return [\n        account,\n        chain,\n        disconnect,\n        (newChain) => switchChainWC(provider, newChain, storage),\n    ];\n}\n// Storage utils  -----------------------------------------------------------------------------------------------\nfunction getNamespaceMethods(provider) {\n    return provider.session?.namespaces[NAMESPACE]?.methods || [];\n}\nfunction getNamespaceChainsIds(provider) {\n    const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map((chain) => Number.parseInt(chain.split(\":\")[1] || \"\"));\n    return chainIds ?? [];\n}\nasync function switchChainWC(provider, chain, storage) {\n    const chainId = chain.id;\n    try {\n        const namespaceChains = getNamespaceChainsIds(provider);\n        const namespaceMethods = getNamespaceMethods(provider);\n        const isChainApproved = namespaceChains.includes(chainId);\n        if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n            const apiChain = await getChainMetadata(chain);\n            const blockExplorerUrls = [\n                ...new Set([\n                    ...(chain.blockExplorers?.map((x) => x.url) || []),\n                    ...(apiChain.explorers?.map((x) => x.url) || []),\n                ]),\n            ];\n            await provider.request({\n                method: ADD_ETH_CHAIN_METHOD,\n                params: [\n                    {\n                        chainId: numberToHex(apiChain.chainId),\n                        chainName: apiChain.name,\n                        nativeCurrency: apiChain.nativeCurrency,\n                        rpcUrls: getValidPublicRPCUrl(apiChain), // no clientId on purpose\n                        blockExplorerUrls: blockExplorerUrls.length > 0 ? blockExplorerUrls : undefined,\n                    },\n                ],\n            });\n            const requestedChains = await getRequestedChainsIds(storage);\n            requestedChains.push(chainId);\n            setRequestedChainsIds(requestedChains, storage);\n        }\n        await provider.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [{ chainId: numberToHex(chainId) }],\n        });\n    }\n    catch (error) {\n        const message = typeof error === \"string\" ? error : error?.message;\n        if (/user rejected request/i.test(message)) {\n            throw new UserRejectedRequestError(error);\n        }\n        throw new SwitchChainError(error);\n    }\n}\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(chains, storage) {\n    storage?.setItem(storageKeys.requestedChains, stringify(chains));\n}\n/**\n * Get the last requested chains from the storage.\n * @internal\n */\nasync function getRequestedChainsIds(storage) {\n    const data = await storage.getItem(storageKeys.requestedChains);\n    return data ? JSON.parse(data) : [];\n}\nfunction getChainsToRequest(options) {\n    const rpcMap = {};\n    if (options.chain) {\n        rpcMap[options.chain.id] = getRpcUrlForChain({\n            chain: options.chain,\n            client: options.client,\n        });\n    }\n    // limit optional chains to 10\n    const optionalChains = (options?.optionalChains || []).slice(0, 10);\n    for (const chain of optionalChains) {\n        rpcMap[chain.id] = getRpcUrlForChain({\n            chain: chain,\n            client: options.client,\n        });\n    }\n    if (!options.chain && optionalChains.length === 0) {\n        rpcMap[1] = getCachedChain(1).rpc;\n    }\n    return {\n        rpcMap,\n        requiredChain: options.chain ? options.chain : undefined,\n        optionalChains: optionalChains.length > 0\n            ? optionalChains.map((x) => x.id)\n            : [1],\n    };\n}\nconst chainsToRequestForSafe = [\n    1, // Ethereum Mainnet\n    11155111, // Sepolia Testnet\n    42161, // Arbitrum One Mainnet\n    43114, // Avalanche Mainnet\n    8453, // Base Mainnet\n    1313161554, // Aurora Mainnet\n    84532, // Base Sepolia Testnet\n    56, // Binance Smart Chain Mainnet\n    42220, // Celo Mainnet\n    100, // Gnosis Mainnet\n    10, // Optimism Mainnet\n    137, // Polygon Mainnet\n    1101, // Polygon zkEVM Mainnet\n    324, // zkSync Era mainnet\n    534352, // Scroll mainnet\n];\n//# sourceMappingURL=controller.js.map"],"names":[],"sourceRoot":""}