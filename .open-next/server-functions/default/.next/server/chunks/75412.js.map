{"version":3,"file":"75412.js","mappings":"wiBAkDO,oBACP,oBAAY,0EAAsG,EAClH,KACA,cAEA,KACA,SAEA,MACA,gFAEA,MAAW,OAAS,WACpB,SAAuC,OAAK,IAC5C,EACc,QAAW,QACzB,MAAe,kBAAY,EAC3B,WACA,+DACA,aACS,CACT,CAAK,EACL,YAAqB,2BAA8B,GAAG,0BAA6B,GAAG,eAAkB,GAAG,cAAiB,EAC5H,eACA,CAAK,CACL,CAIO,cACP,iBAAY,2DAAoF,EAChG,KACA,cAEA,SAAmC,OAAK,IACxC,EACU,QAAW,QACrB,MAAW,OAAmB,EAC9B,WACA,kEACA,aACK,CACL,CAIO,cACP,oBAAY,mCAAyD,SACrE,EACA,OAEW,OAAmB,EAC9B,WACA,mDACA,QACA,SACA,YACA,aACA,CAIA,6BACA,CAAK,CACL,CAIO,cACP,oBAAY,yCAAqE,SACjF,EACA,OAEW,OAAmB,EAC9B,WACA,8DACA,QACA,mBACA,sBACA,uBACA,CACK,CACL,yLC/HO,IACP,GACA,CACA,eACA,aACA,CAAK,CACL,CACA,GACA,CACA,aACA,mBACA,YACA,CACA,eACA,aACA,CAAa,CACb,CACA,iBACA,sBACA,CAAa,CACb,CACA,eACA,qCACA,CAAa,CACb,CACA,eACA,qBACA,CAAa,CACb,CACA,eACA,mBACA,CAAa,CAEb,CAAK,CACL,CAmFO,oBACP,MAAW,kBAAY,EACvB,oBACA,QAxHO,aAwHP,KACA,kBACK,CACL,2BC3HO,IACD,EAAS,CACf,CACA,aACA,WACA,KAJe,IADS,EAKxB,CACA,CACA,eACA,aACA,CAAa,CACb,CACA,aACA,cACA,CAAa,CACb,CACA,iBACA,sBACA,CAAa,CACb,CACA,eACA,qCACA,CAAa,CACb,CACA,eACA,+BACA,CAAa,CACb,CACA,eACA,6BACA,CAAa,CACb,CACA,eACA,gCACA,CAAa,CACb,CACA,eACA,8BACA,CAAa,CACb,CACA,eACA,UACA,CAAa,CAEb,CAAK,CACL,CACA,aACA,gBACA,CAAK,CACL,CACM,EAAU,kBCjDT,SAAS,IAChB,CDgDgB,MChDhB,SAD+B,KAC/B,cACA,CAIO,SAAS,EAAa,GAC7B,MAAW,IANuD,CAMvD,GAAQ,6BACnB,gBCZO,OACP,CAAM,6BAAiC,CACvC,CAAM,4BAAgC,CACtC,CAAM,wCAA4C,CAClD,CAAM,qDAAyD,CAC/D,CAAM,+CAAmD,CACzD,CAAM,6CAAiD,CACvD,CAAM,gDAAoD,CAC1D,CAAM,8CAAkD,CACxD,CAAM,0BAA8B,CACpC,CCFO,oBACP,YAAY,oBAAyB,EACrC,yBACA,QACA,eACA,YACA,4BACA,mBACS,CACT,sCACA,OAAiB,uBAAuB,GAAE,CAC1C,SACA,CAAK,EACL,OAAa,kBACb,CAIO,oBACP,WAAY,iBAAsB,EAClC,OACA,wCACA,CAAe,IAAY,EAC3B,kBACA,+BAAwC,QAAK,oDAC7C,yBAAkC,EAAa,yCAC/C,uBAAgC,EAAa,0BAAuC,KACpF,eADmG,WACnG,GACA,wBAAiC,EAAc,KAC/C,UAAmB,OAAc,GACjC,UACA,QACA,CACA,CCoCO,wBA4BP,IA3BA,oBAAY,wCAAqD,EAGjE,IADA,MAAkC,wBAAkB,IAEpD,SAGA,YAAqC,EAAuB,CAC5D,WACA,QACA,CAH4D,WAK5D,gBACA,sDAcA,EAVA,mBAYA,QAFA,EAVA,oBAaA,cACA,OAA8B,IAAY,EAG1C,SACA,EACA,wBACA,+CAJA,IAZQ,QAAK,oDACb,iCAIA,kFCrGO,gGEKA,MAAwB,GAAe,iDCF9C,+DGLO,iBAA0C,GAAS,CAC1D,eACA,sBAA8B,EAAK,sBACnC,kCACA,CAAS,CACT,CACA,sCECA,IAAM,GAAQ,mCAmCd,mBAAqB,UAAe,EACpC,uCACA,MAAe,OAAS,CAAC,QAAO,KAChC,sDACA,UAAkB,EAA2B,QAC7C,MAAW,OAAmB,SAC9B,CEjCO,mBAEP,EADA,cAAY,GAAY,EAQxB,OACA,SANA,EDhBA,GACA,iBCckB,GDblB,SCakB,GDZlB,iBCaA,EAG4B,OAAY,IAIxC,KAAc,OAAW,IAEzB,OFpBO,YACP,KEmBiC,GFnBrB,sBAAuB,EACnC,OACA,MACA,MAAqB,SDRd,OAiBP,EAhBA,QAAY,oBAAuB,EACnC,EAAuB,OAAK,IAAS,UAAe,EACpD,cACA,EACA,oBACuB,OAAkB,QACzC,kBACuB,EAAe,OAGtC,MAHsC,GAGtC,eAEA,iBAEA,gBACA,YAEA,gBACA,iBAEA,qBACA,kCACA,SACA,QACA,CACA,aAEA,qBAEA,4BAEA,gBACA,sCACA,KAEA,SAyBO,OACP,eACA,SACA,UACA,cACA,MAAmB,OAAS,IAAQ,UAAe,CACnD,YACA,mBACA,gBAEA,aADA,kBAGA,SACA,iCACA,gDACA,0BAIA,0IACA,iCAGA,kDACA,4CAGA,gBAA6B,IAAI,SAAS,GAAG,eAC7C,yBACA,gBACA,KAEA,yBAAiE,GAAG,SACpE,CAAqB,GAErB,QAEA,CACA,EA/DA,IACA,CAAS,EACT,CAEA,MACA,cACA,UACA,MA0DO,kBACP,gBACA,WACA,OACA,qBACA,kBACA,kBACA,iBACA,yCACA,sBAUA,GARA,+CAEA,6CAEA,6CADuB,OAAS,OAAyB,UAAe,EAMxE,QACA,CAEA,EAjFA,qBACA,KACA,UAA8B,IAAqB,EACnD,UACA,UACqB,EACrB,UACA,UACqB,CACrB,CACA,GACA,EACA,QACA,GAEA,KACA,ECnD+B,KAAG,SAAsB,EACxD,MACA,UAAsB,IAAqB,IAAc,QAAQ,IAAE,EACnE,GACA,CACA,oBACA,UAAkB,IAAqB,SAAc,QAAQ,IAAE,EAE/D,MAAsB,EADC,OAAa,KAEpC,CADqC,CACrC,GACA,oBACA,oDACA,mBACA,EACA,0BACA,yBACA,EACA,aACA,GACA,cACA,oBACA,0BAAkE,gBAA2B,GAC7F,2BACA,UAAsC,aAAwB,EAC9D,OACiB,GAEjB,CACA,gBEZiC,CACjC,QACA,eACS,CACT,CACA,gEIjCO,YACP,oDACA,gDACA,gDACA,gDACA,gDACA,gDACA,sBACA,eACA,cACA,cACA,cACA,CACA,EAIO,eACP,0DACA,EAEA,SAA6C,QAAK,MAAc,SAAK,IACrE,EACA,CCOO,qBACP,WACA,KACA,kCACA,QACY,GAAa,YACzB,2BAA8C,KAAuB,CACrE,CACK,CACL,CAgBO,uBACP,gBACA,KACA,yCACA,QACY,GAAa,YACzB,2BAA8C,KAAuB,CACrE,KAAgC,CAChC,CACK,EAEL,OACA,mBAA4B,SAAW,uBACvC,2CACc,SAAW,oBACzB,OACA,qBAA8B,SAAW,yBACzC,aAAsB,SAAW,iBAAqB,KAA0B,CAChF,uEACc,SAAW,kCACzB,OACA,2DACc,SAAW,4BACzB,MACA,CACA,CAoFO,qBACP,gBACA,KACA,8CACA,UACK,EACL,OACA,qBAA8B,SAAW,yBACzC,aAAsB,SAAW,gBACjC,CACA,CAiBO,qBACP,kBACA,MAGA,mBAEA,MVxLO,SAAS,CAAc,EAC9B,IAAY,SUuLuB,KVvLvB,IADkB,KAClB,GAAuB,EACnC,ODcO,YACP,ECf8B,CDe9B,CAAY,iCAAiC,EAC7C,QACA,sBAEA,2BACA,YACA,cACA,IACA,SACA,QACA,IACA,kCACA,cAAkC,EAAe,IACjD,MACA,GAFiD,IAEjD,KACA,MAA0B,SDxCnB,GACP,ECuCwC,CDvCxC,KAAY,4BAAsC,EAClD,QACA,WACA,MACA,UAAkB,IAAiC,WAAG,EAAU,EAChE,MACA,aACA,KACA,4BACA,IAA0B,EAAgB,OAAa,MAAd,GAEzC,mCACA,UAAkB,IAA8B,aAAc,EAAU,EACxE,SAAY,YAAe,EAC3B,oCACA,UAEA,wCACA,YAAoB,WAA0B,KAC9C,WACA,OACA,MACA,UAAsB,IAAuB,EAC7C,UACA,OACA,CAAa,CACb,kBA8CA,gBAAuB,UAAc,QACrC,mBACA,kBACA,kBACA,iCACA,EAEA,CADuB,OAAmB,YAC1C,KArDA,OAA8D,UAAqB,CACnF,CAEA,+CACA,eACA,eACA,IACA,MAAoC,OAAmB,MACvD,MACA,KACA,mBAEA,YAAwC,WAA6B,IACrE,kBAIA,CACA,SACA,MACA,gBAAuC,IAAgC,EACvE,aAAuC,IAAwB,CAC/D,UAAkC,IAAqB,EACvD,UACA,OACA,SACA,KAAkC,OAAI,GACtC,CAAyB,CACzB,QACA,CACA,MAEA,KACA,UAAsB,IAAqB,EAC3C,UACA,UACA,SACA,MACA,CAAa,EAGb,OACA,YACA,uCACA,CACA,EChCwC,CACxC,KACA,QACA,QACA,CAAa,EAEb,gCAGA,UA2BA,GACA,SAAY,wBAA0B,EACtC,MACA,SACA,MACA,SACA,kBACA,IACA,sBACA,OH1FO,cACP,IAAS,OAAS,IAAM,UAAe,EACvC,UAAkB,GAAmB,EAAG,UAAY,EACpD,IAAS,OAAS,IAAM,UAAe,EACvC,UAAkB,GAAmB,EAAG,UAAY,EACpD,wCACA,EGoFqC,KACrC,uCACA,MAAuB,OAAS,CAAC,QAAO,SACxC,YACA,CACA,MACA,QACA,CACA,QACA,mCACA,gBACA,WACA,SACA,iBACA,KAGA,CADA,wBACA,oBACA,CAAS,GAET,qBACA,kBACA,oBACA,mBACA,kCACA,WACA,SACA,kCACA,KAGA,CADA,wBACA,oBACA,CAAS,CAET,EAtEA,CACA,YACA,gBACA,WACA,CAAa,EANb,YAQA,OAAqB,UACrB,CACA,SACA,MACA,EACA,gBAA+B,IAA8B,CAC7D,YACA,gBAA+B,IAAqB,EACpD,aAA+B,IAAuB,EAEtD,KACA,YACA,iBACA,kDACA,CAEA,OAAqB,iBAAiC,aACtD,CACA,CAAK,EACL,eACA,ECjE8B,CAC9B,OACA,yBACA,QACA,CAAK,CACL,EUiLmC,CACnC,QJlLO,aAAoD,EAC3D,OAAW,GAAY,CACvB,IIgLmD,IJjL5B,EACvB,yHACA,SACA,CAAK,CACL,II6KuD,SHlLhD,IAA6C,EACpD,OAAW,CGiLmE,EHjLvD,CACvB,QADuB,EACvB,kHACA,SACA,CAAK,CACL,IG6K8E,CAC9E,WACA,CAAS,EACT,2BACA,MACA,wCAAwD,0BAA4B,GAEpF,MAA0B,OAAiB,EAC3C,MACA,CAAS,CACT,4CAAuD,iBAAyB,eAAe,0BAA4B,EAC3H,CACA,iBACA,CAiBO,qBACP,gBACA,UACA,wCACA,sBACK,EACL,KAGA,OF/OO,YACP,IAAY,UE8OyB,CF9OK,EAC1C,GACA,KACA,kCACA,0BACA,sBACA,KACA,kCACA,kBACA,KACA,sCACA,4BACA,KACA,sCACA,4BACA,KACA,kBACA,kBACA,KACA,YACA,kBACA,oCACA,gBACA,WACA,EAaA,OAZA,gBACA,wCACA,eACA,sCACA,CACA,KACA,UACA,wBACA,sCACA,sCACA,qBACA,CAEA,EEwMqC,EACrC,CAIO,qBACP,gBACA,kBACA,6BACA,uBACK,EACL,OACA,sBACA,gCAEA,CACO,qBAWP,OACA,gBAXA,WACA,kBACA,oCACA,QACA,CACA,iBACA,sCACa,CACb,EACK,EAEL,eACA,CACA,CACA,qBACA,YAAY,wBAA6B,EACzC,gBAA6C,SAAoB,UACjE,EAA6B,SAAc,WAC3C,aACA,cACA,SACA,iCACA,CAAS,CACT,KAAc,QAAS,EACvB,cACA,KACA,SACA,QACA,CAAS,CACT,CAAK,EACL,iBACA,mBACA,4BACA,oBACA,GAAoB,QAAS,KAE7B,uBACA,gBAA2B,GAAW,SAAS;AAC/C,UAAU;AACV,QAAQ,EAAK,EACb,CACA,eACA,sCCtSO,IACD,EADO,CACE,CACf,CACA,aAFe,EAGf,EAJwB,GAIxB,QACA,CAAK,CACL,CACA,eACA,UACA,CAAK,CACL,CACM,GAAU,CAChB,CACA,cAFgB,CAGhB,YACA,CAAK,CACL,CAsFO,qBACP,MAAW,kBAAY,EACvB,oBACA,QAAiB,aAAa,GAAW,GAAU,CACnD,WADuC,IAAY,CACnD,QACK,CACL,CC5GO,IACD,EADO,CACE,CACf,CACA,aACA,SAJwB,KAKxB,YACA,CACA,eACA,aACA,CAAa,CACb,CACA,eACA,YACA,CAAa,CACb,CACA,aACA,eACA,CAAa,CACb,CACA,aACA,eACA,CAAa,CACb,CACA,eACA,mBACA,CAAa,CACb,CACA,eACA,2BACA,CAAa,CACb,CACA,eACA,yBACA,CAAa,CACb,CACA,eACA,mBACA,CAAa,CACb,CACA,eACA,2BACA,CAAa,CACb,CACA,aACA,uBACA,CAAa,CACb,CACA,aACA,gBACA,CAAa,CAEb,CAAK,CACL,CACM,GAAU,CAChB,CACA,cACA,CAAK,CACL,CAmFO,EAvFS,aAuFT,MACP,MAAW,kBAAY,EACvB,oBACA,QAAiB,aAAa,GAAW,GAAU,CACnD,KAD4B,EAC5B,SADuC,CACvC,CACK,CACL,CAHmD,IC9I7C,EADO,CACE,CACf,CACA,aACA,UAHe,IAIf,YACA,CACA,eACA,aACA,CAAa,CACb,CACA,eACA,YACA,CAAa,CACb,CACA,aACA,eACA,CAAa,CACb,CACA,aACA,eACA,CAAa,CACb,CACA,eACA,uBACA,CAAa,CACb,CACA,eACA,yBACA,CAAa,CACb,CACA,eACA,cACA,CAAa,CACb,CACA,aACA,uBACA,CAAa,CACb,CACA,aACA,gBACA,CAAa,CAEb,CAAK,CACL,CACM,GAAU,CAChB,CACA,cACA,CAAK,CACL,CAmFO,OAvFS,QAuFM,GAAa,GACnC,MAAW,eADwB,EACxB,CAAY,EACvB,oBACA,QAAiB,aAAa,GAAW,GAAU,CACnD,UAD4B,MAC5B,EACK,CACL,EAHuC,IAAY,iFCpG5C,UACP,EACA,gBACA,sBACA,SA1CA,YACA,iBACU,SAAM,EAChB,UACA,oBACA,EACA,IACA,EAmCA,GACA,oBACA,iBApCA,YACA,MAAW,SAAM,EACT,SAAG,CAAC,SAAK,kCACjB,OACA,CAAS,EACD,SAAG,CAAC,SAAK,0BAAgD,QAAU,EAC3E,CACA,EA6BA,GACA,gDACA,iBA9BA,GACA,MAAW,SAAM,EACT,SAAG,CAAC,SAAK,kCACjB,OACA,CAAS,EACD,SAAG,CAAC,SAAK,0BAAgD,QAAU,EAC3E,CACA,EAuBA,GACA,0BAvBA,GACA,mBACU,SAAM,EAChB,YACY,SAAG,CAAC,SAAK,8CACrB,OACA,CAAa,EACD,SAAG,CAAC,SAAK,wCACrB,OACA,CAAa,EACb,sBACA,EACA,IACA,EAUA,GACA,sBACA,EC3BO,eAAe,GAAmB,GACzC,WAAY,YAD6B,QAC7B,wCAA8D,EAC1E,KACA,YAKA,SAA4C,KAAuB,CACnE,EAAyB,SAAoB,IAC7C,GACA,cACA,KACA,iCACA,QAAiB,GAAa,OAG9B,EAA6B,CAHC,EAGD,MAAc,IAC3C,aACA,cACA,QAfA,CACA,iCACA,EAcA,KAAc,QAAS,GACvB,CAAK,EACL,iBACA,UACA,4BACA,mBACA,iCAA4C;AAC5C,UAAU;AACV,QAAQ,EAAK,EACb,CACA,kBAEA,0BACA,CACA,4BAIA,oCACA,wEAAoF,iBAAmB,aAAa,kBAAoB,IAExI,CACA,2CACA,mDACkB,SAAW,gCAC7B,OACA,+CACkB,SAAW,8BAC7B,OACA,mCACkB,SAAW,wBAC7B,OACA,6BACA,qCACA,qEACkB,SAAW,yCAC7B,OACA,yDACkB,SAAW,mCAC7B,MACA,GAEA,8DACA,qCAA4C,EAAa,IAAI,EAAM,EACnE,CCjEA,eACA,MACA,GAAc,WAAyB,GAAG,UAAwB,EAElE,OACA,aACA,EACO,OACP,gBACA,EACA,MACA,cAmBO,qBACP,wBACA,GAD8C,CAC9C,gBACA,eACA,oBACA,YAAoC,GAAgB,GACpD,KACA,KAFoD,EAEpD,CAEA,sCACA,CACA,+DAAuE,YAAe,oBAAoB,aAAgB,EAC1H,CAsBO,qBACP,IAAY,uIAA+I,EAC3J,UACA,WACA,GACA,SACA,QACA,yBACA,sCACA,EACA,EAA8B,SAAoB,iCAAsC,KAAuB,EAC/G,+BACA,oBACA,EACc,wBAAkB,sBACxB,aAAM,IACN,OAAoB,QAC5B,IACA,YACA,iBACA,QACA,QACA,CAAS,EACT,IACA,kBACA,QACA,SACA,uCACA,mCACA,CAAS,EACT,EACA,cAAY,0BAAqC,QACjD,WACA,IACA,iBACA,kBACA,kBACA,eACA,aACA,YACA,aACA,QACA,WACA,eACA,eACA,uBACA,mBACA,CAAS,EAGT,IACA,iBACA,kBACA,kBACA,eACA,aACA,YACA,aACA,QACA,WACA,eACA,eACA,uBACA,mBACA,CAAK,CACL,CACA,qBACA,cAAY,qCAA2C,EACvD,cAAU,0BAAqC,EAC/C,iBAAqD,SAAoB,IACzE,GAAQ,SAAa,KAErB,YAAsC,GAAgB,CACtD,SACA,CAAS,EAF6C,EAGtD,eACA,6BAEA,CAEA,4BACY,OAAoB,IACpB,OAAoB,IAChC,EACA,QAEA,IACA,QAEA,CAEA,YAAkC,QAAsB,MAExD,EACA,8BACA,wBAEA,CACA,oBAAa,yBACb,CACA,yBAGA,EACA,EAHA,mBAAY,wLAA2L,EACvM,CAAY,kBAAgB,EAG5B,GACA,OACA,GAEA,cAIA,YACA,QAA4B,aAAM,CAAC,SAAoB,EACvD,kBACA,eACA,2BACA,sCACA,CAAS,GACT,GACA,OAGA,OACA,iBACA,QACA,WACA,eACA,uBACA,mBACA,wBACA,sBACA,UACA,cACA,iBACA,mBACA,iCACA,2BACA,UAAmB,KAAe,EAElC,MACA,YAAuC,GAAmB,CAC1D,SACA,QACA,QAH0D,CAI1D,uCACA,8BACA,CAAS,EAMT,GALA,+BACA,wBACA,iCAGA,gBACA,wBACA,sBACA,2BACA,gCACA,8BACA,8CACA,0CACA,0BACA,0BACA,gCACA,oCAEA,CAEA,wBACA,CACA,iCACA,WACA,CAA6B,QAAS,CAAC,SAAmB,GAAI,eAAiB,EAAI,eAAiB,GACpG,UACA,oCACA,IAAkC,SAAK,CAAC,KAAS,EAAI,QAAU,CAC/D,CAAyB,CAEzB,EACA,OACA,QAAoC,GAAiB,CACrD,SACA,IAFqD,IAErD,CACA,CAAa,GACb,+BACA,8CACA,0CACA,4CACA,QACA,8BACA,gCACA,oCAEA,YAA4C,GAAmB,CAC/D,SACA,QACA,QAH+D,CAI/D,uCACA,8BACA,CAAa,CACb,gCACA,wBACA,gCAEA,CACA,KACA,CAEA,YAAgC,GAAiB,CACjD,SACA,IAFiD,IAEjD,CACA,CAAS,CACT,+BACA,8CACA,0CACA,wDACA,gCACA,oCAEA,OACA,KACA,cACA,CACA,CACA,yBAGA,EAFA,mBAAY,wLAA2L,EACvM,OAAY,YAAgB,EAE5B,GACA,OACA,GAEA,cAIA,YACA,kBACA,eACA,2BACA,sCACA,CAAS,EACT,GACA,OAGA,OACA,iBACA,QACA,WACA,WACA,eACA,uBACA,mBACA,wBACA,sBACA,sBACA,UAAmB,KAAe,EAElC,MACA,YAAsC,GAAmB,CACzD,SACA,QACA,QAHyD,CAIzD,uCACA,8BACA,CAAS,EACT,yBACA,mBACA,KAKA,GAJA,aACA,uBAGA,gBACA,wBACA,qBACA,8BACA,8CACA,8CAEA,CAEA,YAAoC,GAAiB,CACrD,SACA,IAFqD,IAErD,CACA,CAAa,EAKb,GAJA,8BACA,8CACA,0CAEA,aACA,YAA+C,GAAmB,CAClE,SACA,QACA,QAHkE,CAIlE,uCACA,8BACA,CAAiB,EACjB,yBACA,mBACA,KACA,aACA,sBAEA,CACA,CACA,KACA,CAEA,YAAgC,GAAiB,CACjD,SACA,IAFiD,IAEjD,CACA,CAAS,CACT,+BACA,8CACA,0CAEA,OACA,KACA,cACA,CACA,CAoBO,qBACP,WAAY,8CAAiD,EAC7D,QAA6B,GAAa,CAC1C,gBAD0C,OAE1C,EACA,QACA,mBACA,CAAK,EACL,kBACA,2BACA,SACA,IAAqB,SAAU,GAC/B,CAAa,CACb,gBAA6B,QAAS,IACtC,aACS,EACT,OACA,KACA,WACA,CACA,CACA,4DACA,CAkBO,eAAe,GAAa,OAGnC,EAFA,QADmC,GACvB,+BAAmC,EAG/C,YAF8B,SAAoB,IAAsB,KAAuB,EAE/F,CACA,MAA6B,GAAsB,GACnD,QAA2B,GAAgB,CAC3C,IAFmD,KAE7B,OAAW,EACjC,KAF2C,GAE3C,GAA8C,KAAuB,CACrE,QACA,gBACa,EACb,QACA,CAAS,CACT,MAEA,QAA2B,GAAgB,CAC3C,SAAsB,OAAW,EACjC,WAA8C,KAAuB,CACrE,QACA,eACA,CAAa,EACb,QACA,CAAS,EAET,QACA,CACA,qBACA,oBAAY,wDAAoE,EAChF,EAAqB,SAAoB,EACzC,kBACA,eACA,cACA,uBACA,CAAK,EACL,MAAW,SAAM,kBAAiC,aAAM,KACxD,CACA,qBACA,oBAAY,2DAAuE,SACnF,EACA,KAEA,MAAiB,GAAQ,CACzB,IADyB,KACP,OAAW,EAC7B,WAA0C,KAAuB,CACjE,QACA,QACA,CAAS,EACT,IAAa,KACb,iBACK,CACL,CAsGA,qBACA,iBACA,aACA,oBAEA,MADA,MACA,eADoD,kEAGpD,wCACA,CACA,CC/lBA,mBACA,eAIO,uBACP,IAAY,oCAA+C,EAC3D,MACA,yEAGA,SADA,EACA,MACA,cAFA,IAEA,QAFA,EAEA,WACA,SAAc,OAAa,IAC3B,OACA,SAgRA,GACA,oBAAY,+BAA4C,EACxD,GACA,kCACA,yBAEA,OACA,YACA,gBACA,kBACA,MAAuB,QAAc,YACrC,gBACA,iBAEA,QAAgD,OAAyB,EACzE,UACA,aACA,CAAa,EACb,+BAEA,YAAqC,GAAkB,CACvD,SACA,KAFuD,EAEvD,SACA,QACA,mCACA,gDACA,CAAqB,CACrB,aACA,CAAiB,EACjB,GACA,KACA,KAEA,CAEA,YAA4C,OAAqB,EACjE,UACA,aACA,mBACA,CAAa,EAEb,QAAiC,GAAsB,CACvD,SACA,SAFuD,MAEvD,CACA,QACA,mCACA,gDACA,CAAiB,CACjB,cACA,mBACA,CAAa,EASb,MARY,OAAgB,EAC5B,gBACA,aACA,kCACA,wBACA,mBACA,4BACA,CAAa,EACb,CACA,kCACA,gBACA,OACA,CACA,CAAS,CACT,2BAA4B,EAAS,GACrC,uCAAmE,EAAS,EAE5E,uBACA,MAA8B,OAAc,IAC5C,yCACA,CAAS,CACT,gCACA,6CAEA,EACA,QACA,EA7VA,CACA,kBACA,oBACA,QACA,YACA,CAAa,EACb,EACA,CAGA,GAfA,EAeA,iBAfA,EAeA,8BACA,YAAwC,GAhBxC,EAgBgE,oBAChE,GACA,EAFgE,CAEhE,WACA,GAnBA,EAmBA,UACA,mBACA,EAEA,CAvBA,EAwBA,2BACA,iCAEA,cACA,eACA,kBAA+B,KAAuB,CACtD,EAEA,wBACQ,SAAwB,iCAChC,EAA4B,OAAW,EACvC,SACA,UACA,OACA,CAAK,EACL,QAAiC,SAAc,EAC/C,kBACA,uBACA,mDACA,YA3CA,EA2CA,uBACA,0CACA,CAAK,EACL,WACA,UACA,mEAA+E,WAAyB,cAAc,KAAS,IAAI,4BAAgC,GAAK,QAAY,CACpL,CAAK,EACL,EAA4B,OAAW,EACvC,SACA,UACA,OACA,CAAK,EACL,YAvDA,IAwDA,CACA,QACA,aACA,kBACA,kBACA,kBACA,QACA,CAAK,EAGL,GAFA,YACA,YAjEA,EAkEA,YACA,MAAkB,EAAsB,CACxC,kBACA,CAFwC,iBAExC,qBACA,wCACS,GACT,MAAgC,SvB3EzB,GACP,CuB0E6C,EvB1E7C,UAAY,+CAAoD,EAChE,OJkGO,YACP,MAAyB,KInGS,CJmGT,CAAI,UAC7B,2CAEA,MAAW,OAAmB,EAC9B,oBACA,QAtIwB,aAsIM,EAAW,EAAU,CACnD,iBAD4B,IAE5B,OAFuC,CAEvC,EAFmD,EAGnD,0BACS,CACT,4CACA,sDACA,wCACA,kDACA,0DACA,0EACA,4CACA,kDACA,qDACA,CAAK,CACL,EIvHkC,CAClC,WACA,oBACA,QAAoB,eAAiB,MAAQ,EAAqB,CAClE,UACA,QAFkE,CAElE,EACA,UAA2B,EAAqB,CAChD,SACA,SAFgD,GAEhD,CACA,CAAiB,CACjB,CAAa,EACb,iBAAqB,QACrB,CAAS,CACJ,CACL,EuB2D6C,CAC7C,UACA,WACA,YA3EA,EA2EA,uBACA,sCACA,CAAa,CACb,OAAkB,qBAAe,EACjC,UACA,aACA,CAAa,CACb,CAEA,YAKO,qBAEP,gBACA,IAEA,aACA,aAEA,CACA,qBACA,kCACA,MACgG,SAApF,SAAoB,iCAAyC,KAAuB,EAChG,6EAGA,wBACA,GACA,QAAiB,QAAU,YAC3B,6BAEA,EACA,MACA,UACA,kBACA,iBACA,SACA,CAAiB,EACjB,eACA,EACA,6BACA,kBACA,GAEA,2BACA,MAEA,wBAGA,yBACA,GAAkC,OAAW,EAC7C,kBACA,MAA2B,QAAc,YACzC,iBACiB,EAEjB,MAA8B,SAAc,EAC5C,kBACA,cACA,oCACA,CAAa,EACb,EAA0B,QAAc,YACxC,YACA,YACA,SACA,KACA,QACA,kBACA,WACA,eACA,WACA,CAAqB,CACJ,CACJ,EASb,MARY,OAAgB,EAC5B,gBACA,aACA,kCACA,wCACA,mBACA,4BACA,CAAa,EACb,CACA,CAAS,CACT,8BACA,MAA8B,SAAmB,EACjD,kBACA,eACA,8CACA,CAAa,EACb,gBACA,uCAEA,WACA,MACA,uCAEA,MAA0B,QAAc,YACxC,YACA,YACA,SACA,KACA,QACA,iBACA,CAAiB,CACJ,EASb,MARY,OAAgB,EAC5B,gBACA,aACA,kCACA,wCACA,mBACA,gCACA,CAAa,EACb,CACA,CAAS,CACT,2BAA4B,EAAS,EACrC,4BACA,gCACA,+BACA,kCACA,kBACA,SACA,CAAiB,EAEjB,4BAAoB,GAA0B,MAAQ,0DAA0B,CAChF,UACA,kBACA,kCACA,UACA,SACA,CAAa,CACb,CAAS,CACT,uBACA,8BACA,kCACA,+BACA,kCACA,kBACA,WACA,CAAiB,EAEjB,8BAAoB,GAA4B,MAAQ,0DAA0B,CAClF,UACA,kBACA,kCACA,UACA,WACA,CAAa,CACb,CAAS,CACT,gCACA,6CAEA,EACA,QACA,CACA,qBACA,oBAAY,8BAA2C,EACvD,iBACA,EAA0B,OAAW,EACrC,UACA,cACA,gBACK,EAML,SALmC,QAAS,EAC5C,WACA,gBACA,2BACK,EACL,GACA,OAEA,MAAsB,OAAO,EAC7B,WACA,2BACA,UAAmB,EAAS,GACvB,EACL,EAF4B,MAEE,OAAyB,EACvD,cACA,eACK,EACL,EAAsB,SAAc,EACpC,kBACA,cACA,oCACA,CAAK,CACL,WACA,YACA,SACA,KACA,WACA,eACA,qBACA,CAAa,CACJ,CACJ,CACL,CA+EA,qBACA,cAAY,aAAqB,EACjC,IACA,YAAqC,GAAoB,CACzD,cACA,EAFyD,cAEzD,kBACA,kCACA,uCACA,wBACA,sBACS,EACT,QAAmC,GAAU,CAC7C,MAD6C,CAC7C,SACA,cACA,+BACA,iDACA,QACA,CAAS,EACT,GACA,cACA,gBACA,mCACA,gDACA,EACA,QAAiC,GAAY,CAC7C,QAD6C,EAE7C,QACA,CAAS,EAET,QAA8B,GAAoB,CAClD,KACA,YACA,CAAS,EAST,MARQ,OAAgB,EACxB,gBACA,mBACA,kCACA,wCACA,mBACA,sBAAmC,OAAoB,cACvD,CAAS,EACT,CACA,gBACA,cACA,kCAEA,QACA,CAEQ,GAAqB,mBAE7B,CACO,eAAe,GAAwB,OAC9C,MAA4B,OAAW,EACvC,KAF8C,GAE9C,EACA,SACA,OACA,CAAK,EACL,IAKA,OAJA,MAAwC,kBAAY,EACpD,WACA,4DACA,CAAS,CAET,CACA,MACA,MACA,CACA","sources":["webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/lib/calls.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IAccountPermissions/read/getPermissionsForSigner.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IAccountPermissions/write/setPermissionsForSigner.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/date.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/account/types.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/account/common.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/account/addSessionKey.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/types.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/address/isAddressEqual.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/hash/toEventSelector.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/abi/decodeEventLog.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/abi/parseEventLogs.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/event/actions/parse-logs.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/errors/log.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/abi/getAbiItem.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/abi/encodeEventTopics.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/event/utils.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/event/prepare-event.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/types.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/lib/utils.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/lib/bundler.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/lib/packUserOp.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/lib/paymaster.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/lib/userop.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/wallets/smart/index.js"],"sourcesContent":["import { getContract, } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { isHex, stringToHex } from \"../../../utils/encoding/hex.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { DEFAULT_ACCOUNT_FACTORY_V0_6 } from \"./constants.js\";\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictSmartAccountAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictSmartAccountAddress({\n *  client,\n *  chain,\n *  adminAddress,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictSmartAccountAddress(args) {\n    return predictAddress({\n        adminAddress: args.adminAddress,\n        accountSalt: args.accountSalt,\n        factoryContract: getContract({\n            address: args.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY_V0_6,\n            chain: args.chain,\n            client: args.client,\n        }),\n    });\n}\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n * @deprecated Use `predictSmartAccountAddress` instead.\n */\nexport async function predictAddress(args) {\n    const { factoryContract, predictAddressOverride: predictAddress, adminAddress, accountSalt, accountAddress, } = args;\n    if (predictAddress) {\n        return predictAddress(factoryContract, adminAddress);\n    }\n    if (accountAddress) {\n        return accountAddress;\n    }\n    if (!adminAddress) {\n        throw new Error(\"Account address is required to predict the smart wallet address.\");\n    }\n    return withCache(async () => {\n        const saltHex = accountSalt && isHex(accountSalt)\n            ? accountSalt\n            : stringToHex(accountSalt ?? \"\");\n        return readContract({\n            contract: factoryContract,\n            method: \"function getAddress(address, bytes) returns (address)\",\n            params: [adminAddress, saltHex],\n        });\n    }, {\n        cacheKey: `${args.factoryContract.chain.id}-${args.factoryContract.address}-${args.adminAddress}-${args.accountSalt}`,\n        cacheTime: 1000 * 60 * 60 * 24, // 1 day\n    });\n}\n/**\n * @internal\n */\nexport function prepareCreateAccount(args) {\n    const { adminAddress, factoryContract, createAccountOverride: createAccount, accountSalt, } = args;\n    if (createAccount) {\n        return createAccount(factoryContract, adminAddress);\n    }\n    const saltHex = accountSalt && isHex(accountSalt)\n        ? accountSalt\n        : stringToHex(accountSalt ?? \"\");\n    return prepareContractCall({\n        contract: factoryContract,\n        method: \"function createAccount(address, bytes) returns (address)\",\n        params: [adminAddress, saltHex],\n    });\n}\n/**\n * @internal\n */\nexport function prepareExecute(args) {\n    const { accountContract, transaction, executeOverride: execute } = args;\n    if (execute) {\n        return execute(accountContract, transaction);\n    }\n    return prepareContractCall({\n        contract: accountContract,\n        method: \"function execute(address, uint256, bytes)\",\n        params: [\n            transaction.to || \"\",\n            transaction.value || 0n,\n            transaction.data || \"0x\",\n        ],\n        // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract\n        // this avoids another estimateGas call when bundling the userOp\n        // and also allows for passing custom gas limits for the inner tx\n        gas: transaction.gas ? transaction.gas + 21000n : undefined,\n    });\n}\n/**\n * @internal\n */\nexport function prepareBatchExecute(args) {\n    const { accountContract, transactions, executeBatchOverride: executeBatch, } = args;\n    if (executeBatch) {\n        return executeBatch(accountContract, transactions);\n    }\n    return prepareContractCall({\n        contract: accountContract,\n        method: \"function executeBatch(address[], uint256[], bytes[])\",\n        params: [\n            transactions.map((tx) => tx.to || \"\"),\n            transactions.map((tx) => tx.value || 0n),\n            transactions.map((tx) => tx.data || \"0x\"),\n        ],\n    });\n}\n//# sourceMappingURL=calls.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0xf15d424e\";\nconst FN_INPUTS = [\n    {\n        type: \"address\",\n        name: \"signer\",\n    },\n];\nconst FN_OUTPUTS = [\n    {\n        type: \"tuple\",\n        name: \"permissions\",\n        components: [\n            {\n                type: \"address\",\n                name: \"signer\",\n            },\n            {\n                type: \"address[]\",\n                name: \"approvedTargets\",\n            },\n            {\n                type: \"uint256\",\n                name: \"nativeTokenLimitPerTransaction\",\n            },\n            {\n                type: \"uint128\",\n                name: \"startTimestamp\",\n            },\n            {\n                type: \"uint128\",\n                name: \"endTimestamp\",\n            },\n        ],\n    },\n];\n/**\n * Checks if the `getPermissionsForSigner` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getPermissionsForSigner` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetPermissionsForSignerSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetPermissionsForSignerSupported([\"0x...\"]);\n * ```\n */\nexport function isGetPermissionsForSignerSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Encodes the parameters for the \"getPermissionsForSigner\" function.\n * @param options - The options for the getPermissionsForSigner function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetPermissionsForSignerParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetPermissionsForSignerParams({\n *  signer: ...,\n * });\n * ```\n */\nexport function encodeGetPermissionsForSignerParams(options) {\n    return encodeAbiParameters(FN_INPUTS, [options.signer]);\n}\n/**\n * Encodes the \"getPermissionsForSigner\" function into a Hex string with its parameters.\n * @param options - The options for the getPermissionsForSigner function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetPermissionsForSigner({\n *  signer: ...,\n * });\n * ```\n */\nexport function encodeGetPermissionsForSigner(options) {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    return (FN_SELECTOR +\n        encodeGetPermissionsForSignerParams(options).slice(2));\n}\n/**\n * Decodes the result of the getPermissionsForSigner function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetPermissionsForSignerResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetPermissionsForSignerResultResult(\"...\");\n * ```\n */\nexport function decodeGetPermissionsForSignerResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"getPermissionsForSigner\" function on the contract.\n * @param options - The options for the getPermissionsForSigner function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getPermissionsForSigner({\n *  contract,\n *  signer: ...,\n * });\n *\n * ```\n */\nexport async function getPermissionsForSigner(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [options.signer],\n    });\n}\n//# sourceMappingURL=getPermissionsForSigner.js.map","import { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0x5892e236\";\nconst FN_INPUTS = [\n    {\n        type: \"tuple\",\n        name: \"req\",\n        components: [\n            {\n                type: \"address\",\n                name: \"signer\",\n            },\n            {\n                type: \"uint8\",\n                name: \"isAdmin\",\n            },\n            {\n                type: \"address[]\",\n                name: \"approvedTargets\",\n            },\n            {\n                type: \"uint256\",\n                name: \"nativeTokenLimitPerTransaction\",\n            },\n            {\n                type: \"uint128\",\n                name: \"permissionStartTimestamp\",\n            },\n            {\n                type: \"uint128\",\n                name: \"permissionEndTimestamp\",\n            },\n            {\n                type: \"uint128\",\n                name: \"reqValidityStartTimestamp\",\n            },\n            {\n                type: \"uint128\",\n                name: \"reqValidityEndTimestamp\",\n            },\n            {\n                type: \"bytes32\",\n                name: \"uid\",\n            },\n        ],\n    },\n    {\n        type: \"bytes\",\n        name: \"signature\",\n    },\n];\nconst FN_OUTPUTS = [];\n/**\n * Checks if the `setPermissionsForSigner` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `setPermissionsForSigner` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isSetPermissionsForSignerSupported } from \"thirdweb/extensions/erc4337\";\n *\n * const supported = isSetPermissionsForSignerSupported([\"0x...\"]);\n * ```\n */\nexport function isSetPermissionsForSignerSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Encodes the parameters for the \"setPermissionsForSigner\" function.\n * @param options - The options for the setPermissionsForSigner function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeSetPermissionsForSignerParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeSetPermissionsForSignerParams({\n *  req: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeSetPermissionsForSignerParams(options) {\n    return encodeAbiParameters(FN_INPUTS, [options.req, options.signature]);\n}\n/**\n * Encodes the \"setPermissionsForSigner\" function into a Hex string with its parameters.\n * @param options - The options for the setPermissionsForSigner function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeSetPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n * const result = encodeSetPermissionsForSigner({\n *  req: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeSetPermissionsForSigner(options) {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    return (FN_SELECTOR +\n        encodeSetPermissionsForSignerParams(options).slice(2));\n}\n/**\n * Prepares a transaction to call the \"setPermissionsForSigner\" function on the contract.\n * @param options - The options for the \"setPermissionsForSigner\" function.\n * @returns A prepared transaction object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { setPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n *\n * const transaction = setPermissionsForSigner({\n *  contract,\n *  req: ...,\n *  signature: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function setPermissionsForSigner(options) {\n    const asyncOptions = once(async () => {\n        return \"asyncParams\" in options ? await options.asyncParams() : options;\n    });\n    return prepareContractCall({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: async () => {\n            const resolvedOptions = await asyncOptions();\n            return [resolvedOptions.req, resolvedOptions.signature];\n        },\n        value: async () => (await asyncOptions()).overrides?.value,\n        accessList: async () => (await asyncOptions()).overrides?.accessList,\n        gas: async () => (await asyncOptions()).overrides?.gas,\n        gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n        maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n        maxPriorityFeePerGas: async () => (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n        nonce: async () => (await asyncOptions()).overrides?.nonce,\n        extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n        erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    });\n}\n//# sourceMappingURL=setPermissionsForSigner.js.map","import { toBigInt } from \"./bigint.js\";\n/**\n * @internal\n */\nexport function tenYearsFromNow() {\n    return new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10); // 10 years\n}\n/**\n * @internal\n */\nexport function dateToSeconds(date) {\n    return toBigInt(Math.floor(date.getTime() / 1000));\n}\n//# sourceMappingURL=date.js.map","export const SignerPermissionRequest = [\n    { name: \"signer\", type: \"address\" },\n    { name: \"isAdmin\", type: \"uint8\" },\n    { name: \"approvedTargets\", type: \"address[]\" },\n    { name: \"nativeTokenLimitPerTransaction\", type: \"uint256\" },\n    { name: \"permissionStartTimestamp\", type: \"uint128\" },\n    { name: \"permissionEndTimestamp\", type: \"uint128\" },\n    { name: \"reqValidityStartTimestamp\", type: \"uint128\" },\n    { name: \"reqValidityEndTimestamp\", type: \"uint128\" },\n    { name: \"uid\", type: \"bytes32\" },\n];\n//# sourceMappingURL=types.js.map","import { ZERO_ADDRESS } from \"../../../constants/addresses.js\";\nimport { dateToSeconds, tenYearsFromNow } from \"../../../utils/date.js\";\nimport { randomBytesHex } from \"../../../utils/random.js\";\nimport { toWei } from \"../../../utils/units.js\";\nimport { SignerPermissionRequest } from \"./types.js\";\n/**\n * @internal\n */\nexport async function signPermissionRequest(options) {\n    const { account, contract, req } = options;\n    const signature = await account.signTypedData({\n        domain: {\n            name: \"Account\",\n            version: \"1\",\n            verifyingContract: contract.address,\n            chainId: contract.chain.id,\n        },\n        primaryType: \"SignerPermissionRequest\",\n        types: { SignerPermissionRequest },\n        message: req,\n    });\n    return { req, signature };\n}\n/**\n * @internal\n */\nexport async function toContractPermissions(options) {\n    const { target, permissions } = options;\n    return {\n        approvedTargets: permissions.approvedTargets === \"*\"\n            ? [ZERO_ADDRESS]\n            : permissions.approvedTargets,\n        nativeTokenLimitPerTransaction: toWei(permissions.nativeTokenLimitPerTransaction?.toString() || \"0\"),\n        permissionStartTimestamp: dateToSeconds(permissions.permissionStartTimestamp || new Date(0)),\n        permissionEndTimestamp: dateToSeconds(permissions.permissionEndTimestamp || tenYearsFromNow()),\n        reqValidityStartTimestamp: 0n,\n        reqValidityEndTimestamp: dateToSeconds(tenYearsFromNow()),\n        uid: await randomBytesHex(),\n        isAdmin: 0, // session key flag\n        signer: target,\n    };\n}\n/**\n * @internal\n */\nexport async function defaultPermissionsForAdmin(options) {\n    const { target, action } = options;\n    return {\n        approvedTargets: [],\n        nativeTokenLimitPerTransaction: 0n,\n        permissionStartTimestamp: 0n,\n        permissionEndTimestamp: 0n,\n        reqValidityStartTimestamp: 0n,\n        reqValidityEndTimestamp: dateToSeconds(tenYearsFromNow()),\n        uid: await randomBytesHex(),\n        isAdmin: action === \"add-admin\" ? 1 : action === \"remove-admin\" ? 2 : 0,\n        signer: target,\n    };\n}\n//# sourceMappingURL=common.js.map","import { ZERO_ADDRESS } from \"../../../constants/addresses.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { toWei } from \"../../../utils/units.js\";\nimport { getPermissionsForSigner } from \"../__generated__/IAccountPermissions/read/getPermissionsForSigner.js\";\nimport { isSetPermissionsForSignerSupported, setPermissionsForSigner, } from \"../__generated__/IAccountPermissions/write/setPermissionsForSigner.js\";\nimport { signPermissionRequest, toContractPermissions } from \"./common.js\";\n/**\n * Adds session key permissions for a specified address.\n * @param options - The options for the removeSessionKey function.\n * @param {Contract} options.contract - The smart account contract to add the session key to\n * @returns The transaction object to be sent.\n * @example\n * ```ts\n * import { addSessionKey } from 'thirdweb/extensions/erc4337';\n * import { sendTransaction } from 'thirdweb';\n *\n * const transaction = addSessionKey({\n * contract,\n * account,\n * sessionKeyAddress,\n * permissions: {\n *  approvedTargets: ['0x...'],\n *  nativeTokenLimitPerTransaction: 0.1, // in ETH\n *  permissionStartTimestamp: new Date(),\n *  permissionEndTimestamp: new Date(Date.now() + 1000 * 60 * 60 * 24 * 365), // 1 year from now\n * }\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n * @extension ERC4337\n */\nexport function addSessionKey(options) {\n    const { contract, sessionKeyAddress, account, permissions } = options;\n    return setPermissionsForSigner({\n        contract,\n        async asyncParams() {\n            const { req, signature } = await signPermissionRequest({\n                account,\n                contract,\n                req: await toContractPermissions({\n                    target: sessionKeyAddress,\n                    permissions,\n                }),\n            });\n            return { signature, req };\n        },\n    });\n}\n/**\n * Checks if the `isAddSessionKeySupported` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isAddSessionKeySupported` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isAddSessionKeySupported } from \"thirdweb/extensions/erc4337\";\n *\n * const supported = isAddSessionKeySupported([\"0x...\"]);\n * ```\n */\nexport function isAddSessionKeySupported(availableSelectors) {\n    return isSetPermissionsForSignerSupported(availableSelectors);\n}\n/**\n * Checks if the session key should be updated.\n * @param currentPermissions - The current permissions of the session key.\n * @param newPermissions - The new permissions to set for the session key.\n * @returns A boolean indicating if the session key should be updated.\n * @extension ERC4337\n * @example\n * ```ts\n * import { shouldUpdateSessionKey } from \"thirdweb/extensions/erc4337\";\n *\n * const shouldUpdate = await shouldUpdateSessionKey({ accountContract, sessionKeyAddress, newPermissions });\n * ```\n */\nexport async function shouldUpdateSessionKey(args) {\n    const { accountContract, sessionKeyAddress, newPermissions } = args;\n    // check if account is deployed\n    const accountDeployed = await isContractDeployed(accountContract);\n    if (!accountDeployed) {\n        return true;\n    }\n    // get current permissions\n    const currentPermissions = await getPermissionsForSigner({\n        contract: accountContract,\n        signer: sessionKeyAddress,\n    });\n    // check end time validity\n    if (currentPermissions.endTimestamp &&\n        currentPermissions.endTimestamp < Math.floor(new Date().getTime() / 1000)) {\n        return true;\n    }\n    // check targets\n    if (!areSessionKeyContractTargetsEqual(currentPermissions.approvedTargets, newPermissions.approvedTargets)) {\n        return true;\n    }\n    // check if the new native token limit is greater than the current one\n    if (toWei(newPermissions.nativeTokenLimitPerTransaction?.toString() ?? \"0\") >\n        currentPermissions.nativeTokenLimitPerTransaction) {\n        return true;\n    }\n    return false;\n}\nfunction areSessionKeyContractTargetsEqual(currentTargets, newTargets) {\n    // Handle the case where approvedTargets is \"*\"\n    if (newTargets === \"*\" &&\n        currentTargets.length === 1 &&\n        currentTargets[0] === ZERO_ADDRESS) {\n        return true;\n    }\n    if (newTargets !== \"*\") {\n        return newTargets\n            .map((target) => target.toLowerCase())\n            .every((target) => currentTargets.map((t) => t.toLowerCase()).includes(target));\n    }\n    return false;\n}\n//# sourceMappingURL=addSessionKey.js.map","/**\n * @internal\n */\nexport const maxUint96 = 2n ** 96n - 1n;\n//# sourceMappingURL=types.js.map","import { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n    if (!isAddress(a, { strict: false }))\n        throw new InvalidAddressError({ address: a });\n    if (!isAddress(b, { strict: false }))\n        throw new InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map","import { toSignatureHash, } from './toSignatureHash.js';\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash;\n//# sourceMappingURL=toEventSelector.js.map","import { AbiDecodingDataSizeTooSmallError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { size } from '../data/size.js';\nimport { toEventSelector, } from '../hash/toEventSelector.js';\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nconst docsPath = '/docs/contract/decodeEventLog';\nexport function decodeEventLog(parameters) {\n    const { abi, data, strict: strict_, topics, } = parameters;\n    const strict = strict_ ?? true;\n    const [signature, ...argTopics] = topics;\n    if (!signature)\n        throw new AbiEventSignatureEmptyTopicsError({ docsPath });\n    const abiItem = (() => {\n        if (abi.length === 1)\n            return abi[0];\n        return abi.find((x) => x.type === 'event' &&\n            signature === toEventSelector(formatAbiItem(x)));\n    })();\n    if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n        throw new AbiEventSignatureNotFoundError(signature, { docsPath });\n    const { name, inputs } = abiItem;\n    const isUnnamed = inputs?.some((x) => !('name' in x && x.name));\n    let args = isUnnamed ? [] : {};\n    // Decode topics (indexed args).\n    const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed);\n    for (let i = 0; i < indexedInputs.length; i++) {\n        const param = indexedInputs[i];\n        const topic = argTopics[i];\n        if (!topic)\n            throw new DecodeLogTopicsMismatch({\n                abiItem,\n                param: param,\n            });\n        args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });\n    }\n    // Decode data (non-indexed args).\n    const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));\n    if (nonIndexedInputs.length > 0) {\n        if (data && data !== '0x') {\n            try {\n                const decodedData = decodeAbiParameters(nonIndexedInputs, data);\n                if (decodedData) {\n                    if (isUnnamed)\n                        args = [...args, ...decodedData];\n                    else {\n                        for (let i = 0; i < nonIndexedInputs.length; i++) {\n                            args[nonIndexedInputs[i].name] = decodedData[i];\n                        }\n                    }\n                }\n            }\n            catch (err) {\n                if (strict) {\n                    if (err instanceof AbiDecodingDataSizeTooSmallError ||\n                        err instanceof PositionOutOfBoundsError)\n                        throw new DecodeLogDataMismatch({\n                            abiItem,\n                            data: data,\n                            params: nonIndexedInputs,\n                            size: size(data),\n                        });\n                    throw err;\n                }\n            }\n        }\n        else if (strict) {\n            throw new DecodeLogDataMismatch({\n                abiItem,\n                data: '0x',\n                params: nonIndexedInputs,\n                size: 0,\n            });\n        }\n    }\n    return {\n        eventName: name,\n        args: Object.values(args).length > 0 ? args : undefined,\n    };\n}\nfunction decodeTopic({ param, value }) {\n    if (param.type === 'string' ||\n        param.type === 'bytes' ||\n        param.type === 'tuple' ||\n        param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n        return value;\n    const decodedArg = decodeAbiParameters([param], value) || [];\n    return decodedArg[0];\n}\n//# sourceMappingURL=decodeEventLog.js.map","// TODO(v3): checksum address.\nimport { AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { isAddressEqual } from '../address/isAddressEqual.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { decodeEventLog, } from './decodeEventLog.js';\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs(parameters) {\n    const { abi, args, logs, strict = true } = parameters;\n    const eventName = (() => {\n        if (!parameters.eventName)\n            return undefined;\n        if (Array.isArray(parameters.eventName))\n            return parameters.eventName;\n        return [parameters.eventName];\n    })();\n    return logs\n        .map((log) => {\n        try {\n            const abiItem = abi.find((abiItem) => abiItem.type === 'event' &&\n                log.topics[0] === toEventSelector(abiItem));\n            if (!abiItem)\n                return null;\n            const event = decodeEventLog({\n                ...log,\n                abi: [abiItem],\n                strict,\n            });\n            // Check that the decoded event name matches the provided event name.\n            if (eventName && !eventName.includes(event.eventName))\n                return null;\n            // Check that the decoded event args match the provided args.\n            if (!includesArgs({\n                args: event.args,\n                inputs: abiItem.inputs,\n                matchArgs: args,\n            }))\n                return null;\n            return { ...event, ...log };\n        }\n        catch (err) {\n            let eventName;\n            let isUnnamed;\n            if (err instanceof AbiEventSignatureNotFoundError)\n                return null;\n            if (err instanceof DecodeLogDataMismatch ||\n                err instanceof DecodeLogTopicsMismatch) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict)\n                    return null;\n                eventName = err.abiItem.name;\n                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));\n            }\n            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n            return { ...log, args: isUnnamed ? [] : {}, eventName };\n        }\n    })\n        .filter(Boolean);\n}\nfunction includesArgs(parameters) {\n    const { args, inputs, matchArgs } = parameters;\n    if (!matchArgs)\n        return true;\n    if (!args)\n        return false;\n    function isEqual(input, value, arg) {\n        try {\n            if (input.type === 'address')\n                return isAddressEqual(value, arg);\n            if (input.type === 'string' || input.type === 'bytes')\n                return keccak256(toBytes(value)) === arg;\n            return value === arg;\n        }\n        catch {\n            return false;\n        }\n    }\n    if (Array.isArray(args) && Array.isArray(matchArgs)) {\n        return matchArgs.every((value, index) => {\n            if (value === null || value === undefined)\n                return true;\n            const input = inputs[index];\n            if (!input)\n                return false;\n            const value_ = Array.isArray(value) ? value : [value];\n            return value_.some((value) => isEqual(input, value, args[index]));\n        });\n    }\n    if (typeof args === 'object' &&\n        !Array.isArray(args) &&\n        typeof matchArgs === 'object' &&\n        !Array.isArray(matchArgs))\n        return Object.entries(matchArgs).every(([key, value]) => {\n            if (value === null || value === undefined)\n                return true;\n            const input = inputs.find((input) => input.name === key);\n            if (!input)\n                return false;\n            const value_ = Array.isArray(value) ? value : [value];\n            return value_.some((value) => isEqual(input, value, args[key]));\n        });\n    return false;\n}\n//# sourceMappingURL=parseEventLogs.js.map","import { parseEventLogs as viem_parseEventLogs, } from \"viem\";\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs(options) {\n    const { logs, events, strict } = options;\n    return viem_parseEventLogs({\n        logs,\n        abi: events.map((e) => e.abiEvent),\n        strict,\n    });\n}\n//# sourceMappingURL=parse-logs.js.map","import { BaseError } from './base.js';\nexport class FilterTypeNotSupportedError extends BaseError {\n    constructor(type) {\n        super(`Filter type \"${type}\" is not supported.`, {\n            name: 'FilterTypeNotSupportedError',\n        });\n    }\n}\n//# sourceMappingURL=log.js.map","import { AbiItemAmbiguityError, } from '../../errors/abi.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nexport function getAbiItem(parameters) {\n    const { abi, args = [], name } = parameters;\n    const isSelector = isHex(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function')\n                return toFunctionSelector(abiItem) === name;\n            if (abiItem.type === 'event')\n                return toEventSelector(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        return undefined;\n    if (abiItems.length === 1)\n        return abiItems[0];\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return abiItem;\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AbiItemAmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    if (matchedAbiItem)\n        return matchedAbiItem;\n    return abiItems[0];\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return isAddress(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return isAddress(args[parameterIndex], { strict: false });\n            if (types.includes('address') && types.includes('bytes'))\n                return isAddress(args[parameterIndex], { strict: false });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=getAbiItem.js.map","import { AbiEventNotFoundError, } from '../../errors/abi.js';\nimport { FilterTypeNotSupportedError, } from '../../errors/log.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector, } from '../hash/toEventSelector.js';\nimport { encodeAbiParameters, } from './encodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeEventTopics';\nexport function encodeEventTopics(parameters) {\n    const { abi, eventName, args } = parameters;\n    let abiItem = abi[0];\n    if (eventName) {\n        const item = getAbiItem({ abi, name: eventName });\n        if (!item)\n            throw new AbiEventNotFoundError(eventName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'event')\n        throw new AbiEventNotFoundError(undefined, { docsPath });\n    const definition = formatAbiItem(abiItem);\n    const signature = toEventSelector(definition);\n    let topics = [];\n    if (args && 'inputs' in abiItem) {\n        const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);\n        const args_ = Array.isArray(args)\n            ? args\n            : Object.values(args).length > 0\n                ? (indexedInputs?.map((x) => args[x.name]) ?? [])\n                : [];\n        if (args_.length > 0) {\n            topics =\n                indexedInputs?.map((param, i) => {\n                    if (Array.isArray(args_[i]))\n                        return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));\n                    return typeof args_[i] !== 'undefined' && args_[i] !== null\n                        ? encodeArg({ param, value: args_[i] })\n                        : null;\n                }) ?? [];\n        }\n    }\n    return [signature, ...topics];\n}\nfunction encodeArg({ param, value, }) {\n    if (param.type === 'string' || param.type === 'bytes')\n        return keccak256(toBytes(value));\n    if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n        throw new FilterTypeNotSupportedError(param.type);\n    return encodeAbiParameters([param], [value]);\n}\n//# sourceMappingURL=encodeEventTopics.js.map","/**\n * @internal\n */\nexport function isAbiEvent(item) {\n    return !!(item &&\n        typeof item === \"object\" &&\n        \"type\" in item &&\n        item.type === \"event\");\n}\n//# sourceMappingURL=utils.js.map","import { parseAbiItem } from \"abitype\";\nimport { encodeEventTopics, toEventHash } from \"viem\";\nimport { isAbiEvent } from \"./utils.js\";\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent(options) {\n    const { signature } = options;\n    let resolvedSignature;\n    if (isAbiEvent(signature)) {\n        resolvedSignature = signature;\n    }\n    else {\n        resolvedSignature = parseAbiItem(signature);\n    }\n    return {\n        abiEvent: resolvedSignature,\n        hash: toEventHash(resolvedSignature),\n        // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n        topics: encodeEventTopics({\n            abi: [resolvedSignature],\n            args: options.filters,\n        }),\n    };\n}\n//# sourceMappingURL=prepare-event.js.map","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(filters = {}) {\n    return prepareEvent({\n        signature: \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n        filters,\n    });\n}\n//# sourceMappingURL=UserOperationRevertReason.js.map","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\n/**\n * Creates an event object for the PostOpRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { postOpRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  postOpRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function postOpRevertReasonEvent(filters = {}) {\n    return prepareEvent({\n        signature: \"event PostOpRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n        filters,\n    });\n}\n//# sourceMappingURL=PostOpRevertReason.js.map","export function formatUserOperationReceipt(userOpReceiptRaw) {\n    const { receipt: transactionReceipt } = userOpReceiptRaw;\n    const receipt = {\n        ...transactionReceipt,\n        transactionHash: transactionReceipt.transactionHash,\n        blockNumber: transactionReceipt.blockNumber\n            ? BigInt(transactionReceipt.blockNumber)\n            : null,\n        contractAddress: transactionReceipt.contractAddress\n            ? transactionReceipt.contractAddress\n            : null,\n        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n            ? BigInt(transactionReceipt.cumulativeGasUsed)\n            : null,\n        effectiveGasPrice: transactionReceipt.effectiveGasPrice\n            ? BigInt(transactionReceipt.effectiveGasPrice)\n            : null,\n        gasUsed: transactionReceipt.gasUsed\n            ? BigInt(transactionReceipt.gasUsed)\n            : null,\n        logs: transactionReceipt.logs,\n        to: transactionReceipt.to ? transactionReceipt.to : null,\n        transactionIndex: transactionReceipt.transactionIndex,\n        status: transactionReceipt.status,\n        type: transactionReceipt.type,\n    };\n    if (transactionReceipt.blobGasPrice)\n        receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n    if (transactionReceipt.blobGasUsed)\n        receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n    const userOpReceipt = {\n        ...userOpReceiptRaw,\n        receipt,\n        userOpHash: userOpReceiptRaw.userOpHash,\n        actualGasCost: BigInt(userOpReceiptRaw.actualGasCost),\n        actualGasUsed: BigInt(userOpReceiptRaw.actualGasUsed),\n        nonce: BigInt(userOpReceiptRaw.nonce),\n    };\n    return userOpReceipt;\n}\n//# sourceMappingURL=types.js.map","import { isHex, toHex } from \"../../../utils/encoding/hex.js\";\nexport const generateRandomUint192 = () => {\n    const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n    const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n    const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n    const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n    const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n    const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n    return ((rand1 << BigInt(160)) |\n        (rand2 << BigInt(128)) |\n        (rand3 << BigInt(96)) |\n        (rand4 << BigInt(64)) |\n        (rand5 << BigInt(32)) |\n        rand6);\n};\n/**\n * @internal\n */\nexport function hexlifyUserOp(userOp) {\n    return Object.fromEntries(Object.entries(userOp).map(([key, val]) => [\n        key,\n        // turn any value that's not hex into hex\n        val === undefined || val === null || isHex(val) ? val : toHex(val),\n    ]));\n}\n//# sourceMappingURL=utils.js.map","import { decodeErrorResult } from \"viem\";\nimport { getContract } from \"../../../contract/contract.js\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport { postOpRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { toEther } from \"../../../utils/units.js\";\nimport { getEntrypointFromFactory } from \"../index.js\";\nimport { formatUserOperationReceipt, } from \"../types.js\";\nimport { predictSmartAccountAddress } from \"./calls.js\";\nimport { ENTRYPOINT_ADDRESS_v0_6, MANAGED_ACCOUNT_GAS_BUFFER, getDefaultBundlerUrl, } from \"./constants.js\";\nimport { prepareUserOp } from \"./userop.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args) {\n    return sendBundlerRequest({\n        ...args,\n        operation: \"eth_sendUserOperation\",\n        params: [\n            hexlifyUserOp(args.userOp),\n            args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n        ],\n    });\n}\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(args, stateOverrides) {\n    const res = await sendBundlerRequest({\n        ...args,\n        operation: \"eth_estimateUserOperationGas\",\n        params: [\n            hexlifyUserOp(args.userOp),\n            args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n            stateOverrides ?? {},\n        ],\n    });\n    // add gas buffer for managed account factory delegate calls\n    return {\n        preVerificationGas: hexToBigInt(res.preVerificationGas),\n        verificationGas: res.verificationGas !== undefined\n            ? hexToBigInt(res.verificationGas)\n            : undefined,\n        verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n        callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n        paymasterVerificationGasLimit: res.paymasterVerificationGasLimit !== undefined\n            ? hexToBigInt(res.paymasterVerificationGasLimit)\n            : undefined,\n        paymasterPostOpGasLimit: res.paymasterPostOpGasLimit !== undefined\n            ? hexToBigInt(res.paymasterPostOpGasLimit)\n            : undefined,\n    };\n}\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGasCost } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGasCost({\n *  transactions,\n *  adminAccount,\n *  client,\n *  smartWalletOptions,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGasCost(args) {\n    // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n    if (args.smartWalletOptions.factoryAddress &&\n        !args.smartWalletOptions.overrides?.entrypointAddress) {\n        const entrypointAddress = await getEntrypointFromFactory(args.smartWalletOptions.factoryAddress, args.client, args.smartWalletOptions.chain);\n        if (entrypointAddress) {\n            args.smartWalletOptions.overrides = {\n                ...args.smartWalletOptions.overrides,\n                entrypointAddress,\n            };\n        }\n    }\n    const userOp = await prepareUserOp({\n        transactions: args.transactions,\n        adminAccount: args.adminAccount,\n        client: args.client,\n        smartWalletOptions: args.smartWalletOptions,\n        isDeployedOverride: await isContractDeployed(getContract({\n            address: await predictSmartAccountAddress({\n                adminAddress: args.adminAccount.address,\n                factoryAddress: args.smartWalletOptions.factoryAddress,\n                chain: args.smartWalletOptions.chain,\n                client: args.client,\n            }),\n            chain: args.smartWalletOptions.chain,\n            client: args.client,\n        })),\n        waitForDeployment: false,\n    });\n    let gasLimit = 0n;\n    if (\"paymasterVerificationGasLimit\" in userOp) {\n        // v0.7\n        gasLimit =\n            BigInt(userOp.paymasterVerificationGasLimit ?? 0) +\n                BigInt(userOp.paymasterPostOpGasLimit ?? 0) +\n                BigInt(userOp.verificationGasLimit ?? 0) +\n                BigInt(userOp.preVerificationGas ?? 0) +\n                BigInt(userOp.callGasLimit ?? 0);\n    }\n    else {\n        // v0.6\n        gasLimit =\n            BigInt(userOp.verificationGasLimit ?? 0) +\n                BigInt(userOp.preVerificationGas ?? 0) +\n                BigInt(userOp.callGasLimit ?? 0);\n    }\n    const gasCost = gasLimit * (userOp.maxFeePerGas ?? 0n);\n    return {\n        ether: toEther(gasCost),\n        wei: gasCost,\n    };\n}\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args) {\n    const res = await sendBundlerRequest({\n        ...args,\n        operation: \"thirdweb_getUserOperationGasPrice\",\n        params: [],\n    });\n    return {\n        maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n        maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n    };\n}\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(args) {\n    const res = await getUserOpReceiptRaw(args);\n    if (!res) {\n        return undefined;\n    }\n    if (res.success === false) {\n        // parse revert reason\n        const logs = parseEventLogs({\n            events: [userOperationRevertReasonEvent(), postOpRevertReasonEvent()],\n            logs: res.logs,\n        });\n        const revertReason = logs[0]?.args?.revertReason;\n        if (!revertReason) {\n            throw new Error(`UserOp failed at txHash: ${res.receipt.transactionHash}`);\n        }\n        const revertMsg = decodeErrorResult({\n            data: revertReason,\n        });\n        throw new Error(`UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${res.receipt.transactionHash}`);\n    }\n    return res.receipt;\n}\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(args) {\n    const res = await sendBundlerRequest({\n        options: args,\n        operation: \"eth_getUserOperationReceipt\",\n        params: [args.userOpHash],\n    });\n    if (!res) {\n        return undefined;\n    }\n    return formatUserOperationReceipt(res);\n}\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args) {\n    const res = await sendBundlerRequest({\n        options: args.options,\n        operation: \"zk_paymasterData\",\n        params: [args.transaction],\n    });\n    return {\n        paymaster: res.paymaster,\n        paymasterInput: res.paymasterInput,\n    };\n}\nexport async function broadcastZkTransaction(args) {\n    const res = await sendBundlerRequest({\n        options: args.options,\n        operation: \"zk_broadcastTransaction\",\n        params: [\n            {\n                ...args.transaction,\n                signedTransaction: args.signedTransaction,\n            },\n        ],\n    });\n    return {\n        transactionHash: res.transactionHash,\n    };\n}\nasync function sendBundlerRequest(args) {\n    const { options, operation, params } = args;\n    const bundlerUrl = options.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n    const fetchWithHeaders = getClientFetch(options.client);\n    const response = await fetchWithHeaders(bundlerUrl, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: stringify({\n            jsonrpc: \"2.0\",\n            id: 1,\n            method: operation,\n            params,\n        }),\n    });\n    const res = await response.json();\n    if (!response.ok || res.error) {\n        let error = res.error || response.statusText;\n        if (typeof error === \"object\") {\n            error = stringify(error);\n        }\n        const code = res.code || \"UNKNOWN\";\n        throw new Error(`${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n    }\n    return res.result;\n}\n//# sourceMappingURL=bundler.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0x35567e1a\";\nconst FN_INPUTS = [\n    {\n        type: \"address\",\n        name: \"sender\",\n    },\n    {\n        type: \"uint192\",\n        name: \"key\",\n    },\n];\nconst FN_OUTPUTS = [\n    {\n        type: \"uint256\",\n        name: \"nonce\",\n    },\n];\n/**\n * Checks if the `getNonce` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getNonce` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetNonceSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetNonceSupported([\"0x...\"]);\n * ```\n */\nexport function isGetNonceSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Encodes the parameters for the \"getNonce\" function.\n * @param options - The options for the getNonce function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonceParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonceParams({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonceParams(options) {\n    return encodeAbiParameters(FN_INPUTS, [options.sender, options.key]);\n}\n/**\n * Encodes the \"getNonce\" function into a Hex string with its parameters.\n * @param options - The options for the getNonce function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonce } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonce({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonce(options) {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    return (FN_SELECTOR +\n        encodeGetNonceParams(options).slice(2));\n}\n/**\n * Decodes the result of the getNonce function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetNonceResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetNonceResultResult(\"...\");\n * ```\n */\nexport function decodeGetNonceResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"getNonce\" function on the contract.\n * @param options - The options for the getNonce function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getNonce } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getNonce({\n *  contract,\n *  sender: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function getNonce(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [options.sender, options.key],\n    });\n}\n//# sourceMappingURL=getNonce.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0xa6193531\";\nconst FN_INPUTS = [\n    {\n        type: \"tuple\",\n        name: \"userOp\",\n        components: [\n            {\n                type: \"address\",\n                name: \"sender\",\n            },\n            {\n                type: \"uint256\",\n                name: \"nonce\",\n            },\n            {\n                type: \"bytes\",\n                name: \"initCode\",\n            },\n            {\n                type: \"bytes\",\n                name: \"callData\",\n            },\n            {\n                type: \"uint256\",\n                name: \"callGasLimit\",\n            },\n            {\n                type: \"uint256\",\n                name: \"verificationGasLimit\",\n            },\n            {\n                type: \"uint256\",\n                name: \"preVerificationGas\",\n            },\n            {\n                type: \"uint256\",\n                name: \"maxFeePerGas\",\n            },\n            {\n                type: \"uint256\",\n                name: \"maxPriorityFeePerGas\",\n            },\n            {\n                type: \"bytes\",\n                name: \"paymasterAndData\",\n            },\n            {\n                type: \"bytes\",\n                name: \"signature\",\n            },\n        ],\n    },\n];\nconst FN_OUTPUTS = [\n    {\n        type: \"bytes32\",\n    },\n];\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options) {\n    return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options) {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    return (FN_SELECTOR +\n        encodeGetUserOpHashParams(options).slice(2));\n}\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [options.userOp],\n    });\n}\n//# sourceMappingURL=getUserOpHash.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0x22cdde4c\";\nconst FN_INPUTS = [\n    {\n        type: \"tuple\",\n        name: \"userOp\",\n        components: [\n            {\n                type: \"address\",\n                name: \"sender\",\n            },\n            {\n                type: \"uint256\",\n                name: \"nonce\",\n            },\n            {\n                type: \"bytes\",\n                name: \"initCode\",\n            },\n            {\n                type: \"bytes\",\n                name: \"callData\",\n            },\n            {\n                type: \"bytes32\",\n                name: \"accountGasLimits\",\n            },\n            {\n                type: \"uint256\",\n                name: \"preVerificationGas\",\n            },\n            {\n                type: \"bytes32\",\n                name: \"gasFees\",\n            },\n            {\n                type: \"bytes\",\n                name: \"paymasterAndData\",\n            },\n            {\n                type: \"bytes\",\n                name: \"signature\",\n            },\n        ],\n    },\n];\nconst FN_OUTPUTS = [\n    {\n        type: \"bytes32\",\n    },\n];\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options) {\n    return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options) {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    return (FN_SELECTOR +\n        encodeGetUserOpHashParams(options).slice(2));\n}\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [options.userOp],\n    });\n}\n//# sourceMappingURL=getUserOpHash.js.map","import { concat, pad, toHex } from \"viem\";\nfunction getInitCode(unpackedUserOperation) {\n    return unpackedUserOperation.factory\n        ? concat([\n            unpackedUserOperation.factory,\n            unpackedUserOperation.factoryData || \"0x\",\n        ])\n        : \"0x\";\n}\nfunction getAccountGasLimits(unpackedUserOperation) {\n    return concat([\n        pad(toHex(BigInt(unpackedUserOperation.verificationGasLimit)), {\n            size: 16,\n        }),\n        pad(toHex(BigInt(unpackedUserOperation.callGasLimit)), { size: 16 }),\n    ]);\n}\nfunction getGasLimits(unpackedUserOperation) {\n    return concat([\n        pad(toHex(BigInt(unpackedUserOperation.maxPriorityFeePerGas)), {\n            size: 16,\n        }),\n        pad(toHex(BigInt(unpackedUserOperation.maxFeePerGas)), { size: 16 }),\n    ]);\n}\nfunction getPaymasterAndData(unpackedUserOperation) {\n    return unpackedUserOperation.paymaster\n        ? concat([\n            unpackedUserOperation.paymaster,\n            pad(toHex(BigInt(unpackedUserOperation.paymasterVerificationGasLimit || 0)), {\n                size: 16,\n            }),\n            pad(toHex(BigInt(unpackedUserOperation.paymasterPostOpGasLimit || 0)), {\n                size: 16,\n            }),\n            unpackedUserOperation.paymasterData || \"0x\",\n        ])\n        : \"0x\";\n}\nexport const getPackedUserOperation = (userOperation) => {\n    return {\n        sender: userOperation.sender,\n        nonce: BigInt(userOperation.nonce),\n        initCode: getInitCode(userOperation),\n        callData: userOperation.callData,\n        accountGasLimits: getAccountGasLimits(userOperation),\n        preVerificationGas: BigInt(userOperation.preVerificationGas),\n        gasFees: getGasLimits(userOperation),\n        paymasterAndData: getPaymasterAndData(userOperation),\n        signature: userOperation.signature,\n    };\n};\n//# sourceMappingURL=packUserOp.js.map","import { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { ENTRYPOINT_ADDRESS_v0_6, getDefaultBundlerUrl } from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n/**\n * Get paymaster and data details for a user operation.\n * @param args - The userOp and options\n * @returns - The paymaster and data details for the user operation.\n * @example\n * ```ts\n * import { getPaymasterAndData } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const paymasterAndData = await getPaymasterAndData({\n *  userOp,\n *  client,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getPaymasterAndData(args) {\n    const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;\n    if (paymasterOverride) {\n        return paymasterOverride(userOp);\n    }\n    const headers = {\n        \"Content-Type\": \"application/json\",\n    };\n    const entrypoint = entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n    const paymasterUrl = getDefaultBundlerUrl(chain);\n    const body = {\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"pm_sponsorUserOperation\",\n        params: [hexlifyUserOp(userOp), entrypoint],\n    };\n    // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n    const fetchWithHeaders = getClientFetch(client);\n    const response = await fetchWithHeaders(paymasterUrl, {\n        method: \"POST\",\n        headers,\n        body: stringify(body),\n    });\n    const res = await response.json();\n    if (!response.ok) {\n        const error = res.error || response.statusText;\n        const code = res.code || \"UNKNOWN\";\n        throw new Error(`Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n    }\n    if (res.result) {\n        // some paymasters return a string, some return an object with more data\n        if (typeof res.result === \"string\") {\n            return {\n                paymasterAndData: res.result,\n            };\n        }\n        // check for policy errors\n        if (res.result.policyId && res.result.reason) {\n            console.warn(`Paymaster policy rejected this transaction with reason: ${res.result.reason} (policyId: ${res.result.policyId})`);\n        }\n        return {\n            paymasterAndData: res.result.paymasterAndData,\n            verificationGasLimit: res.result.verificationGasLimit\n                ? hexToBigInt(res.result.verificationGasLimit)\n                : undefined,\n            preVerificationGas: res.result.preVerificationGas\n                ? hexToBigInt(res.result.preVerificationGas)\n                : undefined,\n            callGasLimit: res.result.callGasLimit\n                ? hexToBigInt(res.result.callGasLimit)\n                : undefined,\n            paymaster: res.result.paymaster,\n            paymasterData: res.result.paymasterData,\n            paymasterVerificationGasLimit: res.result.paymasterVerificationGasLimit\n                ? hexToBigInt(res.result.paymasterVerificationGasLimit)\n                : undefined,\n            paymasterPostOpGasLimit: res.result.paymasterPostOpGasLimit\n                ? hexToBigInt(res.result.paymasterPostOpGasLimit)\n                : undefined,\n        };\n    }\n    const error = res.error?.message || res.error || response.statusText || \"unknown error\";\n    throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n//# sourceMappingURL=paymaster.js.map","import { maxUint96 } from \"ox/Solidity\";\nimport { concat } from \"viem\";\nimport { getContract, } from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport { estimateUserOpGas, getUserOpGasFees, getUserOpReceipt, } from \"./bundler.js\";\nimport { predictAddress, prepareBatchExecute, prepareCreateAccount, prepareExecute, } from \"./calls.js\";\nimport { DUMMY_SIGNATURE, ENTRYPOINT_ADDRESS_v0_6, ENTRYPOINT_ADDRESS_v0_7, getDefaultAccountFactory, getDefaultBundlerUrl, getEntryPointVersion, } from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\nconst isDeployingSet = new Set();\nconst getKey = (accountContract) => {\n    return `${accountContract.chain.id}:${accountContract.address}`;\n};\nconst markAccountDeploying = (accountContract) => {\n    isDeployingSet.add(getKey(accountContract));\n};\nexport const clearAccountDeploying = (accountContract) => {\n    isDeployingSet.delete(getKey(accountContract));\n};\nconst isAccountDeploying = (accountContract) => {\n    return isDeployingSet.has(getKey(accountContract));\n};\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(args) {\n    const timeout = args.timeoutMs || 120000; // 2mins\n    const interval = args.intervalMs || 1000; // 1s\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n        const userOpReceipt = await getUserOpReceipt(args);\n        if (userOpReceipt) {\n            return userOpReceipt;\n        }\n        await new Promise((resolve) => setTimeout(resolve, interval));\n    }\n    throw new Error(`Timeout waiting for userOp to be mined on chain ${args.chain.id} with UserOp hash: ${args.userOpHash}`);\n}\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args) {\n    const { transaction: executeTx, accountContract, factoryContract, adminAddress, overrides, sponsorGas, waitForDeployment = true, isDeployedOverride, } = args;\n    const chain = executeTx.chain;\n    const client = executeTx.client;\n    const bundlerOptions = {\n        client,\n        chain,\n        bundlerUrl: overrides?.bundlerUrl,\n        entrypointAddress: overrides?.entrypointAddress,\n    };\n    const entrypointVersion = getEntryPointVersion(args.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6);\n    const [isDeployed, callData, callGasLimit, gasFees, nonce] = await Promise.all([\n        typeof isDeployedOverride === \"boolean\"\n            ? isDeployedOverride\n            : isContractDeployed(accountContract).then((isDeployed) => isDeployed || isAccountDeploying(accountContract)),\n        encode(executeTx),\n        resolvePromisedValue(executeTx.gas),\n        getGasFees({\n            executeTx,\n            bundlerOptions,\n            chain,\n            client,\n        }),\n        getAccountNonce({\n            accountContract,\n            chain,\n            client,\n            entrypointAddress: overrides?.entrypointAddress,\n            getNonceOverride: overrides?.getAccountNonce,\n        }),\n    ]);\n    const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;\n    if (entrypointVersion === \"v0.7\") {\n        return populateUserOp_v0_7({\n            bundlerOptions,\n            factoryContract,\n            accountContract,\n            adminAddress,\n            sponsorGas,\n            overrides,\n            isDeployed,\n            nonce,\n            callData,\n            callGasLimit,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            waitForDeployment,\n        });\n    }\n    // default to v0.6\n    return populateUserOp_v0_6({\n        bundlerOptions,\n        factoryContract,\n        accountContract,\n        adminAddress,\n        sponsorGas,\n        overrides,\n        isDeployed,\n        nonce,\n        callData,\n        callGasLimit,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        waitForDeployment,\n    });\n}\nasync function getGasFees(args) {\n    const { executeTx, bundlerOptions, chain, client } = args;\n    let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n    const bundlerUrl = bundlerOptions?.bundlerUrl ?? getDefaultBundlerUrl(chain);\n    if (isThirdwebUrl(bundlerUrl)) {\n        // get gas prices from bundler\n        const bundlerGasPrice = await getUserOpGasFees({\n            options: bundlerOptions,\n        });\n        maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n        maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n    }\n    else {\n        // Check for explicity values\n        const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] = await Promise.all([\n            resolvePromisedValue(maxFeePerGas),\n            resolvePromisedValue(maxPriorityFeePerGas),\n        ]);\n        if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n            // Save a network call if the values are provided\n            maxFeePerGas = resolvedMaxFeePerGas;\n            maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n        }\n        else {\n            // Fallback to RPC gas prices if no explicit values provided\n            const feeData = await getDefaultGasOverrides(client, chain);\n            // Still check for explicit values in case one is provided and not the other\n            maxPriorityFeePerGas =\n                resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n            maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n        }\n    }\n    return { maxFeePerGas, maxPriorityFeePerGas };\n}\nasync function populateUserOp_v0_7(args) {\n    const { bundlerOptions, isDeployed, factoryContract, accountContract, adminAddress, sponsorGas, overrides, nonce, callData, callGasLimit, maxFeePerGas, maxPriorityFeePerGas, waitForDeployment, } = args;\n    const { chain, client } = bundlerOptions;\n    let factory;\n    let factoryData;\n    if (isDeployed) {\n        factoryData = \"0x\";\n        if (waitForDeployment) {\n            // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n            await waitForAccountDeployed(accountContract);\n        }\n    }\n    else {\n        factory = factoryContract.address;\n        factoryData = await encode(prepareCreateAccount({\n            factoryContract: factoryContract,\n            adminAddress,\n            accountSalt: overrides?.accountSalt,\n            createAccountOverride: overrides?.createAccount,\n        }));\n        if (waitForDeployment) {\n            markAccountDeploying(accountContract);\n        }\n    }\n    const partialOp = {\n        sender: accountContract.address,\n        nonce,\n        callData,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        callGasLimit: callGasLimit ?? 0n,\n        verificationGasLimit: 0n,\n        preVerificationGas: 0n,\n        factory,\n        factoryData,\n        paymaster: undefined,\n        paymasterData: \"0x\",\n        paymasterVerificationGasLimit: 0n,\n        paymasterPostOpGasLimit: 0n,\n        signature: DUMMY_SIGNATURE,\n    };\n    if (sponsorGas) {\n        const paymasterResult = (await getPaymasterAndData({\n            userOp: partialOp,\n            chain,\n            client,\n            entrypointAddress: overrides?.entrypointAddress,\n            paymasterOverride: overrides?.paymaster,\n        }));\n        if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n            partialOp.paymaster = paymasterResult.paymaster;\n            partialOp.paymasterData = paymasterResult.paymasterData;\n        }\n        // paymaster can have the gas limits in the response\n        if (paymasterResult.callGasLimit &&\n            paymasterResult.verificationGasLimit &&\n            paymasterResult.preVerificationGas &&\n            paymasterResult.paymasterPostOpGasLimit &&\n            paymasterResult.paymasterVerificationGasLimit) {\n            partialOp.callGasLimit = paymasterResult.callGasLimit;\n            partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n            partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n            partialOp.paymasterPostOpGasLimit =\n                paymasterResult.paymasterPostOpGasLimit;\n            partialOp.paymasterVerificationGasLimit =\n                paymasterResult.paymasterVerificationGasLimit;\n        }\n        else {\n            // otherwise fallback to bundler for gas limits\n            const stateOverrides = overrides?.tokenPaymaster\n                ? {\n                    [overrides.tokenPaymaster.tokenAddress]: {\n                        stateDiff: {\n                            [keccak256(encodeAbiParameters([{ type: \"address\" }, { type: \"uint256\" }], [\n                                accountContract.address,\n                                overrides.tokenPaymaster.balanceStorageSlot,\n                            ]))]: toHex(maxUint96, { size: 32 }),\n                        },\n                    },\n                }\n                : undefined;\n            const estimates = await estimateUserOpGas({\n                userOp: partialOp,\n                options: bundlerOptions,\n            }, stateOverrides);\n            partialOp.callGasLimit = estimates.callGasLimit;\n            partialOp.verificationGasLimit = estimates.verificationGasLimit;\n            partialOp.preVerificationGas = estimates.preVerificationGas;\n            partialOp.paymasterPostOpGasLimit = overrides?.tokenPaymaster\n                ? 500000n // TODO: estimate this better, needed if there's an extra swap needed in the paymaster\n                : estimates.paymasterPostOpGasLimit || 0n;\n            partialOp.paymasterVerificationGasLimit =\n                estimates.paymasterVerificationGasLimit || 0n;\n            // need paymaster to re-sign after estimates\n            const paymasterResult2 = (await getPaymasterAndData({\n                userOp: partialOp,\n                chain,\n                client,\n                entrypointAddress: overrides?.entrypointAddress,\n                paymasterOverride: overrides?.paymaster,\n            }));\n            if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n                partialOp.paymaster = paymasterResult2.paymaster;\n                partialOp.paymasterData = paymasterResult2.paymasterData;\n            }\n        }\n    }\n    else {\n        // not gasless, so we just need to estimate gas limits\n        const estimates = await estimateUserOpGas({\n            userOp: partialOp,\n            options: bundlerOptions,\n        });\n        partialOp.callGasLimit = estimates.callGasLimit;\n        partialOp.verificationGasLimit = estimates.verificationGasLimit;\n        partialOp.preVerificationGas = estimates.preVerificationGas;\n        partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n        partialOp.paymasterVerificationGasLimit =\n            estimates.paymasterVerificationGasLimit || 0n;\n    }\n    return {\n        ...partialOp,\n        signature: \"0x\",\n    };\n}\nasync function populateUserOp_v0_6(args) {\n    const { bundlerOptions, isDeployed, factoryContract, accountContract, adminAddress, sponsorGas, overrides, nonce, callData, callGasLimit, maxFeePerGas, maxPriorityFeePerGas, waitForDeployment, } = args;\n    const { chain, client } = bundlerOptions;\n    let initCode;\n    if (isDeployed) {\n        initCode = \"0x\";\n        if (waitForDeployment) {\n            // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n            await waitForAccountDeployed(accountContract);\n        }\n    }\n    else {\n        initCode = await getAccountInitCode({\n            factoryContract: factoryContract,\n            adminAddress,\n            accountSalt: overrides?.accountSalt,\n            createAccountOverride: overrides?.createAccount,\n        });\n        if (waitForDeployment) {\n            markAccountDeploying(accountContract);\n        }\n    }\n    const partialOp = {\n        sender: accountContract.address,\n        nonce,\n        initCode,\n        callData,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        callGasLimit: callGasLimit ?? 0n,\n        verificationGasLimit: 0n,\n        preVerificationGas: 0n,\n        paymasterAndData: \"0x\",\n        signature: DUMMY_SIGNATURE,\n    };\n    if (sponsorGas) {\n        const paymasterResult = await getPaymasterAndData({\n            userOp: partialOp,\n            chain,\n            client,\n            entrypointAddress: overrides?.entrypointAddress,\n            paymasterOverride: overrides?.paymaster,\n        });\n        const paymasterAndData = \"paymasterAndData\" in paymasterResult\n            ? paymasterResult.paymasterAndData\n            : \"0x\";\n        if (paymasterAndData && paymasterAndData !== \"0x\") {\n            partialOp.paymasterAndData = paymasterAndData;\n        }\n        // paymaster can have the gas limits in the response\n        if (paymasterResult.callGasLimit &&\n            paymasterResult.verificationGasLimit &&\n            paymasterResult.preVerificationGas) {\n            partialOp.callGasLimit = paymasterResult.callGasLimit;\n            partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n            partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n        }\n        else {\n            // otherwise fallback to bundler for gas limits\n            const estimates = await estimateUserOpGas({\n                userOp: partialOp,\n                options: bundlerOptions,\n            });\n            partialOp.callGasLimit = estimates.callGasLimit;\n            partialOp.verificationGasLimit = estimates.verificationGasLimit;\n            partialOp.preVerificationGas = estimates.preVerificationGas;\n            // need paymaster to re-sign after estimates\n            if (paymasterAndData && paymasterAndData !== \"0x\") {\n                const paymasterResult2 = await getPaymasterAndData({\n                    userOp: partialOp,\n                    chain,\n                    client,\n                    entrypointAddress: overrides?.entrypointAddress,\n                    paymasterOverride: overrides?.paymaster,\n                });\n                const paymasterAndData2 = \"paymasterAndData\" in paymasterResult2\n                    ? paymasterResult2.paymasterAndData\n                    : \"0x\";\n                if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n                    partialOp.paymasterAndData = paymasterAndData2;\n                }\n            }\n        }\n    }\n    else {\n        // not gasless, so we just need to estimate gas limits\n        const estimates = await estimateUserOpGas({\n            userOp: partialOp,\n            options: bundlerOptions,\n        });\n        partialOp.callGasLimit = estimates.callGasLimit;\n        partialOp.verificationGasLimit = estimates.verificationGasLimit;\n        partialOp.preVerificationGas = estimates.preVerificationGas;\n    }\n    return {\n        ...partialOp,\n        signature: \"0x\",\n    };\n}\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args) {\n    const { userOp, chain, entrypointAddress, adminAccount } = args;\n    const userOpHash = await getUserOpHash({\n        client: args.client,\n        userOp,\n        chain,\n        entrypointAddress,\n    });\n    if (adminAccount.signMessage) {\n        const signature = await adminAccount.signMessage({\n            message: {\n                raw: hexToBytes(userOpHash),\n            },\n            originalMessage: stringify(userOp),\n            chainId: chain.id,\n        });\n        return {\n            ...userOp,\n            signature,\n        };\n    }\n    throw new Error(\"signMessage not implemented in signingAccount\");\n}\n/**\n * Get the hash of a user operation.\n * @param args - The options for getting the user operation hash\n * @returns - The user operation hash\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n * const userOpHash = await getUserOpHash({\n *  client,\n *  userOp,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpHash(args) {\n    const { userOp, chain, entrypointAddress } = args;\n    const entrypointVersion = getEntryPointVersion(entrypointAddress || ENTRYPOINT_ADDRESS_v0_6);\n    let userOpHash;\n    if (entrypointVersion === \"v0.7\") {\n        const packedUserOp = getPackedUserOperation(userOp);\n        userOpHash = await getUserOpHashV07({\n            contract: getContract({\n                address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n                chain,\n                client: args.client,\n            }),\n            userOp: packedUserOp,\n        });\n    }\n    else {\n        userOpHash = await getUserOpHashV06({\n            contract: getContract({\n                address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n                chain,\n                client: args.client,\n            }),\n            userOp: userOp,\n        });\n    }\n    return userOpHash;\n}\nasync function getAccountInitCode(options) {\n    const { factoryContract, adminAddress, accountSalt, createAccountOverride } = options;\n    const deployTx = prepareCreateAccount({\n        factoryContract,\n        adminAddress,\n        accountSalt,\n        createAccountOverride,\n    });\n    return concat([factoryContract.address, await encode(deployTx)]);\n}\nasync function getAccountNonce(options) {\n    const { accountContract, chain, client, entrypointAddress, getNonceOverride, } = options;\n    if (getNonceOverride) {\n        return getNonceOverride(accountContract);\n    }\n    return await getNonce({\n        contract: getContract({\n            address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n            chain,\n            client,\n        }),\n        key: generateRandomUint192(),\n        sender: accountContract.address,\n    });\n}\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options) {\n    const unsignedUserOp = await prepareUserOp({\n        transactions: options.transactions,\n        adminAccount: options.adminAccount,\n        client: options.client,\n        smartWalletOptions: options.smartWalletOptions,\n        waitForDeployment: options.waitForDeployment,\n        isDeployedOverride: options.isDeployedOverride,\n    });\n    const signedUserOp = await signUserOp({\n        client: options.client,\n        chain: options.smartWalletOptions.chain,\n        adminAccount: options.adminAccount,\n        entrypointAddress: options.smartWalletOptions.overrides?.entrypointAddress,\n        userOp: unsignedUserOp,\n    });\n    return signedUserOp;\n}\nexport async function prepareUserOp(options) {\n    const config = options.smartWalletOptions;\n    const factoryContract = getContract({\n        address: config.factoryAddress ||\n            getDefaultAccountFactory(config.overrides?.entrypointAddress),\n        chain: config.chain,\n        client: options.client,\n    });\n    const accountAddress = await predictAddress({\n        factoryContract,\n        adminAddress: options.adminAccount.address,\n        predictAddressOverride: config.overrides?.predictAddress,\n        accountSalt: config.overrides?.accountSalt,\n        accountAddress: config.overrides?.accountAddress,\n    });\n    const accountContract = getContract({\n        address: accountAddress,\n        chain: config.chain,\n        client: options.client,\n    });\n    let executeTx;\n    if (options.transactions.length === 1) {\n        const tx = options.transactions[0];\n        // for single tx, simulate fully\n        const serializedTx = await toSerializableTransaction({\n            transaction: tx,\n            from: accountAddress,\n        });\n        executeTx = prepareExecute({\n            accountContract,\n            transaction: serializedTx,\n            executeOverride: config.overrides?.execute,\n        });\n    }\n    else {\n        // for multiple txs, we can't simulate, just encode\n        const serializedTxs = await Promise.all(options.transactions.map(async (tx) => {\n            const [data, to, value] = await Promise.all([\n                encode(tx),\n                resolvePromisedValue(tx.to),\n                resolvePromisedValue(tx.value),\n            ]);\n            return {\n                data,\n                to,\n                value,\n                chainId: tx.chain.id,\n            };\n        }));\n        executeTx = prepareBatchExecute({\n            accountContract,\n            transactions: serializedTxs,\n            executeBatchOverride: config.overrides?.executeBatch,\n        });\n    }\n    return createUnsignedUserOp({\n        transaction: executeTx,\n        factoryContract,\n        accountContract,\n        adminAddress: options.adminAccount.address,\n        sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n        overrides: config.overrides,\n        waitForDeployment: options.waitForDeployment,\n        isDeployedOverride: options.isDeployedOverride,\n    });\n}\nasync function waitForAccountDeployed(accountContract) {\n    const startTime = Date.now();\n    while (isAccountDeploying(accountContract)) {\n        if (Date.now() - startTime > 60000) {\n            clearAccountDeploying(accountContract); // clear the flag so it doesnt stay stuck in this state\n            throw new Error(\"Account deployment is taking too long (over 1 minute). Please try again.\");\n        }\n        await new Promise((resolve) => setTimeout(resolve, 500));\n    }\n}\n//# sourceMappingURL=userop.js.map","import { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { addSessionKey, shouldUpdateSessionKey, } from \"../../extensions/erc4337/account/addSessionKey.js\";\nimport { sendTransaction } from \"../../transaction/actions/send-transaction.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport { populateEip712Transaction, signEip712Transaction, } from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { maxUint96 } from \"../../utils/types.js\";\nimport { broadcastZkTransaction, bundleUserOp, getZkPaymasterData, } from \"./lib/bundler.js\";\nimport { predictAddress, prepareBatchExecute, prepareExecute, } from \"./lib/calls.js\";\nimport { ENTRYPOINT_ADDRESS_v0_6, ENTRYPOINT_ADDRESS_v0_7, getDefaultAccountFactory, getEntryPointVersion, } from \"./lib/constants.js\";\nimport { clearAccountDeploying, createUnsignedUserOp, signUserOp, waitForUserOpReceipt, } from \"./lib/userop.js\";\nexport { isSmartWallet } from \"./is-smart-wallet.js\";\n/**\n * For in-app wallets, the smart wallet creation is implicit so we track these to be able to retrieve the personal account for a smart account on the wallet API.\n * Note: We have to go account to account here and NOT wallet to account because the smart wallet itself is never exposed to the in-app wallet, only the account.\n * @internal\n */\nconst adminAccountToSmartAccountMap = new WeakMap();\nconst smartAccountToAdminAccountMap = new WeakMap();\n/**\n * @internal\n */\nexport async function connectSmartAccount(connectionOptions, creationOptions) {\n    const { personalAccount, client, chain: connectChain } = connectionOptions;\n    if (!personalAccount) {\n        throw new Error(\"No personal account provided for smart account connection\");\n    }\n    const options = creationOptions;\n    const chain = connectChain ?? options.chain;\n    const sponsorGas = \"gasless\" in options ? options.gasless : options.sponsorGas;\n    if (await isZkSyncChain(chain)) {\n        return [\n            createZkSyncAccount({\n                creationOptions,\n                connectionOptions,\n                chain,\n                sponsorGas,\n            }),\n            chain,\n        ];\n    }\n    // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n    if (options.factoryAddress && !options.overrides?.entrypointAddress) {\n        const entrypointAddress = await getEntrypointFromFactory(options.factoryAddress, client, chain);\n        if (entrypointAddress) {\n            options.overrides = {\n                ...options.overrides,\n                entrypointAddress,\n            };\n        }\n    }\n    if (options.overrides?.tokenPaymaster &&\n        !options.overrides?.entrypointAddress) {\n        // if token paymaster is set, but no entrypoint address, set the entrypoint address to v0.7\n        options.overrides = {\n            ...options.overrides,\n            entrypointAddress: ENTRYPOINT_ADDRESS_v0_7,\n        };\n    }\n    const factoryAddress = options.factoryAddress ??\n        getDefaultAccountFactory(options.overrides?.entrypointAddress);\n    const factoryContract = getContract({\n        client: client,\n        address: factoryAddress,\n        chain: chain,\n    });\n    const accountAddress = await predictAddress({\n        factoryContract,\n        adminAddress: personalAccount.address,\n        predictAddressOverride: options.overrides?.predictAddress,\n        accountSalt: options.overrides?.accountSalt,\n        accountAddress: options.overrides?.accountAddress,\n    })\n        .then((address) => address)\n        .catch((err) => {\n        throw new Error(`Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}: ${err?.message || \"unknown error\"}`, { cause: err });\n    });\n    const accountContract = getContract({\n        client,\n        address: accountAddress,\n        chain,\n    });\n    const account = await createSmartAccount({\n        ...options,\n        chain,\n        sponsorGas,\n        personalAccount,\n        accountContract,\n        factoryContract,\n        client,\n    });\n    adminAccountToSmartAccountMap.set(personalAccount, account);\n    smartAccountToAdminAccountMap.set(account, personalAccount);\n    if (options.sessionKey) {\n        if (await shouldUpdateSessionKey({\n            accountContract,\n            sessionKeyAddress: options.sessionKey.address,\n            newPermissions: options.sessionKey.permissions,\n        })) {\n            const transaction = addSessionKey({\n                account: personalAccount,\n                contract: accountContract,\n                permissions: options.sessionKey.permissions,\n                sessionKeyAddress: options.sessionKey.address,\n            });\n            await sendTransaction({\n                account: account,\n                transaction,\n            });\n        }\n    }\n    return [account, chain];\n}\n/**\n * @internal\n */\nexport async function disconnectSmartAccount(account) {\n    // look up the personalAccount for the smart wallet\n    const personalAccount = smartAccountToAdminAccountMap.get(account);\n    if (personalAccount) {\n        // remove the mappings\n        adminAccountToSmartAccountMap.delete(personalAccount);\n        smartAccountToAdminAccountMap.delete(account);\n    }\n}\nasync function createSmartAccount(options) {\n    const erc20Paymaster = options.overrides?.tokenPaymaster;\n    if (erc20Paymaster) {\n        if (getEntryPointVersion(options.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6) !== \"v0.7\") {\n            throw new Error(\"Token paymaster is only supported for entrypoint version v0.7\");\n        }\n    }\n    let accountContract = options.accountContract;\n    const account = {\n        address: getAddress(accountContract.address),\n        async sendTransaction(transaction) {\n            // if erc20 paymaster - check allowance and approve if needed\n            let paymasterOverride = undefined;\n            if (erc20Paymaster) {\n                await approveERC20({\n                    accountContract,\n                    erc20Paymaster,\n                    options,\n                });\n                const paymasterCallback = async () => {\n                    return {\n                        paymaster: erc20Paymaster.paymasterAddress,\n                        paymasterData: \"0x\",\n                    };\n                };\n                paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n            }\n            else {\n                paymasterOverride = options.overrides?.paymaster;\n            }\n            // If this transaction is for a different chain than the initial one, get the account contract for that chain\n            if (transaction.chainId !== accountContract.chain.id) {\n                accountContract = getContract({\n                    address: account.address,\n                    chain: getCachedChain(transaction.chainId),\n                    client: options.client,\n                });\n            }\n            const executeTx = prepareExecute({\n                accountContract: accountContract,\n                transaction,\n                executeOverride: options.overrides?.execute,\n            });\n            const chain = getCachedChain(transaction.chainId);\n            const result = await _sendUserOp({\n                executeTx,\n                options: {\n                    ...options,\n                    chain,\n                    accountContract,\n                    overrides: {\n                        ...options.overrides,\n                        paymaster: paymasterOverride,\n                    },\n                },\n            });\n            trackTransaction({\n                client: options.client,\n                chainId: chain.id,\n                transactionHash: result.transactionHash,\n                walletAddress: options.accountContract.address,\n                walletType: \"smart\",\n                contractAddress: transaction.to ?? undefined,\n            });\n            return result;\n        },\n        async sendBatchTransaction(transactions) {\n            const executeTx = prepareBatchExecute({\n                accountContract,\n                transactions,\n                executeBatchOverride: options.overrides?.executeBatch,\n            });\n            if (transactions.length === 0) {\n                throw new Error(\"No transactions to send\");\n            }\n            const firstTx = transactions[0];\n            if (!firstTx) {\n                throw new Error(\"No transactions to send\");\n            }\n            const chain = getCachedChain(firstTx.chainId);\n            const result = await _sendUserOp({\n                executeTx,\n                options: {\n                    ...options,\n                    chain,\n                    accountContract,\n                },\n            });\n            trackTransaction({\n                client: options.client,\n                chainId: chain.id,\n                transactionHash: result.transactionHash,\n                walletAddress: options.accountContract.address,\n                walletType: \"smart\",\n                contractAddress: transactions[0]?.to ?? undefined,\n            });\n            return result;\n        },\n        async signMessage({ message }) {\n            if (options.overrides?.signMessage) {\n                return options.overrides.signMessage({\n                    adminAccount: options.personalAccount,\n                    factoryContract: options.factoryContract,\n                    accountContract,\n                    message,\n                });\n            }\n            const { smartAccountSignMessage } = await import(\"./lib/signing.js\");\n            return smartAccountSignMessage({\n                accountContract,\n                factoryContract: options.factoryContract,\n                options,\n                message,\n            });\n        },\n        async signTypedData(typedData) {\n            if (options.overrides?.signTypedData) {\n                return options.overrides.signTypedData({\n                    adminAccount: options.personalAccount,\n                    factoryContract: options.factoryContract,\n                    accountContract,\n                    typedData,\n                });\n            }\n            const { smartAccountSignTypedData } = await import(\"./lib/signing.js\");\n            return smartAccountSignTypedData({\n                accountContract,\n                factoryContract: options.factoryContract,\n                options,\n                typedData,\n            });\n        },\n        async onTransactionRequested(transaction) {\n            return options.personalAccount.onTransactionRequested?.(transaction);\n        },\n    };\n    return account;\n}\nasync function approveERC20(args) {\n    const { accountContract, erc20Paymaster, options } = args;\n    const tokenAddress = erc20Paymaster.tokenAddress;\n    const tokenContract = getContract({\n        address: tokenAddress,\n        chain: accountContract.chain,\n        client: accountContract.client,\n    });\n    const accountAllowance = await allowance({\n        contract: tokenContract,\n        owner: accountContract.address,\n        spender: erc20Paymaster.paymasterAddress,\n    });\n    if (accountAllowance > 0n) {\n        return;\n    }\n    const approveTx = approve({\n        contract: tokenContract,\n        spender: erc20Paymaster.paymasterAddress,\n        amountWei: maxUint96 - 1n,\n    });\n    const transaction = await toSerializableTransaction({\n        transaction: approveTx,\n        from: accountContract.address,\n    });\n    const executeTx = prepareExecute({\n        accountContract,\n        transaction,\n        executeOverride: options.overrides?.execute,\n    });\n    await _sendUserOp({\n        executeTx,\n        options: {\n            ...options,\n            overrides: {\n                ...options.overrides,\n                tokenPaymaster: undefined,\n            },\n        },\n    });\n}\nfunction createZkSyncAccount(args) {\n    const { creationOptions, connectionOptions, chain } = args;\n    const account = {\n        address: connectionOptions.personalAccount.address,\n        async sendTransaction(transaction) {\n            // override passed tx, we have to refetch gas and fees always\n            const prepTx = {\n                data: transaction.data,\n                to: transaction.to ?? undefined,\n                value: transaction.value ?? 0n,\n                chain: getCachedChain(transaction.chainId),\n                client: connectionOptions.client,\n                eip712: transaction.eip712,\n            };\n            let serializableTransaction = await populateEip712Transaction({\n                account,\n                transaction: prepTx,\n            });\n            if (args.sponsorGas && !serializableTransaction.paymaster) {\n                // get paymaster input\n                const pmData = await getZkPaymasterData({\n                    options: {\n                        client: connectionOptions.client,\n                        chain,\n                        bundlerUrl: creationOptions.overrides?.bundlerUrl,\n                        entrypointAddress: creationOptions.overrides?.entrypointAddress,\n                    },\n                    transaction: serializableTransaction,\n                });\n                serializableTransaction = {\n                    ...serializableTransaction,\n                    ...pmData,\n                };\n            }\n            // sign\n            const signedTransaction = await signEip712Transaction({\n                account,\n                chainId: chain.id,\n                eip712Transaction: serializableTransaction,\n            });\n            // broadcast via bundler\n            const txHash = await broadcastZkTransaction({\n                options: {\n                    client: connectionOptions.client,\n                    chain,\n                    bundlerUrl: creationOptions.overrides?.bundlerUrl,\n                    entrypointAddress: creationOptions.overrides?.entrypointAddress,\n                },\n                transaction: serializableTransaction,\n                signedTransaction,\n            });\n            trackTransaction({\n                client: connectionOptions.client,\n                chainId: chain.id,\n                transactionHash: txHash.transactionHash,\n                walletAddress: account.address,\n                walletType: \"smart\",\n                contractAddress: transaction.to ?? undefined,\n            });\n            return {\n                transactionHash: txHash.transactionHash,\n                client: connectionOptions.client,\n                chain: chain,\n            };\n        },\n        async signMessage({ message }) {\n            return connectionOptions.personalAccount.signMessage({ message });\n        },\n        async signTypedData(_typedData) {\n            const typedData = parseTypedData(_typedData);\n            return connectionOptions.personalAccount.signTypedData(typedData);\n        },\n        async onTransactionRequested(transaction) {\n            return connectionOptions.personalAccount.onTransactionRequested?.(transaction);\n        },\n    };\n    return account;\n}\nasync function _sendUserOp(args) {\n    const { executeTx, options } = args;\n    try {\n        const unsignedUserOp = await createUnsignedUserOp({\n            transaction: executeTx,\n            factoryContract: options.factoryContract,\n            accountContract: options.accountContract,\n            adminAddress: options.personalAccount.address,\n            sponsorGas: options.sponsorGas,\n            overrides: options.overrides,\n        });\n        const signedUserOp = await signUserOp({\n            client: options.client,\n            chain: options.chain,\n            adminAccount: options.personalAccount,\n            entrypointAddress: options.overrides?.entrypointAddress,\n            userOp: unsignedUserOp,\n        });\n        const bundlerOptions = {\n            chain: options.chain,\n            client: options.client,\n            bundlerUrl: options.overrides?.bundlerUrl,\n            entrypointAddress: options.overrides?.entrypointAddress,\n        };\n        const userOpHash = await bundleUserOp({\n            options: bundlerOptions,\n            userOp: signedUserOp,\n        });\n        // wait for tx receipt rather than return the userOp hash\n        const receipt = await waitForUserOpReceipt({\n            ...bundlerOptions,\n            userOpHash,\n        });\n        trackTransaction({\n            client: options.client,\n            chainId: options.chain.id,\n            transactionHash: receipt.transactionHash,\n            walletAddress: options.accountContract.address,\n            walletType: \"smart\",\n            contractAddress: await resolvePromisedValue(executeTx.to ?? undefined),\n        });\n        return {\n            client: options.client,\n            chain: options.chain,\n            transactionHash: receipt.transactionHash,\n        };\n    }\n    finally {\n        // reset the isDeploying flag after every transaction or error\n        clearAccountDeploying(options.accountContract);\n    }\n}\nexport async function getEntrypointFromFactory(factoryAddress, client, chain) {\n    const factoryContract = getContract({\n        address: factoryAddress,\n        client,\n        chain,\n    });\n    try {\n        const entrypointAddress = await readContract({\n            contract: factoryContract,\n            method: \"function entrypoint() public view returns (address)\",\n        });\n        return entrypointAddress;\n    }\n    catch {\n        return undefined;\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}