{"version":3,"file":"42558.js","mappings":"qhBAOO,0BAA0C,oDAAyD,EAC1G,MAA8B,OAAW,EACzC,kCACA,cACA,gBACK,EACL,QAAwB,kBAAY,EACpC,WACA,2DACA,mBACK,EACL,uBAEA,SACA,4DAEA,UACA,2DAEA,WACA,4DAGA,mCACA,OACA,eACA,QACA,SACA,UACA,QACA,YACA,0BACA,EACA,OACA,uBACA,QACA,uBACA,gBACA,4BACqB,CACrB,UACA,6BACA,OAA6B,iBAA0C,CACtD,EACjB,EACA,CAGA,OACA,eACA,QACA,SACA,UACA,QACA,aAEA,OACA,uBACA,QACA,qCACA,iCACA,mBACA,4BACiB,CACjB,UACA,6BACA,sBAAyB,EAAgB,CAC5B,EACb,EACA,CACA,CAAK,GAGL,eAAa,0BADb,SACa,CACb,CACA,OACA,CAAM,2BAA+B,CACrC,CAAM,yBAA6B,CACnC,CAAM,4BAAgC,CACtC,CAAM,0BAA8B,CACpC,CAAM,4BAAgC,CACtC,CAAM,yBAA6B,CACnC,CACA,GACA,CAAM,2BAA+B,CACrC,CAAM,yBAA6B,CACnC,CAAM,4BAAgC,CACtC,CAAM,0BAA8B,CACpC,CAAM,4BAAgC,CACtC,CAAM,yBAA6B,CACnC,CAAM,8BAAkC,CACxC,CAIO,oBACP,YAAY,6BAAkC,WAC9C,oCACA,cACA,SACA,iCACA,CAAS,CACT,KAAc,OAAS,EACvB,UACA,OACA,YACA,mDACS,CACT,CAAK,EACL,SACA,2CAAuD,eAAsB,GAE7E,qBACA,aACA,yCAAqD,UAAa,GAElE,uBAIA,aAFA,IAGA,oBACA,uBAA6C,YAAkB,EAC/D,KACA,OACA,kCACA,0BACA,4BAGA,mCAXA,KAYA,CACA,wDAAgE,OAChE,CACA,oBACA,IAAY,qBAAmB,EAC/B,6CACA,iBAA+B,EAAI,sBAAsB,EAAQ,GACjE,YACA,CAAK,EACL,iBACA,SACA,YAEA,eACA,MACA,YAEA,iBACA,cACA,gDAAgE,eAAoB,EACpF,iBACA,+CACA,aAMA,OALA,MAAkC,OAAc,EAChD,4BACA,0BACA,kCACa,CAGb,SACA,WAEA,CACA","sources":["webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/transaction/actions/gasless/providers/engine.js"],"sourcesContent":["import { getContract } from \"../../../../contract/contract.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport { waitForReceipt, } from \"../../wait-for-tx-receipt.js\";\n/**\n * @internal - only exported for testing\n */\nexport async function prepareEngineTransaction({ account, serializableTransaction, transaction, gasless, }) {\n    const forrwaderContract = getContract({\n        address: gasless.relayerForwarderAddress,\n        chain: transaction.chain,\n        client: transaction.client,\n    });\n    const nonce = await readContract({\n        contract: forrwaderContract,\n        method: \"function getNonce(address) view returns (uint256)\",\n        params: [account.address],\n    });\n    const [signature, message] = await (async () => {\n        // TODO: handle special case for `approve` -> `permit` transactions\n        if (!serializableTransaction.to) {\n            throw new Error(\"engine transactions must have a 'to' address\");\n        }\n        if (!serializableTransaction.gas) {\n            throw new Error(\"engine transactions must have a 'gas' value\");\n        }\n        if (!serializableTransaction.data) {\n            throw new Error(\"engine transactions must have a 'data' value\");\n        }\n        // chainless support!\n        if (gasless.experimentalChainlessSupport) {\n            const message = {\n                from: account.address,\n                to: serializableTransaction.to,\n                value: 0n,\n                gas: serializableTransaction.gas,\n                nonce: nonce,\n                data: serializableTransaction.data,\n                chainid: BigInt(transaction.chain.id),\n            };\n            return [\n                await account.signTypedData({\n                    domain: {\n                        name: \"GSNv2 Forwarder\",\n                        version: \"0.0.1\",\n                        verifyingContract: forrwaderContract.address,\n                    },\n                    message,\n                    primaryType: \"ForwardRequest\",\n                    types: { ForwardRequest: ChainAwareForwardRequest },\n                }),\n                message,\n            ];\n        }\n        // else non-chainless support\n        const message = {\n            from: account.address,\n            to: serializableTransaction.to,\n            value: 0n,\n            gas: serializableTransaction.gas,\n            nonce: nonce,\n            data: serializableTransaction.data,\n        };\n        return [\n            await account.signTypedData({\n                domain: {\n                    name: gasless.domainName ?? \"GSNv2 Forwarder\",\n                    version: gasless.domainVersion ?? \"0.0.1\",\n                    chainId: transaction.chain.id,\n                    verifyingContract: forrwaderContract.address,\n                },\n                message,\n                primaryType: \"ForwardRequest\",\n                types: { ForwardRequest },\n            }),\n            message,\n        ];\n    })();\n    // TODO: handle special case for `approve` -> `permit`\n    const messageType = \"forward\";\n    return { message, signature, messageType };\n}\nconst ForwardRequest = [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"gas\", type: \"uint256\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"data\", type: \"bytes\" },\n];\nconst ChainAwareForwardRequest = [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"gas\", type: \"uint256\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"data\", type: \"bytes\" },\n    { name: \"chainid\", type: \"uint256\" },\n];\n/**\n * @internal\n */\nexport async function relayEngineTransaction(options) {\n    const { message, messageType, signature } = await prepareEngineTransaction(options);\n    const response = await fetch(options.gasless.relayerUrl, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: stringify({\n            request: message,\n            type: messageType,\n            signature,\n            forwarderAddress: options.gasless.relayerForwarderAddress,\n        }),\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to send transaction: ${await response.text()}`);\n    }\n    const json = await response.json();\n    if (!json.result) {\n        throw new Error(`Relay transaction failed: ${json.message}`);\n    }\n    const queueId = json.result.queueId;\n    // poll for transactionHash\n    const timeout = 60000;\n    const interval = 1000;\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n        const receipt = await fetchReceipt({ options, queueId });\n        if (receipt) {\n            return {\n                transactionHash: receipt.transactionHash,\n                chain: options.transaction.chain,\n                client: options.transaction.client,\n            };\n        }\n        await new Promise((resolve) => setTimeout(resolve, interval));\n    }\n    throw new Error(`Failed to find relayed transaction after ${timeout}ms`);\n}\nasync function fetchReceipt(args) {\n    const { options, queueId } = args;\n    const url = options.gasless.relayerUrl.split(\"/relayer/\")[0];\n    const res = await fetch(`${url}/transaction/status/${queueId}`, {\n        method: \"GET\",\n    });\n    const resJson = await res.json();\n    if (!res.ok) {\n        return null;\n    }\n    const result = resJson.result;\n    if (!result) {\n        return null;\n    }\n    switch (result.status) {\n        case \"errored\":\n            throw new Error(`Transaction errored with reason: ${result.errorMessage}`);\n        case \"cancelled\":\n            throw new Error(\"Transaction execution cancelled.\");\n        case \"mined\": {\n            const receipt = await waitForReceipt({\n                client: options.transaction.client,\n                chain: options.transaction.chain,\n                transactionHash: result.transactionHash,\n            });\n            return receipt;\n        }\n        default: {\n            return null;\n        }\n    }\n}\n//# sourceMappingURL=engine.js.map"],"names":[],"sourceRoot":""}