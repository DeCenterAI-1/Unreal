{"version":3,"file":"14573.js","mappings":"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B,wBAA2B,EAAM,SAAI,CAAC,IAAM,EAAI,+EA3CjE,WACA,QAGA,GACA,eACA,YACA,CAAS,CACT,EAmCiE,8BAAiM,UAAK,CAAC,UAAS,EAAI,gCAAkC,SAAI,CAAC,IAAO,EAAI,6BAAiC,GAAI,aAAmB,GAAK,CACpY,0NGxDO,eACP,MAA6B,QAAmB,GAChD,WAgfA,GACA,SAAsC,QAAa,KAAO,QAAiB,IAC3E,EAAmC,QAAa,YAChD,iCACA,yCACA,sDACA,qBACA,EAvfA,CACA,sBACA,kBACA,CAAK,EACL,WA+DA,OFtFO,EEuFP,MFrFA,CATO,WE8FiB,CF7FxB,aE6FsC,EF7FtC,WACA,4BACA,EAAsB,QAAU,2BACxB,QAAU,mCAClB,aACA,EACO,EEuF+B,SFpFtC,CACA,CACA,aACA,gBACA,8BACa,CACb,CAEA,eACA,CACA,CACA,aACA,0BACA,4BACa,CACb,CACA,cACA,2BACA,6BACa,CACb,CACA,gBACA,gBACA,8BACa,CACb,CAEA,CACA,CACA,aACA,0BACA,4BACS,CACT,CACA,cACA,gBACA,6BACA,CAAS,CACT,CE+CA,MAAoD,cAAQ,IAC5D,MAAwC,cAAQ,GAChD,MAA0C,cAAQ,OAElD,CAAY,YA4KZ,YACA,MAAwB,QAAc,GACtC,EAAwB,QAAoB,EAC5C,oBACA,gBACA,cACA,yBACS,CACJ,EACL,mBACA,uBACA,iCACA,4BACA,2BACA,cACA,KACA,4BACA,mBACA,KACA,+BACA,qBACA,WACA,KACA,uBACA,mCACA,YACA,KACA,SACA,kBAEA,CACA,MAA6B,YAAM,KAC/B,eAAS,OACb,wBAGA,QACA,0CACA,aACA,oBAEA,CAAK,yBAED,eAAS,MACb,mBAGA,wCACA,IACA,wCACA,sBAEA,CACA,SACA,iDACA,CAEA,CAAK,qBAEL,MAA+B,YAAM,KAOrC,MANI,eAAS,MACb,6BACA,aACY,OAAuB,IAEnC,CAAK,QACL,CAAa,WACb,EA/OyC,CACzC,0BACA,gBACA,cACA,aAEA,eAIA,SAEA,CAAS,CACT,cACA,CAAK,EAEL,SACA,OAEA,EA4QA,YACA,MAAwB,QAAc,GACtC,MAAW,QAAW,EACtB,yBAmFA,EAlFA,cAAoB,sBAA6B,EACjD,iBAEA,8BACA,oBAAyC,QAAc,aAEvD,qBACA,MACA,2CAGA,YAAgC,QAAqB,EACrD,sBACA,gCACA,WACA,oBACA,8BACA,sBACA,oBACA,gBACa,EACb,yBACA,EAAkC,OAAW,EAC7C,gBACA,6CACA,MAAuB,QAAc,iCACrC,CAAa,EACb,kBACA,MAAuB,SAAS,EAChC,WACA,gBACA,sCACiB,mCACjB,0BACgB,OAAa,EAC7B,6BACA,gBACA,wBACA,6BACA,+CACA,uCACA,2CACA,mCACA,wCACA,yCACiB,EACjB,MAAoC,QAAO,EAC3C,WACA,sCACA,0CACA,CAAiB,EACjB,QAAiC,sBAAe,EAChD,UACA,aACA,CAAiB,CACjB,OAAsB,QAAc,EAAG,0BAA8B,EACrD,OAAa,EAC7B,8BACA,gBACA,wBACA,6BACA,+CACA,uCACA,2CACA,mCACA,wCACA,yCACiB,CACjB,CACY,OAAa,EACzB,8BACA,gBACA,wBACA,6BACA,+CACA,uCACA,2CACA,mCACA,wCACA,yCACa,EACb,2BAGA,yBACA,MAAkC,QAAO,EACzC,WACA,sCACA,0CACA,CAAiB,EACjB,QAAgC,QAAoB,EACpD,UACA,kBACA,CAAiB,CACjB,MAEA,QAAgC,sBAAe,EAC/C,UACA,aACA,CAAiB,EAuBjB,OArBA,MAAkB,QAAc,EAAG,0BAAmC,EAC1D,OAAa,EACzB,+BACA,gBACA,wBACA,6BACA,+CACA,uCACA,2CACA,mCACA,wCACA,yCACa,EAEb,cACgB,QAAY,EAC5B,YACA,yBACA,mBACiB,EAEjB,CACA,kCACA,mBAEA,CAAS,CACT,eACY,OAAuB,GACnC,CAAS,CACJ,CACL,EAnZA,CACA,gBACA,cACA,aACA,CAAK,EAEL,CAAY,YAAuB,SAuNnC,GACA,MAAuB,QAAsB,8BAC7C,CACA,gBACA,kCACA,iBACA,EACA,QACA,YACA,uBACA,gBACA,cACA,KACA,cACA,gBACA,WACA,KACA,eACA,YACA,KACA,SACA,WAKA,CACA,MAA6B,YAAM,KAC/B,eAAS,OACb,wBAGA,+BACA,aACA,oBAEA,CAAK,kBACL,MAAwB,QAAc,GACtC,EAA+B,YAAM,KAOrC,MANI,eAAS,MACb,6BACA,aACY,OAAuB,IAEnC,CAAK,QACL,UAAa,EACb,EArQmC,CACnC,gBACA,wBACA,mBACA,eACA,eAEgB,QAAoB,EACpC,0BACA,gBACiB,qBAIjB,UACA,UAEA,UAEA,CAAS,CACJ,EAEL,gBACA,gBAwBA,OAvBA,MAEA,IAEA,IAEA,cAEA,QAGA,EADA,YACA,UAEA,QACA,SAEA,EACA,EAGA,kBAGA,CACA,QACA,OACA,QACA,CACA,CAAK,EACL,kCACA,qCACA,iCAEA,EAA2B,iBAAW,WACtC,MACA,WACA,MACA,CACA,UAEA,MAA0B,SDzMnB,KAGP,CCsMyC,GDtMzC,sBAFA,GAEA,IACA,qBAFA,GAEA,IACA,sBAA0B,EAAK,SAAS,EAAM,0BAA4B,MAAM,WAAW,IAAe,GAAR,CAAY,OAAS,GAAK,CAC5H,CAD4H,CCoMnF,4BAC7B,OAAa,EACzB,0BACA,gBACA,sCACA,6BACa,EACb,KACY,QAAY,EACxB,YACA,0BACa,CACb,MACA,YAEA,IACA,2BACA,kBACA,gBACA,eACA,CAAiB,EACjB,GACA,uBACA,kBACiB,CACjB,CACA,SACA,0CACA,MAEA,IAEA,UACA,UAEA,CAAK,EACL,EACA,EACA,EACA,QACA,SACA,EACA,QACA,EACA,QACA,SACA,wBACA,kBACA,EACA,EACA,EAyBA,MAvBI,eAAS,MACb,eAIA,GACA,GACA,IACA,QACA,cACA,GACA,IAEA,CAAK,EACL,aACA,EACA,EACA,SACA,EACA,EACA,EACA,EACA,EACA,CACA,QACA,iBACA,YACA,SACA,UACA,CACA,EAhPA,CACA,cACA,gBACA,sBACA,gBACA,cACA,cACA,YACA,CAAK,EACL,iCACA,MAAY,UAAK,CAAC,IAAS,EAAI,iBAAoB,SAAI,CAAC,IAAW,EAAI,8BAA0C,EAAG,SAAI,CAAC,GAAM,EAAI,OAAS,EAAG,SAAI,CAAC,IAAS,EAAI,yCACjK,YAAiC,IAAO,IACvB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yB,EACzD,wBACA,aACA,CAAiC,EACD,yBAAmB,EACnD,SAA8C,OAAW,EACzD,QAAiD,QAAa,IAChB,IAAoB,CAClE,UACA,QACA,QACA,CAAqC,CACrC,CAAiC,EACjC,CAEA,wBAiFA,GACA,UAAY,iFAAiF,EAC7F,OACA,mBACA,oBACA,oBACA,OACA,mCACA,WACA,aACA,aAA8B,QAAa,IACrB,IAAoB,CAC1C,UACA,oBACA,gBACA,YACA,eACA,CAAa,CACb,SACA,aACA,aAA8B,QAAa,IACrB,IAAoB,CAC1C,UACA,oBACA,gBACA,YACA,eACA,CAAa,CACb,cAA2B,QAAK,eAChC,aACA,YAAyB,QAAK,eAC9B,WACA,cACA,eAA4B,QAAK,eACjC,WACA,eACA,kBACA,cACA,sBACA,mBACA,qBACA,iBACA,CAAa,CACJ,CACT,cACA,YACA,QACA,kCACA,SACA,UAAuB,QAAK,eAC5B,iBACA,qCACA,OACA,aACA,aAA8B,QAAa,IACrB,IAAoB,CAC1C,UACA,oBACA,gBACA,YACA,eACA,CAAa,CAEb,CACA,EAjJA,CACA,QACA,QACA,gBACA,cACA,8BACA,YACA,aACA,CAA6B,GAE7B,aACA,GAAwC,UAAY,CACpD,KACA,CACA,YAA2D,GAAwB,CACnF,SACA,WAFmF,CAEnF,kBACA,YACA,aACA,aAA8C,QAAa,IACrB,IAAoB,CAC1D,UACA,SACA,4BACA,CAA6B,EAC7B,mBAYA,MAV4D,SAAS,EACrE,SAA8C,OAAW,EACzD,SACA,oCACA,MAA+C,QAAc,wBAC7D,CAAqC,EACrC,uBACA,eACA,wBACiC,EAEjC,kCACA,aACA,MAAwD,QAAO,EAC/D,SAAkD,OAAW,EAC7D,SACA,oCACA,MAAmD,QAAc,wBACjE,CAAyC,EACzC,uBACA,eACA,0CACA,CAAqC,CAErC,OAA0C,QAAyB,EACnE,wBACA,aACA,CAAqC,CACrC,CAEA,cAEA,2BACA,QAA6C,sBAAe,EAC5D,wBACA,aACA,CAA6B,EAE7B,qBACA,GAAwC,UAAY,CACpD,CAEA,CACA,SACA,iBACA,GACA,WACA,6CACA,CAAyB,CACz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","sources":["webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/DirectPaymentModeScreen.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useBuyTxStates.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/TransactionModeScreen.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/CurrencySelection.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getQuote.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithFiatQuote.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/utils/errors.js","webpack://unreal/../../../../src/react/web/ui/components/Drawer.tsx","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/formatSeconds.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/EstimatedTimeAndFees.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/PayWIthCreditCard.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/Fees.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/pay/utils/commonTypes.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/Providers.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/FiatScreenContent.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/pay/buyWithFiat/isSwapRequiredPostOnramp.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/openOnRamppopup.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/fiat/OnRampScreen.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useEnabledPaymentMethods.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/chains/chain-definitions/polygon.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/main/useUISelectionStates.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/utils.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/FiatValue.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/BuyTokenInput.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/core/hooks/pay/useBuyWithCryptoQuote.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/PayWithCrypto.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/SwapScreenContent.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/TokenSelectorScreen.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getTransfer.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/TransferConfirmationScreen.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/swap/TransferFlow.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/usePayerSetup.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/react/web/ui/ConnectWallet/screens/Buy/BuyScreen.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc20/read/decimals.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/read/decimals.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/common/__generated__/IContractMetadata/read/name.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/common/read/name.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/common/__generated__/IContractMetadata/read/symbol.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/common/read/symbol.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/extensions/erc20/read/getCurrencyMetadata.js"],"sourcesContent":["import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { trackPayEvent } from \"../../../../../../analytics/track/pay.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../../contract/contract.js\";\nimport { decimals } from \"../../../../../../extensions/erc20/read/decimals.js\";\nimport { shortenAddress } from \"../../../../../../utils/address.js\";\nimport { formatNumber } from \"../../../../../../utils/formatNumber.js\";\nimport { toTokens } from \"../../../../../../utils/units.js\";\nimport { useCustomTheme } from \"../../../../../core/design-system/CustomThemeProvider.js\";\nimport { iconSize, spacing } from \"../../../../../core/design-system/index.js\";\nimport { useChainMetadata } from \"../../../../../core/hooks/others/useChainQuery.js\";\nimport { useActiveWallet } from \"../../../../../core/hooks/wallets/useActiveWallet.js\";\nimport { useEnsName } from \"../../../../../core/utils/wallet.js\";\nimport { LoadingScreen } from \"../../../../wallets/shared/LoadingScreen.js\";\nimport { ChainIcon } from \"../../../components/ChainIcon.js\";\nimport { Img } from \"../../../components/Img.js\";\nimport { Spacer } from \"../../../components/Spacer.js\";\nimport { TokenIcon } from \"../../../components/TokenIcon.js\";\nimport { WalletImage } from \"../../../components/WalletImage.js\";\nimport { Container, Line, ModalHeader } from \"../../../components/basic.js\";\nimport { Button } from \"../../../components/buttons.js\";\nimport { Text } from \"../../../components/text.js\";\nimport { ConnectButton } from \"../../ConnectButton.js\";\nimport { isNativeToken } from \"../nativeToken.js\";\nexport function DirectPaymentModeScreen(props) {\n    const { payUiOptions, supportedDestinations, client, onContinue, payerAccount, } = props;\n    const theme = useCustomTheme();\n    const activeWallet = useActiveWallet();\n    const metadata = payUiOptions.metadata;\n    const paymentInfo = payUiOptions.paymentInfo;\n    const { data: chainData } = useChainMetadata(paymentInfo.chain);\n    const { data: sellerEns } = useEnsName({\n        client,\n        address: paymentInfo.sellerAddress,\n    });\n    const totalCostQuery = useQuery({\n        queryKey: [\"amount\", paymentInfo],\n        queryFn: async () => {\n            let tokenDecimals = 18;\n            if (paymentInfo.token && !isNativeToken(paymentInfo.token)) {\n                tokenDecimals = await decimals({\n                    contract: getContract({\n                        address: paymentInfo.token.address,\n                        chain: paymentInfo.chain,\n                        client,\n                    }),\n                });\n            }\n            let cost;\n            if (\"amountWei\" in paymentInfo) {\n                cost = toTokens(paymentInfo.amountWei, tokenDecimals);\n            }\n            else {\n                cost = paymentInfo.amount;\n            }\n            return cost;\n        },\n    });\n    const totalCost = totalCostQuery.data;\n    if (!chainData || totalCost === undefined) {\n        return _jsx(LoadingScreen, {});\n    }\n    const token = paymentInfo.token\n        ? {\n            ...paymentInfo.token,\n            icon: paymentInfo.token?.icon ||\n                supportedDestinations\n                    .find((c) => c.chain.id === paymentInfo.chain.id)\n                    ?.tokens.find((t) => t.address.toLowerCase() ===\n                    paymentInfo.token?.address.toLowerCase())?.icon,\n        }\n        : {\n            address: NATIVE_TOKEN_ADDRESS,\n            name: chainData.nativeCurrency.name,\n            symbol: chainData.nativeCurrency.symbol,\n            icon: chainData.icon?.url,\n        };\n    return (_jsxs(Container, { p: \"lg\", children: [_jsx(ModalHeader, { title: metadata?.name || \"Payment Details\" }), _jsx(Spacer, { y: \"lg\" }), _jsxs(Container, { children: [metadata?.image ? (_jsx(Img, { client: client, src: metadata?.image, style: {\n                            width: \"100%\",\n                            borderRadius: spacing.md,\n                            backgroundColor: theme.colors.tertiaryBg,\n                        } })) : activeWallet ? (_jsxs(Container, { flex: \"row\", center: \"both\", style: {\n                            padding: spacing.md,\n                            marginBottom: spacing.md,\n                            borderRadius: spacing.md,\n                            backgroundColor: theme.colors.tertiaryBg,\n                        }, children: [_jsx(WalletImage, { size: iconSize.xl, id: activeWallet.id, client: client }), _jsx(\"div\", { style: {\n                                    flexGrow: 1,\n                                    borderBottom: \"6px dotted\",\n                                    borderColor: theme.colors.secondaryIconColor,\n                                    marginLeft: spacing.md,\n                                    marginRight: spacing.md,\n                                } }), _jsx(ChainIcon, { client: client, size: iconSize.xl, chainIconUrl: chainData.icon?.url })] })) : null, _jsx(Spacer, { y: \"md\" }), _jsxs(Container, { flex: \"row\", children: [_jsx(Container, { flex: \"column\", expand: true, children: _jsx(Text, { size: \"md\", color: \"primaryText\", weight: 700, children: \"Price\" }) }), _jsx(Container, { expand: true, children: _jsxs(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: { justifyContent: \"right\" }, children: [_jsx(TokenIcon, { chain: paymentInfo.chain, client: props.client, size: \"sm\", token: token }), _jsxs(Text, { color: \"primaryText\", size: \"md\", weight: 700, children: [String(formatNumber(Number(totalCost), 6)), \" \", token.symbol] })] }) })] }), _jsx(Spacer, { y: \"md\" }), _jsx(Line, {}), _jsx(Spacer, { y: \"md\" }), _jsxs(Container, { flex: \"row\", children: [_jsx(Container, { flex: \"column\", expand: true, children: _jsx(Text, { size: \"xs\", color: \"secondaryText\", children: \"Network\" }) }), _jsx(Container, { expand: true, children: _jsxs(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: { justifyContent: \"right\" }, children: [_jsx(ChainIcon, { chainIconUrl: chainData.icon?.url, size: \"xs\", client: props.client }), _jsx(Text, { size: \"xs\", color: \"secondaryText\", style: { textAlign: \"right\" }, children: chainData.name })] }) })] }), _jsx(Spacer, { y: \"sm\" }), _jsxs(Container, { flex: \"row\", children: [_jsx(Container, { flex: \"column\", expand: true, children: _jsx(Text, { size: \"xs\", color: \"secondaryText\", children: \"Seller\" }) }), _jsx(Container, { expand: true, children: _jsx(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: { justifyContent: \"right\" }, children: _jsx(Text, { size: \"xs\", color: \"secondaryText\", style: { textAlign: \"right\" }, children: sellerEns || shortenAddress(paymentInfo.sellerAddress) }) }) })] })] }), _jsx(Spacer, { y: \"xl\" }), payerAccount ? (_jsx(Button, { variant: \"accent\", fullWidth: true, onClick: () => {\n                    trackPayEvent({\n                        event: \"choose_payment_method_direct_payment_mode\",\n                        client,\n                        walletAddress: payerAccount.address,\n                        walletType: activeWallet?.id,\n                    });\n                    onContinue(totalCost, paymentInfo.chain, token);\n                }, children: \"Choose Payment Method\" })) : (_jsx(\"div\", { children: _jsx(ConnectButton, { ...props.connectOptions, client: client, theme: theme, connectButton: {\n                        style: {\n                            width: \"100%\",\n                        },\n                    } }) }))] }));\n}\n//# sourceMappingURL=DirectPaymentModeScreen.js.map","import { useQuery } from \"@tanstack/react-query\";\nimport { useEffect, useState } from \"react\";\nimport { getChainMetadata } from \"../../../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../../../contract/contract.js\";\nimport { getCurrencyMetadata } from \"../../../../../../../extensions/erc20/read/getCurrencyMetadata.js\";\nimport { encode } from \"../../../../../../../transaction/actions/encode.js\";\nimport { getTransactionGasCost } from \"../../../../../../../transaction/utils.js\";\nimport { resolvePromisedValue } from \"../../../../../../../utils/promise/resolve-promised-value.js\";\nimport { getWalletBalance } from \"../../../../../../../wallets/utils/getWalletBalance.js\";\nexport function useTransactionCostAndData(args) {\n    const { transaction, account, supportedDestinations } = args;\n    // Compute query key of the transaction first\n    const [txQueryKey, setTxQueryKey] = useState();\n    useEffect(() => {\n        Promise.all([\n            resolvePromisedValue(transaction.value),\n            resolvePromisedValue(transaction.erc20Value),\n            resolvePromisedValue(transaction.to),\n            encode(transaction),\n        ]).then(([value, erc20Value, to, data]) => {\n            setTxQueryKey({\n                value: value?.toString(),\n                erc20Value: erc20Value?.amountWei?.toString(),\n                erc20Currency: erc20Value?.tokenAddress,\n                to,\n                data,\n            });\n        });\n    }, [transaction]);\n    return useQuery({\n        queryKey: [\n            \"transaction-cost\",\n            transaction.chain.id,\n            account?.address,\n            txQueryKey,\n        ],\n        queryFn: async () => {\n            if (!account) {\n                throw new Error(\"No payer account found\");\n            }\n            const erc20Value = await resolvePromisedValue(transaction.erc20Value);\n            if (erc20Value) {\n                const [tokenBalance, tokenMeta, gasCostWei] = await Promise.all([\n                    getWalletBalance({\n                        address: account.address,\n                        chain: transaction.chain,\n                        client: transaction.client,\n                        tokenAddress: erc20Value.tokenAddress,\n                    }),\n                    getCurrencyMetadata({\n                        contract: getContract({\n                            address: erc20Value.tokenAddress,\n                            chain: transaction.chain,\n                            client: transaction.client,\n                        }),\n                    }),\n                    getTransactionGasCost(transaction, account?.address),\n                ]);\n                const transactionValueWei = erc20Value.amountWei;\n                const walletBalance = tokenBalance;\n                const currency = {\n                    address: erc20Value.tokenAddress,\n                    name: tokenMeta.name,\n                    symbol: tokenMeta.symbol,\n                    icon: supportedDestinations\n                        .find((c) => c.chain.id === transaction.chain.id)\n                        ?.tokens.find((t) => t.address.toLowerCase() ===\n                        erc20Value.tokenAddress.toLowerCase())?.icon,\n                };\n                return {\n                    token: currency,\n                    decimals: tokenMeta.decimals,\n                    walletBalance,\n                    gasCostWei,\n                    transactionValueWei,\n                };\n            }\n            const [nativeWalletBalance, chainMetadata, gasCostWei] = await Promise.all([\n                getWalletBalance({\n                    address: account.address,\n                    chain: transaction.chain,\n                    client: transaction.client,\n                }),\n                getChainMetadata(transaction.chain),\n                getTransactionGasCost(transaction, account?.address),\n            ]);\n            const walletBalance = nativeWalletBalance;\n            const transactionValueWei = (await resolvePromisedValue(transaction.value)) || 0n;\n            return {\n                token: {\n                    address: NATIVE_TOKEN_ADDRESS,\n                    name: chainMetadata.nativeCurrency.name,\n                    symbol: chainMetadata.nativeCurrency.symbol,\n                    icon: chainMetadata.icon?.url,\n                },\n                decimals: 18,\n                walletBalance,\n                gasCostWei,\n                transactionValueWei,\n            };\n        },\n        enabled: !!transaction && !!txQueryKey,\n        refetchInterval: () => {\n            if (transaction.erc20Value) {\n                // if erc20 value is set, we don't need to poll\n                return undefined;\n            }\n            return 30_000;\n        },\n    });\n}\n//# sourceMappingURL=useBuyTxStates.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { trackPayEvent } from \"../../../../../../analytics/track/pay.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../constants/addresses.js\";\nimport { formatNumber } from \"../../../../../../utils/formatNumber.js\";\nimport { toTokens } from \"../../../../../../utils/units.js\";\nimport { useCustomTheme } from \"../../../../../core/design-system/CustomThemeProvider.js\";\nimport { fontSize, iconSize, spacing, } from \"../../../../../core/design-system/index.js\";\nimport { useChainMetadata } from \"../../../../../core/hooks/others/useChainQuery.js\";\nimport { useWalletBalance } from \"../../../../../core/hooks/others/useWalletBalance.js\";\nimport { useActiveAccount } from \"../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { useActiveWallet } from \"../../../../../core/hooks/wallets/useActiveWallet.js\";\nimport { hasSponsoredTransactionsEnabled } from \"../../../../../core/utils/wallet.js\";\nimport { ErrorState } from \"../../../../wallets/shared/ErrorState.js\";\nimport { LoadingScreen } from \"../../../../wallets/shared/LoadingScreen.js\";\nimport { ChainIcon } from \"../../../components/ChainIcon.js\";\nimport { Img } from \"../../../components/Img.js\";\nimport { Skeleton } from \"../../../components/Skeleton.js\";\nimport { Spacer } from \"../../../components/Spacer.js\";\nimport { TokenIcon } from \"../../../components/TokenIcon.js\";\nimport { Container, Line, ModalHeader } from \"../../../components/basic.js\";\nimport { Button } from \"../../../components/buttons.js\";\nimport { Text } from \"../../../components/text.js\";\nimport { TokenSymbol } from \"../../../components/token/TokenSymbol.js\";\nimport { ConnectButton } from \"../../ConnectButton.js\";\nimport { OutlineWalletIcon } from \"../../icons/OutlineWalletIcon.js\";\nimport { formatTokenBalance } from \"../formatTokenBalance.js\";\nimport { NATIVE_TOKEN, isNativeToken, } from \"../nativeToken.js\";\nimport { useTransactionCostAndData } from \"./main/useBuyTxStates.js\";\nimport { WalletRow } from \"./swap/WalletRow.js\";\nexport function TransactionModeScreen(props) {\n    const { payUiOptions, client, payerAccount, supportedDestinations, onContinue, } = props;\n    const { data: chainData, error: chainDataError, isLoading: chainDataLoading, refetch: chainDataRefetch, } = useChainMetadata(payUiOptions.transaction.chain);\n    const metadata = payUiOptions.metadata;\n    const { data: transactionCostAndData, error: transactionCostAndDataError, isLoading: transactionCostAndDataLoading, refetch: transactionCostAndDataRefetch, } = useTransactionCostAndData({\n        transaction: payUiOptions.transaction,\n        account: payerAccount,\n        supportedDestinations,\n    });\n    const theme = useCustomTheme();\n    const activeWallet = useActiveWallet();\n    const activeAccount = useActiveAccount();\n    const sponsoredTransactionsEnabled = hasSponsoredTransactionsEnabled(activeWallet);\n    const balanceQuery = useWalletBalance({\n        address: activeAccount?.address,\n        chain: payUiOptions.transaction.chain,\n        tokenAddress: isNativeToken(transactionCostAndData?.token || NATIVE_TOKEN)\n            ? undefined\n            : transactionCostAndData?.token.address,\n        client: props.client,\n    }, {\n        enabled: !!transactionCostAndData,\n    });\n    if (transactionCostAndDataLoading || chainDataLoading) {\n        return _jsx(LoadingScreen, {});\n    }\n    if (!activeAccount) {\n        return (_jsx(Container, { style: {\n                minHeight: \"350px\",\n            }, fullHeight: true, flex: \"row\", center: \"both\", children: _jsxs(Container, { animate: \"fadein\", children: [_jsx(Spacer, { y: \"xxl\" }), _jsx(Container, { flex: \"row\", center: \"x\", children: _jsx(OutlineWalletIcon, { size: iconSize[\"3xl\"] }) }), _jsx(Spacer, { y: \"lg\" }), _jsx(Text, { center: true, color: \"primaryText\", size: \"md\", children: \"Please connect a wallet to continue\" }), _jsx(Spacer, { y: \"xl\" }), _jsx(Container, { flex: \"row\", center: \"x\", style: { width: \"100%\" }, children: _jsx(ConnectButton, { client: client, theme: theme, ...props.connectOptions }) })] }) }));\n    }\n    if (transactionCostAndDataError || chainDataError) {\n        return (_jsx(Container, { style: {\n                minHeight: \"350px\",\n            }, fullHeight: true, flex: \"row\", center: \"both\", children: _jsx(ErrorState, { title: transactionCostAndDataError?.message ||\n                    chainDataError?.message ||\n                    \"Something went wrong\", onTryAgain: transactionCostAndDataError\n                    ? transactionCostAndDataRefetch\n                    : chainDataRefetch }) }));\n    }\n    if (!transactionCostAndData || !chainData) {\n        return _jsx(LoadingScreen, {});\n    }\n    const insufficientFunds = balanceQuery.data &&\n        balanceQuery.data.value < transactionCostAndData.transactionValueWei;\n    return (_jsxs(Container, { p: \"lg\", children: [_jsx(ModalHeader, { title: metadata?.name || \"Transaction\" }), _jsx(Spacer, { y: \"lg\" }), _jsxs(Container, { children: [metadata?.image ? (_jsx(Img, { client: client, src: metadata?.image, style: {\n                            width: \"100%\",\n                            borderRadius: spacing.md,\n                            border: `1px solid ${theme.colors.borderColor}`,\n                            backgroundColor: theme.colors.tertiaryBg,\n                        } })) : activeAccount ? (_jsxs(Container, { flex: \"column\", gap: \"sm\", children: [insufficientFunds && (_jsx(Text, { size: \"sm\", color: \"danger\", style: { textAlign: \"center\" }, children: \"Insufficient funds\" })), _jsxs(Container, { flex: \"row\", style: {\n                                    justifyContent: \"space-between\",\n                                    padding: spacing.sm,\n                                    marginBottom: spacing.sm,\n                                    borderRadius: spacing.md,\n                                    backgroundColor: theme.colors.tertiaryBg,\n                                    border: `1px solid ${theme.colors.borderColor}`,\n                                }, children: [_jsx(WalletRow, { address: activeAccount?.address, iconSize: \"md\", client: client }), balanceQuery.data ? (_jsxs(Container, { flex: \"row\", gap: \"3xs\", center: \"y\", children: [_jsx(Text, { size: \"xs\", color: \"secondaryText\", weight: 500, children: formatTokenBalance(balanceQuery.data, false) }), _jsx(TokenSymbol, { token: transactionCostAndData.token, chain: payUiOptions.transaction.chain, size: \"xs\", color: \"secondaryText\" })] })) : (_jsx(Skeleton, { width: \"70px\", height: fontSize.xs }))] })] })) : null, _jsx(Spacer, { y: \"md\" }), _jsxs(Container, { flex: \"row\", children: [_jsx(Container, { flex: \"column\", expand: true, children: _jsx(Text, { size: \"md\", color: \"primaryText\", weight: 700, children: \"Price\" }) }), _jsx(Container, { expand: true, children: _jsxs(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: { justifyContent: \"right\" }, children: [_jsx(TokenIcon, { chain: payUiOptions.transaction.chain, client: props.client, size: \"sm\", token: transactionCostAndData.token }), _jsxs(Text, { color: \"primaryText\", size: \"md\", weight: 700, children: [String(formatNumber(Number(toTokens(transactionCostAndData.transactionValueWei, transactionCostAndData.decimals)), 6)), \" \", transactionCostAndData.token.symbol] })] }) })] }), _jsx(Spacer, { y: \"md\" }), _jsx(Line, {}), _jsx(Spacer, { y: \"md\" }), _jsxs(Container, { flex: \"row\", children: [_jsx(Container, { flex: \"column\", expand: true, children: _jsx(Text, { size: \"xs\", color: \"secondaryText\", children: \"Gas Fees\" }) }), _jsx(Container, { expand: true, children: _jsx(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: { justifyContent: \"right\" }, children: _jsx(Text, { color: sponsoredTransactionsEnabled ? \"success\" : \"primaryText\", size: \"xs\", children: sponsoredTransactionsEnabled\n                                            ? \"Sponsored\"\n                                            : `${String(formatNumber(Number(toTokens(transactionCostAndData.gasCostWei, chainData.nativeCurrency.decimals)), 6))} ${chainData.nativeCurrency.symbol}` }) }) })] }), _jsx(Spacer, { y: \"sm\" }), _jsxs(Container, { flex: \"row\", children: [_jsx(Container, { flex: \"column\", expand: true, children: _jsx(Text, { size: \"xs\", color: \"secondaryText\", children: \"Network\" }) }), _jsx(Container, { expand: true, children: _jsxs(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: { justifyContent: \"right\" }, children: [_jsx(ChainIcon, { chainIconUrl: chainData.icon?.url, size: \"xs\", client: props.client }), _jsx(Text, { size: \"xs\", color: \"secondaryText\", style: { textAlign: \"right\" }, children: chainData.name })] }) })] })] }), _jsx(Spacer, { y: \"xl\" }), payerAccount ? (_jsx(Button, { variant: \"accent\", fullWidth: true, onClick: () => {\n                    let totalCostWei = transactionCostAndData.transactionValueWei;\n                    if (transactionCostAndData.token.address === NATIVE_TOKEN_ADDRESS &&\n                        !sponsoredTransactionsEnabled) {\n                        totalCostWei += transactionCostAndData.gasCostWei;\n                    }\n                    trackPayEvent({\n                        event: \"choose_payment_method_transaction_mode\",\n                        client,\n                        walletAddress: payerAccount.address,\n                        walletType: activeWallet?.id,\n                    });\n                    onContinue(toTokens(totalCostWei, transactionCostAndData.decimals), payUiOptions.transaction.chain, transactionCostAndData.token);\n                }, children: \"Choose Payment Method\" })) : (_jsx(\"div\", { children: _jsx(ConnectButton, { ...props.connectOptions, client: client, theme: theme, connectButton: {\n                        style: {\n                            width: \"100%\",\n                        },\n                    } }) }))] }));\n}\n//# sourceMappingURL=TransactionModeScreen.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport styled from \"@emotion/styled\";\nimport { useCustomTheme } from \"../../../../../../core/design-system/CustomThemeProvider.js\";\nimport { spacing } from \"../../../../../../core/design-system/index.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Container, Line, ModalHeader } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { currencies, getFiatIcon } from \"./currencies.js\";\nexport function CurrencySelection(props) {\n    return (_jsxs(Container, { children: [_jsx(Container, { p: \"lg\", children: _jsx(ModalHeader, { title: \"Pay with\", onBack: props.onBack }) }), _jsx(Line, {}), _jsx(Spacer, { y: \"lg\" }), _jsx(Container, { flex: \"column\", gap: \"xs\", px: \"lg\", children: currencies.map((c) => {\n                    return (_jsxs(SelectCurrencyButton, { fullWidth: true, variant: \"secondary\", onClick: () => props.onSelect(c), gap: \"sm\", children: [getFiatIcon(c, \"lg\"), _jsxs(Container, { flex: \"column\", gap: \"xxs\", children: [_jsx(Text, { color: \"primaryText\", children: c.shorthand }), _jsx(Text, { size: \"sm\", children: c.name })] })] }, c.shorthand));\n                }) }), _jsx(Spacer, { y: \"lg\" })] }));\n}\nconst SelectCurrencyButton = /* @__PURE__ */ styled(Button)(() => {\n    const theme = useCustomTheme();\n    return {\n        background: theme.colors.tertiaryBg,\n        justifyContent: \"flex-start\",\n        gap: spacing.sm,\n        padding: spacing.sm,\n        \"&:hover\": {\n            background: theme.colors.secondaryButtonBg,\n            transform: \"scale(1.01)\",\n        },\n        transition: \"background 200ms ease, transform 150ms ease\",\n    };\n});\n//# sourceMappingURL=CurrencySelection.js.map","import { getClientFetch } from \"../../utils/fetch.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { getPayBuyWithFiatQuoteEndpoint } from \"../utils/definitions.js\";\n/**\n * Get a quote of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote) to buy given token with fiat currency.\n * This quote contains the information about the swap such as token amounts, processing fees, estimated time etc.\n *\n * ### Rendering the On-Ramp provider UI\n * Once you have the `quote`, you can open the `quote.onRampLink` in a new tab - This will prompt the user to buy the token with fiat currency\n *\n * ### Determining the steps required\n * If `quote.onRampToken.token` is same as `quote.toToken` ( same chain + same token address ) - This means that the token can be directly bought from the on-ramp provider.\n * But if they are different, On-ramp provider will send the `quote.onRampToken` to the user's wallet address and a swap is required to swap it to the desired token onchain.\n *\n * You can use the [`isSwapRequiredPostOnramp`](https://portal.thirdweb.com/references/typescript/v5/isSwapRequiredPostOnramp) utility function to check if a swap is required after the on-ramp is done.\n *\n * ### Polling for the status\n * Once you open the `quote.onRampLink` in a new tab, you can start polling for the status using [`getBuyWithFiatStatus`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithFiatStatus) to get the status of the transaction.\n *\n * `getBuyWithFiatStatus` returns a status object of type [`BuyWithFiatStatus`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatStatus).\n *\n * - If no swap is required - the status will become `\"ON_RAMP_TRANSFER_COMPLETED\"` once the on-ramp provider has sent the desired token to the user's wallet address. Once you receive this status, the process is complete.\n * - If a swap is required - the status will become `\"CRYPTO_SWAP_REQUIRED\"` once the on-ramp provider has sent the tokens to the user's wallet address. Once you receive this status, you need to start the swap process.\n *\n * ### Swap Process\n * On receiving the `\"CRYPTO_SWAP_REQUIRED\"` status, you can use the [`getPostOnRampQuote`](https://portal.thirdweb.com/references/typescript/v5/getPostOnRampQuote) function to get the quote for the swap of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote).\n *\n * Once you have this quote - You can follow the same steps as mentioned in the [`getBuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoQuote) documentation to perform the swap.\n *\n * @param params - object of type [`GetBuyWithFiatQuoteParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithFiatQuoteParams)\n * @returns Object of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote) which contains the information about the quote such as processing fees, estimated time, converted token amounts, etc.\n * @example\n * Get a quote for buying 10 USDC on polygon chain (chainId: 137) with USD fiat currency:\n *\n * ```ts\n * import { getBuyWithFiatQuote } from \"thirdweb/pay\";\n *\n * const quote = await getBuyWithFiatQuote({\n *  client: client, // thirdweb client\n *  fromCurrencySymbol: \"USD\", // fiat currency symbol\n *  toChainId: 137, // polygon chain id\n *  toAmount: \"10\", // amount of USDC to buy\n *  toTokenAddress: \"0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359\" // USDC token address in polygon chain\n *  toAddress: \"0x...\", // user's wallet address\n *  isTestMode: false, // whether to use onramp in test mode for testing purpose (defaults to false)\n * });\n *\n * window.open(quote.onRampLink, \"_blank\");\n * ```\n * @buyCrypto\n */\nexport async function getBuyWithFiatQuote(params) {\n    try {\n        const clientFetch = getClientFetch(params.client);\n        const response = await clientFetch(getPayBuyWithFiatQuoteEndpoint(), {\n            method: \"POST\",\n            headers: {\n                Accept: \"application/json\",\n                \"Content-Type\": \"application/json\",\n            },\n            body: stringify({\n                toAddress: params.toAddress,\n                fromCurrencySymbol: params.fromCurrencySymbol,\n                toChainId: params.toChainId.toString(),\n                toTokenAddress: params.toTokenAddress,\n                fromAmount: params.fromAmount,\n                toAmount: params.toAmount,\n                maxSlippageBPS: params.maxSlippageBPS,\n                isTestMode: params.isTestMode,\n                purchaseData: params.purchaseData,\n                fromAddress: params.fromAddress,\n                toGasAmountWei: params.toGasAmountWei,\n                preferredProvider: params.preferredProvider,\n                multiHopSupported: true,\n            }),\n        });\n        // Assuming the response directly matches the SwapResponse interface\n        if (!response.ok) {\n            const errorObj = await response.json();\n            if (errorObj && \"error\" in errorObj) {\n                throw errorObj;\n            }\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return (await response.json()).result;\n    }\n    catch (error) {\n        console.error(\"Error getting buy with fiat quote\", error);\n        throw error;\n    }\n}\n//# sourceMappingURL=getQuote.js.map","import { useQuery, } from \"@tanstack/react-query\";\nimport { getBuyWithFiatQuote, } from \"../../../../pay/buyWithFiat/getQuote.js\";\n/**\n * Hook to get a price quote for performing a \"Buy with Fiat\" transaction that allows users to buy a token with fiat currency.\n *\n * The price quote is an object of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote).\n * This quote contains the information about the purchase such as token amounts, processing fees, estimated time etc.\n *\n * This hook is a React Query wrapper of the [`getBuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithFiatQuote) function.\n * You can also use that function directly\n *\n * Once you have the `quote`, you can open a new window with `quote.onRampLink` to allow the user to buy the token with fiat currency.\n * and [`useBuyWithFiatStatus`](https://portal.thirdweb.com/references/typescript/v5/useBuyWithFiatStatus) function to start polling for the status of this transaction.\n *\n * @param params - object of type [`GetBuyWithFiatQuoteParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithFiatQuoteParams)\n * @param queryParams - options to configure the react query\n * @returns A React Query object which contains the data of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote)\n * @example\n * ```ts\n * import { NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n * import { base } from \"thirdweb/chains\";\n * import { useBuyWithFiatQuote } from \"thirdweb/react\";\n *\n * // get a quote for buying 0.01 base native token with USD fiat currency\n * function Example() {\n *   const quote = useBuyWithFiatQuote({\n *     client: client, // thirdweb client\n *     fromCurrencySymbol: \"USD\", // fiat currency symbol\n *     toChainId: base.id, // base chain id\n *     toAmount: \"0.01\", // amount of token to buy\n *     toTokenAddress: NATIVE_TOKEN_ADDRESS, // native token\n *     toAddress: \"0x...\", // user's wallet address\n *   });\n *\n *   return (\n *     <div>\n *       {quote.data && (\n *         <a href={quote.data.onRampLink} target=\"_blank\">\n *           open onramp provider\n *         </a>\n *       )}\n *     </div>\n *   );\n * }\n * ```\n * @buyCrypto\n */\nexport function useBuyWithFiatQuote(params, queryOptions) {\n    return useQuery({\n        ...queryOptions,\n        queryKey: [\"useBuyWithFiatQuote\", params],\n        queryFn: async () => {\n            if (!params) {\n                throw new Error(\"No params provided\");\n            }\n            return getBuyWithFiatQuote(params);\n        },\n        enabled: !!params,\n        retry: false,\n    });\n}\n//# sourceMappingURL=useBuyWithFiatQuote.js.map","export const defaultMessage = \"Unable to get price quote\";\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport function getErrorMessage(err) {\n    if (typeof err.error === \"object\" && err.error.code) {\n        if (err.error.code === \"MINIMUM_PURCHASE_AMOUNT\") {\n            return {\n                code: \"MINIMUM_PURCHASE_AMOUNT\",\n                message: \"Purchase amount is too low\",\n            };\n        }\n    }\n    return {\n        code: \"UNABLE_TO_GET_PRICE_QUOTE\",\n        message: defaultMessage,\n    };\n}\n//# sourceMappingURL=errors.js.map",null,"/**\n * @internal\n */\nexport function formatSeconds(seconds) {\n    // hours and minutes\n    if (seconds > 3600) {\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor((seconds % 3600) / 60);\n        return `${hours} Hours ${minutes} Minutes`;\n    }\n    // minutes only\n    if (seconds > 60) {\n        const minutes = Math.ceil(seconds / 60);\n        return `${minutes} Minutes`;\n    }\n    return `${seconds}s`;\n}\n//# sourceMappingURL=formatSeconds.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { ClockIcon } from \"@radix-ui/react-icons\";\nimport { fontSize, iconSize, radius, } from \"../../../../../core/design-system/index.js\";\nimport { Skeleton } from \"../../../components/Skeleton.js\";\nimport { Container } from \"../../../components/basic.js\";\nimport { Button } from \"../../../components/buttons.js\";\nimport { Text } from \"../../../components/text.js\";\nimport { formatSeconds } from \"./swap/formatSeconds.js\";\nexport function EstimatedTimeAndFees(props) {\n    const { estimatedSeconds, quoteIsLoading } = props;\n    return (_jsxs(Container, { bg: \"tertiaryBg\", flex: \"row\", borderColor: \"borderColor\", style: {\n            borderRadius: radius.md,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0,\n            justifyContent: \"space-between\",\n            alignItems: \"center\",\n            borderWidth: \"1px\",\n            borderStyle: \"solid\",\n        }, children: [_jsxs(Container, { flex: \"row\", center: \"y\", gap: \"xxs\", color: \"accentText\", p: \"sm\", children: [_jsx(ClockIcon, { width: iconSize.sm, height: iconSize.sm }), quoteIsLoading ? (_jsx(Skeleton, { height: fontSize.xs, width: \"50px\", color: \"borderColor\" })) : (_jsx(Text, { size: \"xs\", color: \"secondaryText\", children: estimatedSeconds !== undefined\n                            ? `~${formatSeconds(estimatedSeconds)}`\n                            : \"--\" }))] }), _jsxs(Button, { variant: \"ghost\", onClick: props.onViewFees, gap: \"xs\", children: [_jsx(Container, { color: \"accentText\", flex: \"row\", center: \"both\", children: _jsx(ViewFeeIcon, { size: iconSize.sm }) }), _jsx(Text, { size: \"xs\", color: \"secondaryText\", children: \"View Fees\" })] })] }));\n}\nconst ViewFeeIcon = (props) => {\n    return (_jsxs(\"svg\", { width: props.size, height: props.size, viewBox: \"0 0 12 12\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\", \"aria-hidden\": \"true\", children: [_jsx(\"path\", { d: \"M9.5 1.5H2.5C1.94772 1.5 1.5 1.94772 1.5 2.5V9.5C1.5 10.0523 1.94772 10.5 2.5 10.5H9.5C10.0523 10.5 10.5 10.0523 10.5 9.5V2.5C10.5 1.94772 10.0523 1.5 9.5 1.5Z\", stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\" }), _jsx(\"path\", { d: \"M4.5 7.5L7.5 4.5\", stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\" })] }));\n};\n//# sourceMappingURL=EstimatedTimeAndFees.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport styled from \"@emotion/styled\";\nimport { ChevronDownIcon } from \"@radix-ui/react-icons\";\nimport { formatNumber } from \"../../../../../../utils/formatNumber.js\";\nimport { fontSize, iconSize, radius, spacing, } from \"../../../../../core/design-system/index.js\";\nimport { Skeleton } from \"../../../components/Skeleton.js\";\nimport { Container } from \"../../../components/basic.js\";\nimport { Button } from \"../../../components/buttons.js\";\nimport { Text } from \"../../../components/text.js\";\nimport { getFiatIcon } from \"./fiat/currencies.js\";\n/**\n * Shows an amount \"value\" and renders the selected token and chain\n * It also renders the buttons to select the token and chain\n * It also renders the balance of active wallet for the selected token in selected chain\n * @internal\n */\nexport function PayWithCreditCard(props) {\n    return (_jsxs(Container, { bg: \"tertiaryBg\", borderColor: \"borderColor\", flex: \"row\", style: {\n            borderRadius: radius.md,\n            borderBottomRightRadius: 0,\n            borderBottomLeftRadius: 0,\n            borderWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderBottom: \"none\",\n            flexWrap: \"nowrap\",\n            justifyContent: \"space-between\",\n            alignItems: \"center\",\n        }, children: [_jsxs(CurrencyButton, { variant: \"ghost\", onClick: props.onSelectCurrency, style: {\n                    minHeight: \"64px\",\n                    justifyContent: \"flex-start\",\n                    minWidth: \"50%\",\n                }, gap: \"sm\", children: [getFiatIcon(props.currency, \"md\"), _jsxs(Container, { flex: \"row\", center: \"y\", gap: \"xxs\", color: \"secondaryText\", children: [_jsx(Text, { color: \"primaryText\", children: props.currency.shorthand }), _jsx(ChevronDownIcon, { width: iconSize.sm, height: iconSize.sm })] })] }), _jsx(\"div\", { style: {\n                    flexGrow: 1,\n                    flexShrink: 1,\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    alignItems: \"flex-end\",\n                    gap: spacing.xxs,\n                    overflow: \"hidden\",\n                    textOverflow: \"ellipsis\",\n                    whiteSpace: \"nowrap\",\n                    justifyContent: \"center\",\n                    paddingRight: spacing.sm,\n                }, children: props.isLoading ? (_jsx(Skeleton, { width: \"100px\", height: fontSize.lg })) : (_jsx(Text, { size: \"lg\", color: props.value ? \"primaryText\" : \"secondaryText\", children: props.value\n                        ? `${props.currency.symbol}${formatNumber(Number(props.value), 6)}`\n                        : \"--\" })) })] }));\n}\nconst CurrencyButton = /* @__PURE__ */ styled(Button)(() => {\n    return {\n        \"&[disabled]:hover\": {\n            borderColor: \"transparent\",\n        },\n    };\n});\n//# sourceMappingURL=PayWIthCreditCard.js.map","import { jsxs as _jsxs, jsx as _jsx } from \"react/jsx-runtime\";\nimport { formatNumber } from \"../../../../../../../utils/formatNumber.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Container, Line } from \"../../../../components/basic.js\";\nimport { Text } from \"../../../../components/text.js\";\n/**\n * @internal\n */\nexport function SwapFees(props) {\n    return (_jsx(Container, { flex: \"column\", gap: \"xs\", style: {\n            alignItems: \"flex-start\",\n        }, children: props.quote.processingFees.map((fee) => {\n            const feeAmount = formatNumber(Number(fee.amount), 6);\n            return (_jsxs(Container, { flex: \"row\", gap: \"xxs\", children: [_jsxs(Text, { color: \"primaryText\", size: \"sm\", children: [feeAmount === 0 ? \"~\" : \"\", feeAmount, \" \", fee.token.symbol] }), _jsxs(Text, { color: \"secondaryText\", size: \"sm\", children: [\"($\", (fee.amountUSDCents / 100).toFixed(2), \")\"] })] }, `${fee.token.chainId}_${fee.token.tokenAddress}_${feeAmount}`));\n        }) }));\n}\n/**\n * @internal\n */\nexport function FiatFees(props) {\n    return (_jsxs(Container, { flex: \"column\", gap: \"xs\", children: [_jsxs(\"div\", { style: {\n                    display: \"flex\",\n                    justifyContent: \"space-between\",\n                }, children: [_jsx(Text, { inline: true, color: \"secondaryText\", children: \"Amount\" }), _jsxs(Text, { color: \"primaryText\", inline: true, children: [formatNumber(Number(props.quote.fromCurrency.amount), 2), \" \", props.quote.fromCurrency.currencySymbol] })] }), props.quote.processingFees.map((fee, i) => {\n                const feeAmount = formatNumber(Number(fee.amount), 6);\n                return (_jsxs(\"div\", { style: {\n                        display: \"flex\",\n                        justifyContent: \"space-between\",\n                    }, children: [_jsx(Text, { inline: true, color: \"secondaryText\", children: fee.feeType === \"NETWORK\" ? \"Network Fee\" : \"Processing Fee\" }), _jsxs(Text, { color: \"primaryText\", inline: true, children: [feeAmount === 0 ? \"~\" : \"\", \" \", feeAmount, \" \", fee.currencySymbol] })] }, i));\n            }), _jsx(Spacer, { y: \"xxs\" }), _jsx(Line, {}), _jsx(Spacer, { y: \"xxs\" }), _jsxs(\"div\", { style: {\n                    display: \"flex\",\n                    justifyContent: \"space-between\",\n                }, children: [_jsx(Text, { inline: true, color: \"secondaryText\", children: \"Total\" }), _jsxs(Text, { color: \"primaryText\", inline: true, children: [formatNumber(Number(props.quote.fromCurrencyWithFees.amount), 6), \" \", props.quote.fromCurrencyWithFees.currencySymbol] })] })] }));\n}\n//# sourceMappingURL=Fees.js.map","export const FiatProviders = [\"COINBASE\", \"STRIPE\", \"TRANSAK\", \"KADO\"];\n//# sourceMappingURL=commonTypes.js.map","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { FiatProviders, } from \"../../../../../../../pay/utils/commonTypes.js\";\nimport { Container } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Link } from \"../../../../components/text.js\";\n/**\n * @internal\n */\nexport function Providers(props) {\n    return (_jsx(Container, { expand: true, flex: \"column\", gap: \"sm\", style: {\n            alignItems: \"flex-start\",\n        }, children: FiatProviders.map((provider) => {\n            return (_jsx(Container, { flex: \"row\", expand: true, style: {\n                    justifyContent: \"space-between\",\n                }, children: _jsx(Button, { fullWidth: true, onClick: () => props.onSelect(provider), variant: \"link\", children: _jsx(Link, { color: props.preferredProvider === provider\n                            ? \"primaryText\"\n                            : \"secondaryText\", size: \"sm\", hoverColor: \"primaryText\", children: provider.charAt(0).toUpperCase() +\n                            provider.slice(1).toLowerCase() }) }) }, provider));\n        }) }));\n}\n//# sourceMappingURL=Providers.js.map","import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { ChevronDownIcon } from \"@radix-ui/react-icons\";\nimport { useState } from \"react\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { formatNumber } from \"../../../../../../../utils/formatNumber.js\";\nimport { iconSize, spacing, } from \"../../../../../../core/design-system/index.js\";\nimport { useBuyWithFiatQuote } from \"../../../../../../core/hooks/pay/useBuyWithFiatQuote.js\";\nimport { PREFERRED_FIAT_PROVIDER_STORAGE_KEY } from \"../../../../../../core/utils/storage.js\";\nimport { defaultMessage, getErrorMessage, } from \"../../../../../utils/errors.js\";\nimport { Drawer, DrawerOverlay, useDrawer, } from \"../../../../components/Drawer.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Spinner } from \"../../../../components/Spinner.js\";\nimport { Container } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { TokenSymbol } from \"../../../../components/token/TokenSymbol.js\";\nimport { isNativeToken } from \"../../nativeToken.js\";\nimport { EstimatedTimeAndFees } from \"../EstimatedTimeAndFees.js\";\nimport { PayWithCreditCard } from \"../PayWIthCreditCard.js\";\nimport { FiatFees } from \"../swap/Fees.js\";\nimport { Providers } from \"./Providers.js\";\nexport function FiatScreenContent(props) {\n    const { toToken, tokenAmount, payer, client, setScreen, toChain, showCurrencySelector, selectedCurrency, } = props;\n    const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;\n    const receiverAddress = defaultRecipientAddress || props.payer.account.address;\n    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = useDrawer();\n    const [drawerScreen, setDrawerScreen] = useState(\"fees\");\n    const buyWithFiatOptions = props.payOptions.buyWithFiat;\n    const [preferredProvider, setPreferredProvider] = useState(buyWithFiatOptions !== false\n        ? buyWithFiatOptions?.preferredProvider ||\n            (localStorage.getItem(PREFERRED_FIAT_PROVIDER_STORAGE_KEY) ??\n                undefined)\n        : undefined);\n    const fiatQuoteQuery = useBuyWithFiatQuote(buyWithFiatOptions !== false && tokenAmount\n        ? {\n            fromCurrencySymbol: selectedCurrency.shorthand,\n            toChainId: toChain.id,\n            toAddress: receiverAddress,\n            toTokenAddress: isNativeToken(toToken)\n                ? NATIVE_TOKEN_ADDRESS\n                : toToken.address,\n            toAmount: tokenAmount,\n            client,\n            isTestMode: buyWithFiatOptions?.testMode,\n            purchaseData: props.payOptions.purchaseData,\n            fromAddress: payer.account.address,\n            preferredProvider: preferredProvider,\n        }\n        : undefined);\n    function handleSubmit() {\n        if (!fiatQuoteQuery.data) {\n            return;\n        }\n        setScreen({\n            id: \"fiat-flow\",\n            quote: fiatQuoteQuery.data,\n        });\n    }\n    function showFees() {\n        if (!fiatQuoteQuery.data) {\n            return;\n        }\n        setDrawerScreen(\"fees\");\n        setIsOpen(true);\n    }\n    function showProviders() {\n        setDrawerScreen(\"providers\");\n        setIsOpen(true);\n    }\n    const disableSubmit = !fiatQuoteQuery.data;\n    const errorMsg = !fiatQuoteQuery.isLoading && fiatQuoteQuery.error\n        ? getErrorMessage(fiatQuoteQuery.error)\n        : undefined;\n    return (_jsxs(Container, { flex: \"column\", gap: \"lg\", animate: \"fadein\", children: [isOpen && (_jsxs(_Fragment, { children: [_jsx(DrawerOverlay, { ref: drawerOverlayRef }), _jsxs(Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: [drawerScreen === \"fees\" && fiatQuoteQuery.data && (_jsxs(\"div\", { children: [_jsx(Text, { size: \"lg\", color: \"primaryText\", children: \"Fees\" }), _jsx(Spacer, { y: \"lg\" }), _jsx(FiatFees, { quote: fiatQuoteQuery.data })] })), drawerScreen === \"providers\" && (_jsxs(\"div\", { children: [_jsx(Text, { size: \"lg\", color: \"primaryText\", children: \"Providers\" }), _jsx(Spacer, { y: \"lg\" }), _jsx(Providers, { preferredProvider: preferredProvider || fiatQuoteQuery.data?.provider, onSelect: (provider) => {\n                                            setPreferredProvider(provider);\n                                            // save the pref in local storage\n                                            localStorage.setItem(PREFERRED_FIAT_PROVIDER_STORAGE_KEY, provider);\n                                            setIsOpen(false);\n                                        } })] }))] })] })), _jsxs(Container, { flex: \"column\", gap: \"sm\", children: [_jsx(Text, { size: \"sm\", children: \"Pay with credit card\" }), _jsxs(\"div\", { children: [_jsx(PayWithCreditCard, { isLoading: fiatQuoteQuery.isLoading, value: fiatQuoteQuery.data?.fromCurrencyWithFees.amount, client: client, currency: selectedCurrency, onSelectCurrency: showCurrencySelector }), _jsxs(Container, { bg: \"tertiaryBg\", flex: \"row\", borderColor: \"borderColor\", style: {\n                                    paddingLeft: spacing.md,\n                                    justifyContent: \"space-between\",\n                                    alignItems: \"center\",\n                                    borderWidth: \"1px\",\n                                    borderStyle: \"solid\",\n                                    borderBottom: \"none\",\n                                }, children: [_jsx(Text, { size: \"xs\", color: \"secondaryText\", children: \"Provider\" }), _jsx(Button, { variant: \"ghost\", onClick: showProviders, children: _jsxs(Container, { flex: \"row\", center: \"y\", gap: \"xxs\", color: \"secondaryText\", children: [_jsx(Text, { size: \"xs\", children: preferredProvider\n                                                        ? `${preferredProvider.charAt(0).toUpperCase() + preferredProvider.slice(1).toLowerCase()}`\n                                                        : fiatQuoteQuery.data?.provider\n                                                            ? `${fiatQuoteQuery.data?.provider.charAt(0).toUpperCase() + fiatQuoteQuery.data?.provider.slice(1).toLowerCase()}`\n                                                            : \"\" }), _jsx(ChevronDownIcon, { width: iconSize.sm, height: iconSize.sm })] }) })] }), _jsx(EstimatedTimeAndFees, { quoteIsLoading: fiatQuoteQuery.isLoading, estimatedSeconds: fiatQuoteQuery.data?.estimatedDurationSeconds, onViewFees: showFees })] }), errorMsg && (_jsx(\"div\", { children: errorMsg.data?.minimumAmountEth ? (_jsxs(Text, { color: \"danger\", size: \"sm\", center: true, multiline: true, children: [\"Minimum amount is\", \" \", formatNumber(Number(errorMsg.data.minimumAmountEth), 6), \" \", _jsx(TokenSymbol, { token: toToken, chain: toChain, size: \"sm\", inline: true, color: \"danger\" })] })) : (_jsx(Text, { color: \"danger\", size: \"sm\", center: true, multiline: true, children: errorMsg.message || defaultMessage })) }))] }), errorMsg?.data?.minimumAmountEth ? (_jsx(Button, { variant: \"accent\", fullWidth: true, onClick: () => {\n                    props.setTokenAmount(formatNumber(Number(errorMsg.data?.minimumAmountEth), 6).toString());\n                    props.setHasEditedAmount(true);\n                }, children: \"Set Minimum\" })) : (_jsx(Button, { variant: disableSubmit ? \"outline\" : \"accent\", \"data-disabled\": disableSubmit, disabled: disableSubmit, fullWidth: true, onClick: handleSubmit, gap: \"xs\", children: fiatQuoteQuery.isLoading ? (_jsxs(_Fragment, { children: [\"Getting price quote\", _jsx(Spinner, { size: \"sm\", color: \"accentText\" })] })) : (\"Continue\") }))] }));\n}\n//# sourceMappingURL=FiatScreenContent.js.map","import { getAddress } from \"../../utils/address.js\";\n/**\n * Check if a Swap is required after on-ramp when buying a token with fiat currency.\n *\n * If `quote.toToken` and `quote.onRampToken` are the same (same token and chain),\n * it means on-ramp provider can directly send the desired token to the user's wallet and no swap is required.\n *\n * If `quote.toToken` and `quote.onRampToken` are different (different token or chain), A swap is required to swap the on-ramp token to the desired token.\n *\n * @param buyWithFiatQuote - The quote of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote) returned\n * by the [`getBuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithFiatQuote) function.\n * @buyCrypto\n */\nexport function isSwapRequiredPostOnramp(buyWithFiatQuote) {\n    const sameChain = buyWithFiatQuote.toToken.chainId ===\n        buyWithFiatQuote.onRampToken.token.chainId;\n    const sameToken = getAddress(buyWithFiatQuote.toToken.tokenAddress) ===\n        getAddress(buyWithFiatQuote.onRampToken.token.tokenAddress);\n    return !(sameChain && sameToken);\n}\nexport function getOnRampSteps(buyWithFiatQuote) {\n    const isSwapRequired = isSwapRequiredPostOnramp(buyWithFiatQuote);\n    if (!isSwapRequired) {\n        return [\n            {\n                action: \"buy\",\n                token: buyWithFiatQuote.toToken,\n                amount: buyWithFiatQuote.estimatedToAmountMin,\n            },\n        ];\n    }\n    if (buyWithFiatQuote.routingToken) {\n        return [\n            {\n                action: \"buy\",\n                token: buyWithFiatQuote.onRampToken.token,\n                amount: buyWithFiatQuote.onRampToken.amount,\n            },\n            {\n                action: \"swap\",\n                token: buyWithFiatQuote.routingToken.token,\n                amount: buyWithFiatQuote.routingToken.amount,\n            },\n            {\n                action: \"bridge\",\n                token: buyWithFiatQuote.toToken,\n                amount: buyWithFiatQuote.estimatedToAmountMin,\n            },\n        ];\n    }\n    return [\n        {\n            action: \"buy\",\n            token: buyWithFiatQuote.onRampToken.token,\n            amount: buyWithFiatQuote.onRampToken.amount,\n        },\n        {\n            action: \"swap\",\n            token: buyWithFiatQuote.toToken,\n            amount: buyWithFiatQuote.estimatedToAmountMin,\n        },\n    ];\n}\n//# sourceMappingURL=isSwapRequiredPostOnramp.js.map","export function openOnrampPopup(link, theme) {\n    const height = 750;\n    const width = 500;\n    const top = (window.innerHeight - height) / 2;\n    const left = (window.innerWidth - width) / 2;\n    return window.open(`${link}&theme=${theme}`, \"thirdweb Pay\", `width=${width}, height=${height}, top=${top}, left=${left}`);\n}\n//# sourceMappingURL=openOnRamppopup.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { trackPayEvent } from \"../../../../../../../analytics/track/pay.js\";\nimport { getCachedChain } from \"../../../../../../../chains/utils.js\";\nimport { getContract } from \"../../../../../../../contract/contract.js\";\nimport { allowance } from \"../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../../../../../../extensions/erc20/write/approve.js\";\nimport { getBuyWithCryptoQuote } from \"../../../../../../../pay/buyWithCrypto/getQuote.js\";\nimport { getBuyWithFiatStatus, } from \"../../../../../../../pay/buyWithFiat/getStatus.js\";\nimport { getOnRampSteps, } from \"../../../../../../../pay/buyWithFiat/isSwapRequiredPostOnramp.js\";\nimport { sendBatchTransaction } from \"../../../../../../../transaction/actions/send-batch-transaction.js\";\nimport { sendTransaction } from \"../../../../../../../transaction/actions/send-transaction.js\";\nimport { waitForReceipt } from \"../../../../../../../transaction/actions/wait-for-tx-receipt.js\";\nimport { formatNumber } from \"../../../../../../../utils/formatNumber.js\";\nimport { isEcosystemWallet } from \"../../../../../../../wallets/ecosystem/is-ecosystem-wallet.js\";\nimport { isInAppWallet } from \"../../../../../../../wallets/in-app/core/wallet/index.js\";\nimport { isSmartWallet } from \"../../../../../../../wallets/smart/is-smart-wallet.js\";\nimport { spacing } from \"../../../../../../core/design-system/index.js\";\nimport { useChainName } from \"../../../../../../core/hooks/others/useChainQuery.js\";\nimport { useBuyWithCryptoStatus } from \"../../../../../../core/hooks/pay/useBuyWithCryptoStatus.js\";\nimport { useBuyWithFiatStatus } from \"../../../../../../core/hooks/pay/useBuyWithFiatStatus.js\";\nimport { useConnectedWallets } from \"../../../../../../core/hooks/wallets/useConnectedWallets.js\";\nimport { invalidateWalletBalance } from \"../../../../../../core/providers/invalidateWalletBalance.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Spinner } from \"../../../../components/Spinner.js\";\nimport { SwitchNetworkButton } from \"../../../../components/SwitchNetwork.js\";\nimport { Container, ModalHeader } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { TokenSymbol } from \"../../../../components/token/TokenSymbol.js\";\nimport { PayTokenIcon } from \"../PayTokenIcon.js\";\nimport { openOnrampPopup } from \"../openOnRamppopup.js\";\nimport { StepConnectorArrow } from \"../swap/StepConnector.js\";\nimport { WalletRow } from \"../swap/WalletRow.js\";\nimport { addPendingTx } from \"../swap/pendingSwapTx.js\";\nimport { StepContainer } from \"./FiatSteps.js\";\nexport function OnRampScreen(props) {\n    const connectedWallets = useConnectedWallets();\n    const isAutoMode = isInAppSigner({\n        wallet: props.payer.wallet,\n        connectedWallets,\n    });\n    const state = useOnRampScreenState({\n        quote: props.quote,\n        client: props.client,\n        onSuccess: props.onSuccess,\n        onDone: props.onDone,\n        payer: props.payer,\n        theme: props.theme,\n        isAutoMode,\n    });\n    const firstStepChainId = state.steps[0]?.step.token.chainId;\n    return (_jsxs(Container, { p: \"lg\", children: [_jsx(ModalHeader, { title: props.title, onBack: props.onBack }), _jsx(Spacer, { y: \"xl\" }), _jsx(Container, { flex: \"column\", gap: \"xs\", center: \"y\", style: {\n                    paddingLeft: spacing.md,\n                }, children: _jsx(WalletRow, { client: props.client, address: props.receiverAddress, iconSize: \"md\", textSize: \"sm\", label: \"Recipient wallet\" }) }), _jsx(Spacer, { y: \"md\" }), _jsx(Container, { flex: \"column\", children: state.steps.map(({ step, status }, index) => (_jsxs(Container, { flex: \"column\", children: [_jsx(StepContainer, { state: status, index: index, style: {\n                                flex: \"1\",\n                            }, children: _jsx(StepUI, { step: step, client: props.client, payer: props.payer, index: index }) }), index < state.steps.length - 1 && _jsx(StepConnectorArrow, {})] }, step.action))) }), _jsx(Spacer, { y: \"md\" }), _jsx(Text, { size: \"xs\", color: \"secondaryText\", center: true, style: { padding: `0 ${spacing.xl}` }, children: \"Keep this window open until all transactions are complete.\" }), _jsx(Spacer, { y: \"lg\" }), _jsx(Container, { flex: \"column\", gap: \"md\", children: !state.isDone &&\n                    firstStepChainId &&\n                    firstStepChainId !== props.payer.chain.id ? (_jsx(SwitchNetworkButton, { fullWidth: true, variant: \"accent\", switchChain: async () => {\n                        await props.payer.wallet.switchChain(getCachedChain(firstStepChainId));\n                    } })) : (_jsxs(Button, { variant: \"accent\", gap: \"sm\", fullWidth: true, onClick: state.handleContinue, disabled: state.isLoading, children: [state.isLoading\n                            ? \"Processing\"\n                            : state.isDone\n                                ? props.transactionMode\n                                    ? \"Continue Transaction\"\n                                    : \"Done\"\n                                : state.isFailed\n                                    ? \"Retry\"\n                                    : \"Continue\", state.isLoading && _jsx(Spinner, { size: \"sm\", color: \"primaryText\" })] })) })] }));\n}\nfunction StepUI(props) {\n    const { step, client } = props;\n    const chain = useChainName(getCachedChain(step.token.chainId));\n    return (_jsx(Container, { flex: \"column\", gap: \"xs\", py: \"3xs\", children: _jsxs(Container, { flex: \"row\", center: \"y\", gap: \"sm\", style: {\n                display: \"flex\",\n                justifyContent: \"space-between\",\n                flexWrap: \"nowrap\",\n            }, children: [_jsx(PayTokenIcon, { chain: getCachedChain(step.token.chainId), client: client, size: \"md\", token: {\n                        address: step.token.tokenAddress,\n                    } }), _jsxs(Container, { flex: \"column\", gap: \"3xs\", center: \"y\", style: { flex: \"1\" }, children: [_jsx(Text, { size: \"sm\", color: \"primaryText\", children: step.action.charAt(0).toUpperCase() + step.action.slice(1) }), _jsxs(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: {\n                                display: \"flex\",\n                                justifyContent: \"space-between\",\n                                flexWrap: \"nowrap\",\n                            }, children: [_jsxs(Container, { flex: \"row\", gap: \"xxs\", center: \"y\", style: {\n                                        flex: \"1 1 60%\",\n                                        minWidth: 0,\n                                        maxWidth: \"60%\",\n                                        overflow: \"hidden\",\n                                        flexWrap: \"nowrap\",\n                                    }, children: [_jsx(Text, { size: \"sm\", color: \"primaryText\", children: formatNumber(Number(step.amount), 5) }), _jsx(TokenSymbol, { token: {\n                                                address: step.token.tokenAddress,\n                                                name: step.token.name || \"\",\n                                                symbol: step.token.symbol || \"\",\n                                            }, chain: getCachedChain(step.token.chainId), size: \"sm\", color: \"secondaryText\" })] }), _jsx(Container, { flex: \"row\", gap: \"xs\", center: \"y\", style: {\n                                        flex: \"1 1 40%\",\n                                        maxWidth: \"40%\",\n                                        minWidth: 0,\n                                        justifyContent: \"flex-end\",\n                                        flexWrap: \"nowrap\",\n                                    }, children: _jsx(Text, { size: \"xs\", style: {\n                                            overflow: \"hidden\",\n                                            textOverflow: \"ellipsis\",\n                                            whiteSpace: \"nowrap\",\n                                        }, children: chain.name }) })] })] })] }) }));\n}\nfunction useOnRampScreenState(props) {\n    const onRampSteps = getOnRampSteps(props.quote);\n    const [currentStepIndex, setCurrentStepIndex] = useState(0);\n    const [swapTxHash, setSwapTxHash] = useState();\n    const [popupWindow, setPopupWindow] = useState(null);\n    // Track onramp status\n    const { uiStatus: fiatOnrampStatus } = useOnRampStatus({\n        intentId: props.quote.intentId,\n        client: props.client,\n        onSuccess: (status) => {\n            if (onRampSteps.length === 1) {\n                // If only one step, this is the final success\n                props.onSuccess(status);\n            }\n            else {\n                // Move to next step (swap)\n                setCurrentStepIndex((prev) => prev + 1);\n            }\n        },\n        openedWindow: popupWindow,\n    });\n    // Get quote for current swap/bridge step if needed\n    const previousStep = onRampSteps[currentStepIndex - 1];\n    const currentStep = onRampSteps[currentStepIndex];\n    // Handle swap execution\n    const swapMutation = useSwapMutation({\n        client: props.client,\n        payer: props.payer,\n        isFiatFlow: true,\n    });\n    // Track swap status\n    const { uiStatus: swapStatus } = useSwapStatus({\n        client: props.client,\n        transactionHash: swapTxHash?.hash,\n        chainId: swapTxHash?.chainId,\n        onSuccess: () => {\n            if (currentStepIndex === onRampSteps.length - 1) {\n                // Last step completed - call final success\n                getBuyWithFiatStatus({\n                    intentId: props.quote.intentId,\n                    client: props.client,\n                }).then(props.onSuccess);\n            }\n            else {\n                // Reset swap state before moving to next step\n                setSwapTxHash(undefined);\n                swapMutation.reset();\n                // Move to next step\n                setCurrentStepIndex((prev) => prev + 1);\n            }\n        },\n    });\n    // Map steps to their current status\n    const steps = onRampSteps.map((step, index) => {\n        let status = \"unknown\";\n        if (index === 0) {\n            // First step (onramp) status\n            status = fiatOnrampStatus;\n        }\n        else if (index < currentStepIndex) {\n            // Previous steps are completed\n            status = \"completed\";\n        }\n        else if (index === currentStepIndex) {\n            // Current step - could be swap or bridge\n            if (swapMutation.isPending) {\n                status = \"pending\";\n            }\n            else if (swapMutation.error) {\n                status = \"failed\";\n            }\n            else if (swapTxHash) {\n                status = swapStatus;\n            }\n            else {\n                status = \"actionRequired\";\n            }\n        }\n        return {\n            index,\n            step,\n            status,\n        };\n    });\n    const isLoading = steps.some((step) => step.status === \"pending\");\n    const isDone = steps.every((step) => step.status === \"completed\");\n    const isFailed = steps.some((step) => step.status === \"failed\");\n    // Update handleContinue to handle done state\n    const handleContinue = useCallback(async () => {\n        if (isDone) {\n            props.onDone();\n            return;\n        }\n        if (currentStepIndex === 0) {\n            // First step - open onramp popup\n            const popup = openOnrampPopup(props.quote.onRampLink, props.theme);\n            trackPayEvent({\n                event: \"open_onramp_popup\",\n                client: props.client,\n                walletAddress: props.payer.account.address,\n                walletType: props.payer.wallet.id,\n            });\n            setPopupWindow(popup);\n            addPendingTx({\n                type: \"fiat\",\n                intentId: props.quote.intentId,\n            });\n        }\n        else if (previousStep && currentStep && !swapTxHash) {\n            // Execute swap/bridge\n            try {\n                const result = await swapMutation.mutateAsync({\n                    fromToken: previousStep.token,\n                    toToken: currentStep.token,\n                    amount: currentStep.amount,\n                });\n                setSwapTxHash({\n                    hash: result.transactionHash,\n                    chainId: result.chainId,\n                });\n            }\n            catch (e) {\n                console.error(\"Failed to execute swap:\", e);\n            }\n        }\n        else if (isFailed) {\n            // retry the quote step\n            setSwapTxHash(undefined);\n            swapMutation.reset();\n        }\n    }, [\n        isDone,\n        currentStepIndex,\n        swapTxHash,\n        props.quote,\n        props.onDone,\n        swapMutation,\n        props.theme,\n        isFailed,\n        swapMutation.reset,\n        props.client,\n        props.payer.account.address,\n        props.payer.wallet.id,\n        currentStep,\n        previousStep,\n    ]);\n    // Auto-progress effect\n    useEffect(() => {\n        if (!props.isAutoMode) {\n            return;\n        }\n        // Auto-start next swap step when previous step completes\n        if (!isLoading &&\n            !isDone &&\n            !isFailed &&\n            currentStepIndex > 0 &&\n            currentStepIndex < onRampSteps.length &&\n            !swapTxHash) {\n            handleContinue();\n        }\n    }, [\n        props.isAutoMode,\n        currentStepIndex,\n        swapTxHash,\n        onRampSteps.length,\n        handleContinue,\n        isDone,\n        isFailed,\n        isLoading,\n    ]);\n    return {\n        steps,\n        handleContinue,\n        isLoading,\n        isDone,\n        isFailed,\n    };\n}\nfunction useOnRampStatus(props) {\n    const queryClient = useQueryClient();\n    const statusQuery = useBuyWithFiatStatus({\n        intentId: props.intentId,\n        client: props.client,\n        queryOptions: {\n            enabled: !!props.openedWindow,\n        },\n    });\n    let uiStatus = \"actionRequired\";\n    switch (statusQuery.data?.status) {\n        case \"ON_RAMP_TRANSFER_COMPLETED\":\n        case \"CRYPTO_SWAP_COMPLETED\":\n        case \"CRYPTO_SWAP_REQUIRED\":\n            uiStatus = \"completed\";\n            break;\n        case \"CRYPTO_SWAP_FALLBACK\":\n            uiStatus = \"partialSuccess\";\n            break;\n        case \"ON_RAMP_TRANSFER_FAILED\":\n        case \"PAYMENT_FAILED\":\n            uiStatus = \"failed\";\n            break;\n        case \"PENDING_PAYMENT\":\n        case \"ON_RAMP_TRANSFER_IN_PROGRESS\":\n            uiStatus = \"pending\";\n            break;\n        default:\n            uiStatus = \"actionRequired\";\n            break;\n    }\n    const purchaseCbCalled = useRef(false);\n    useEffect(() => {\n        if (purchaseCbCalled.current || !props.onSuccess) {\n            return;\n        }\n        if (statusQuery.data &&\n            (uiStatus === \"completed\" || uiStatus === \"partialSuccess\")) {\n            purchaseCbCalled.current = true;\n            props.onSuccess(statusQuery.data);\n        }\n    }, [props.onSuccess, statusQuery.data, uiStatus]);\n    // close the onramp popup if onramp is completed\n    useEffect(() => {\n        if (!props.openedWindow) {\n            return;\n        }\n        if (uiStatus === \"completed\" || uiStatus === \"partialSuccess\") {\n            try {\n                if (props.openedWindow && !props.openedWindow.closed) {\n                    props.openedWindow.close();\n                }\n            }\n            catch (e) {\n                console.warn(\"Failed to close payment window:\", e);\n            }\n        }\n    }, [props.openedWindow, uiStatus]);\n    // invalidate wallet balance when onramp is completed\n    const invalidatedBalance = useRef(false);\n    useEffect(() => {\n        if (!invalidatedBalance.current && uiStatus === \"completed\") {\n            invalidatedBalance.current = true;\n            invalidateWalletBalance(queryClient);\n        }\n    }, [uiStatus, queryClient]);\n    return { uiStatus };\n}\nfunction useSwapStatus(props) {\n    const swapStatus = useBuyWithCryptoStatus(props.transactionHash && props.chainId\n        ? {\n            client: props.client,\n            transactionHash: props.transactionHash,\n            chainId: props.chainId,\n        }\n        : undefined);\n    let uiStatus = \"unknown\";\n    switch (swapStatus.data?.status) {\n        case \"COMPLETED\":\n            uiStatus = \"completed\";\n            break;\n        case \"FAILED\":\n        case \"NOT_FOUND\":\n            uiStatus = \"failed\";\n            break;\n        case \"PENDING\":\n            uiStatus = \"pending\";\n            break;\n        case \"NONE\":\n            uiStatus = \"unknown\";\n            break;\n        default:\n            uiStatus = \"unknown\";\n            break;\n    }\n    const purchaseCbCalled = useRef(false);\n    useEffect(() => {\n        if (purchaseCbCalled.current || !props.onSuccess) {\n            return;\n        }\n        if (swapStatus.data?.status === \"COMPLETED\") {\n            purchaseCbCalled.current = true;\n            props.onSuccess(swapStatus.data);\n        }\n    }, [props.onSuccess, swapStatus]);\n    const queryClient = useQueryClient();\n    const balanceInvalidated = useRef(false);\n    useEffect(() => {\n        if (uiStatus === \"completed\" && !balanceInvalidated.current) {\n            balanceInvalidated.current = true;\n            invalidateWalletBalance(queryClient);\n        }\n    }, [queryClient, uiStatus]);\n    return { uiStatus };\n}\nfunction useSwapMutation(props) {\n    const queryClient = useQueryClient();\n    return useMutation({\n        mutationFn: async (input) => {\n            const { fromToken, toToken, amount } = input;\n            const wallet = props.payer.wallet;\n            // in case the wallet is not on the same chain as the fromToken, switch to it\n            if (wallet.getChain()?.id !== fromToken.chainId) {\n                await wallet.switchChain(getCachedChain(fromToken.chainId));\n            }\n            const account = wallet.getAccount();\n            if (!account) {\n                throw new Error(\"Payer wallet has no account\");\n            }\n            // always get a fresh quote before executing\n            const quote = await getBuyWithCryptoQuote({\n                fromChainId: fromToken.chainId,\n                fromTokenAddress: fromToken.tokenAddress,\n                toAmount: amount,\n                toChainId: toToken.chainId,\n                toTokenAddress: toToken.tokenAddress,\n                fromAddress: account.address,\n                toAddress: account.address,\n                client: props.client,\n            });\n            const canBatch = account.sendBatchTransaction;\n            const tokenContract = getContract({\n                client: props.client,\n                address: quote.swapDetails.fromToken.tokenAddress,\n                chain: getCachedChain(quote.swapDetails.fromToken.chainId),\n            });\n            const approveTxRequired = quote.approvalData &&\n                (await allowance({\n                    contract: tokenContract,\n                    owner: account.address,\n                    spender: quote.approvalData.spenderAddress,\n                })) < BigInt(quote.approvalData.amountWei);\n            if (approveTxRequired && quote.approvalData && !canBatch) {\n                trackPayEvent({\n                    event: \"prompt_swap_approval\",\n                    client: props.client,\n                    walletAddress: account.address,\n                    walletType: props.payer.wallet.id,\n                    fromToken: quote.swapDetails.fromToken.tokenAddress,\n                    fromAmount: quote.swapDetails.fromAmountWei,\n                    toToken: quote.swapDetails.toToken.tokenAddress,\n                    toAmount: quote.swapDetails.toAmountWei,\n                    chainId: quote.swapDetails.fromToken.chainId,\n                    dstChainId: quote.swapDetails.toToken.chainId,\n                });\n                const transaction = approve({\n                    contract: tokenContract,\n                    spender: quote.approvalData.spenderAddress,\n                    amountWei: BigInt(quote.approvalData.amountWei),\n                });\n                const tx = await sendTransaction({\n                    account,\n                    transaction,\n                });\n                await waitForReceipt({ ...tx, maxBlocksWaitTime: 50 });\n                trackPayEvent({\n                    event: \"swap_approval_success\",\n                    client: props.client,\n                    walletAddress: account.address,\n                    walletType: props.payer.wallet.id,\n                    fromToken: quote.swapDetails.fromToken.tokenAddress,\n                    fromAmount: quote.swapDetails.fromAmountWei,\n                    toToken: quote.swapDetails.toToken.tokenAddress,\n                    toAmount: quote.swapDetails.toAmountWei,\n                    chainId: quote.swapDetails.fromToken.chainId,\n                    dstChainId: quote.swapDetails.toToken.chainId,\n                });\n            }\n            trackPayEvent({\n                event: \"prompt_swap_execution\",\n                client: props.client,\n                walletAddress: account.address,\n                walletType: props.payer.wallet.id,\n                fromToken: quote.swapDetails.fromToken.tokenAddress,\n                fromAmount: quote.swapDetails.fromAmountWei,\n                toToken: quote.swapDetails.toToken.tokenAddress,\n                toAmount: quote.swapDetails.toAmountWei,\n                chainId: quote.swapDetails.fromToken.chainId,\n                dstChainId: quote.swapDetails.toToken.chainId,\n            });\n            const tx = quote.transactionRequest;\n            let _swapTx;\n            // check if we can batch approval and swap\n            if (canBatch && quote.approvalData && approveTxRequired) {\n                const approveTx = approve({\n                    contract: tokenContract,\n                    spender: quote.approvalData.spenderAddress,\n                    amountWei: BigInt(quote.approvalData.amountWei),\n                });\n                _swapTx = await sendBatchTransaction({\n                    account,\n                    transactions: [approveTx, tx],\n                });\n            }\n            else {\n                _swapTx = await sendTransaction({\n                    account,\n                    transaction: tx,\n                });\n            }\n            await waitForReceipt({ ..._swapTx, maxBlocksWaitTime: 50 });\n            trackPayEvent({\n                event: \"swap_execution_success\",\n                client: props.client,\n                walletAddress: account.address,\n                walletType: props.payer.wallet.id,\n                fromToken: quote.swapDetails.fromToken.tokenAddress,\n                fromAmount: quote.swapDetails.fromAmountWei,\n                toToken: quote.swapDetails.toToken.tokenAddress,\n                toAmount: quote.swapDetails.toAmountWei,\n                chainId: quote.swapDetails.fromToken.chainId,\n                dstChainId: quote.swapDetails.toToken.chainId,\n            });\n            // do not add pending tx if the swap is part of fiat flow\n            if (!props.isFiatFlow) {\n                addPendingTx({\n                    type: \"swap\",\n                    txHash: _swapTx.transactionHash,\n                    chainId: _swapTx.chain.id,\n                });\n            }\n            return {\n                transactionHash: _swapTx.transactionHash,\n                chainId: _swapTx.chain.id,\n            };\n        },\n        onSuccess: () => {\n            invalidateWalletBalance(queryClient);\n        },\n    });\n}\nfunction isInAppSigner(options) {\n    const isInAppOrEcosystem = (w) => isInAppWallet(w) || isEcosystemWallet(w);\n    const isSmartWalletWithAdmin = isSmartWallet(options.wallet) &&\n        options.connectedWallets.some((w) => isInAppOrEcosystem(w) &&\n            w.getAccount()?.address?.toLowerCase() ===\n                options.wallet.getAdminAccount?.()?.address?.toLowerCase());\n    return isInAppOrEcosystem(options.wallet) || isSmartWalletWithAdmin;\n}\n//# sourceMappingURL=OnRampScreen.js.map","import { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { isNativeToken } from \"../../nativeToken.js\";\nexport function useEnabledPaymentMethods(options) {\n    const { payOptions, supportedDestinations, toChain, toToken } = options;\n    function getEnabledPayMethodsForSelectedToken() {\n        const chain = supportedDestinations.find((c) => c.chain.id === toChain.id);\n        if (!chain) {\n            return {\n                fiat: false,\n                swap: false,\n            };\n        }\n        const toTokenAddress = isNativeToken(toToken)\n            ? NATIVE_TOKEN_ADDRESS\n            : toToken.address;\n        const tokenInfo = chain.tokens.find((t) => t.address.toLowerCase() === toTokenAddress.toLowerCase());\n        if (!tokenInfo) {\n            return {\n                fiat: true,\n                swap: true,\n            };\n        }\n        return {\n            fiat: tokenInfo.buyWithFiatEnabled,\n            swap: tokenInfo.buyWithCryptoEnabled,\n        };\n    }\n    const { fiat, swap } = getEnabledPayMethodsForSelectedToken();\n    const buyWithFiatEnabled = payOptions.buyWithFiat !== false && fiat;\n    const buyWithCryptoEnabled = payOptions.buyWithCrypto !== false && swap;\n    return {\n        buyWithFiatEnabled,\n        buyWithCryptoEnabled,\n    };\n}\n//# sourceMappingURL=useEnabledPaymentMethods.js.map","import { defineChain } from \"../utils.js\";\n/**\n * @chain\n */\nexport const polygon = /*@__PURE__*/ defineChain({\n    id: 137,\n    name: \"Polygon\",\n    nativeCurrency: { name: \"POL\", symbol: \"POL\", decimals: 18 },\n    blockExplorers: [\n        {\n            name: \"PolygonScan\",\n            url: \"https://polygonscan.com\",\n            apiUrl: \"https://api.polygonscan.com/api\",\n        },\n    ],\n});\n//# sourceMappingURL=polygon.js.map","import { useEffect, useState } from \"react\";\nimport { polygon } from \"../../../../../../../chains/chain-definitions/polygon.js\";\nimport { useActiveWalletChain } from \"../../../../../../core/hooks/wallets/useActiveWalletChain.js\";\nimport { useDebouncedValue } from \"../../../../hooks/useDebouncedValue.js\";\nimport { NATIVE_TOKEN } from \"../../nativeToken.js\";\nimport { currencies, usdCurrency, } from \"../fiat/currencies.js\";\n// handle states for token and chain selection\nexport function useToTokenSelectionStates(options) {\n    const { payOptions, supportedDestinations } = options;\n    // --------------------------------------------------------------------------\n    // buy token amount ---------------------------------------------------------\n    // NOTE - for transaction / direct payment modes, the token amount is set when the user tap continue\n    const prefillBuy = payOptions?.prefillBuy;\n    const activeChain = useActiveWalletChain();\n    const initialTokenAmount = prefillBuy?.amount || \"\";\n    const [tokenAmount, setTokenAmount] = useState(initialTokenAmount);\n    const deferredTokenAmount = useDebouncedValue(tokenAmount, 300);\n    useEffect(() => {\n        if (prefillBuy?.amount) {\n            setTokenAmount(prefillBuy.amount);\n        }\n        if (prefillBuy?.chain) {\n            setToChain(prefillBuy.chain);\n        }\n        if (prefillBuy?.token) {\n            setToToken(prefillBuy.token);\n        }\n    }, [prefillBuy?.amount, prefillBuy?.chain, prefillBuy?.token]);\n    // Destination chain and token selection -----------------------------------\n    const [toChain, setToChain] = useState(\n    // use prefill chain if available\n    prefillBuy?.chain ||\n        (payOptions.mode === \"transaction\" && payOptions.transaction?.chain) ||\n        (payOptions.mode === \"direct_payment\" && payOptions.paymentInfo?.chain) ||\n        // use active chain if its supported as destination\n        supportedDestinations.find((x) => x.chain.id === activeChain?.id)\n            ?.chain ||\n        // default to the first chain in supportedDestinations, or polygon if nothing is found at all\n        supportedDestinations[0]?.chain ||\n        polygon);\n    const [toToken, setToToken] = useState(prefillBuy?.token ||\n        (payOptions.mode === \"direct_payment\" && payOptions.paymentInfo.token) ||\n        NATIVE_TOKEN);\n    return {\n        toChain,\n        setToChain,\n        toToken,\n        setToToken,\n        tokenAmount,\n        setTokenAmount,\n        deferredTokenAmount,\n    };\n}\nexport function useFromTokenSelectionStates(options) {\n    const { payOptions } = options;\n    // TODO (pay) - auto select token based on connected wallet balances\n    // Source token and chain selection ---------------------------------------------------\n    const [fromChain_, setFromChain] = useState();\n    // use prefill chain if available\n    const fromChainDevSpecified = (payOptions.buyWithCrypto !== false &&\n        payOptions.buyWithCrypto?.prefillSource?.chain) ||\n        (payOptions.mode === \"transaction\" && payOptions.transaction?.chain) ||\n        (payOptions.mode === \"direct_payment\" && payOptions.paymentInfo?.chain);\n    const fromChain = fromChain_ || fromChainDevSpecified || undefined;\n    const [fromToken_, setFromToken] = useState();\n    // use prefill token if available\n    const fromTokenDevSpecified = (payOptions.buyWithCrypto !== false &&\n        payOptions.buyWithCrypto?.prefillSource?.token) ||\n        (payOptions.mode === \"direct_payment\" && payOptions.paymentInfo.token);\n    // supported tokens query in here\n    const fromToken = fromToken_ || fromTokenDevSpecified || undefined;\n    return {\n        fromChain,\n        setFromChain,\n        fromToken,\n        setFromToken,\n    };\n}\nexport function useFiatCurrencySelectionStates(options) {\n    const { payOptions } = options;\n    // --------------------------------------------------------------------------\n    const devSpecifiedDefaultCurrency = payOptions.buyWithFiat !== false\n        ? payOptions.buyWithFiat?.prefillSource?.currency\n        : undefined;\n    const defaultSelectedCurrencyShorthand = devSpecifiedDefaultCurrency || getDefaultCurrencyBasedOnLocation();\n    const [selectedCurrency, setSelectedCurrency] = useState(currencies.find((x) => x.shorthand === defaultSelectedCurrencyShorthand) ||\n        usdCurrency);\n    return {\n        selectedCurrency,\n        setSelectedCurrency,\n    };\n}\nfunction getDefaultCurrencyBasedOnLocation() {\n    // if Intl is not supported - browser throws\n    try {\n        const timeZone = Intl.DateTimeFormat()\n            .resolvedOptions()\n            .timeZone.toLowerCase();\n        // Europe/London -> GBP\n        if (timeZone.includes(\"london\")) {\n            return \"GBP\";\n        }\n        // Europe/* -> EUR\n        if (timeZone.includes(\"europe\")) {\n            return \"EUR\";\n        }\n        // Japan\n        if (timeZone.includes(\"japan\")) {\n            return \"JPY\";\n        }\n        // canada\n        if (timeZone.includes(\"canada\")) {\n            return \"CAD\";\n        }\n        // australia\n        if (timeZone.includes(\"australia\")) {\n            return \"AUD\";\n        }\n        // new zealand\n        if (timeZone.includes(\"new zealand\")) {\n            return \"NZD\";\n        }\n        return \"USD\";\n    }\n    catch {\n        return \"USD\";\n    }\n}\n//# sourceMappingURL=useUISelectionStates.js.map","export function getBuyTokenAmountFontSize(value) {\n    return value.length > 10 ? \"26px\" : value.length > 6 ? \"34px\" : \"50px\";\n}\n//# sourceMappingURL=utils.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { convertCryptoToFiat } from \"../../../../../../../pay/convert/cryptoToFiat.js\";\nimport { formatNumber } from \"../../../../../../../utils/formatNumber.js\";\nimport { fontSize } from \"../../../../../../core/design-system/index.js\";\nimport { Skeleton } from \"../../../../components/Skeleton.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { useDebouncedValue } from \"../../../../hooks/useDebouncedValue.js\";\nimport { getTokenAddress } from \"../../nativeToken.js\";\nexport function FiatValue(props) {\n    const deferredTokenAmount = useDebouncedValue(props.tokenAmount, 500);\n    const cryptoToFiatQuery = useQuery({\n        queryKey: [\n            \"cryptoToFiat\",\n            props.chain.id,\n            getTokenAddress(props.token),\n            deferredTokenAmount,\n        ],\n        queryFn: () => convertCryptoToFiat({\n            client: props.client,\n            chain: props.chain,\n            fromTokenAddress: getTokenAddress(props.token),\n            fromAmount: Number(deferredTokenAmount),\n            to: \"USD\",\n        }),\n    });\n    if (cryptoToFiatQuery.isLoading) {\n        return _jsx(Skeleton, { width: \"50px\", height: fontSize.lg });\n    }\n    return cryptoToFiatQuery.data?.result ? (_jsxs(Text, { ...props, children: [\"$\", formatNumber(cryptoToFiatQuery.data.result, 2).toFixed(2)] })) : null;\n}\n//# sourceMappingURL=FiatValue.js.map","import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { fontSize } from \"../../../../../../core/design-system/index.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Container } from \"../../../../components/basic.js\";\nimport { Input } from \"../../../../components/formElements.js\";\nimport { TokenRow } from \"../../../../components/token/TokenRow.js\";\nimport { TokenSymbol } from \"../../../../components/token/TokenSymbol.js\";\nimport { getBuyTokenAmountFontSize } from \"../utils.js\";\nimport { FiatValue } from \"./FiatValue.js\";\n/**\n * @internal\n */\nexport function BuyTokenInput(props) {\n    const getWidth = () => {\n        let chars = props.value.replace(\".\", \"\").length;\n        const hasDot = props.value.includes(\".\");\n        if (hasDot) {\n            chars += 0.3;\n        }\n        return `calc(${`${Math.max(1, chars)}ch`} + 6px)`;\n    };\n    return (_jsxs(Container, { children: [_jsx(\"div\", { onClick: (e) => {\n                    e.currentTarget.querySelector(\"input\")?.focus();\n                }, children: _jsxs(Container, { flex: \"row\", center: \"both\", gap: \"xs\", style: {\n                        flexWrap: \"nowrap\",\n                    }, children: [_jsx(Input, { variant: \"outline\", pattern: \"^[0-9]*[.,]?[0-9]*$\", inputMode: \"decimal\", tabIndex: -1, placeholder: \"0\", type: \"text\", \"data-placeholder\": props.value === \"\", value: props.value || \"0\", disabled: props.freezeAmount, onClick: (e) => {\n                                // put cursor at the end of the input\n                                if (props.value === \"\") {\n                                    e.currentTarget.setSelectionRange(e.currentTarget.value.length, e.currentTarget.value.length);\n                                }\n                            }, onChange: (e) => {\n                                let value = e.target.value;\n                                // Replace comma with period if it exists\n                                value = value.replace(\",\", \".\");\n                                if (value.startsWith(\".\")) {\n                                    value = `0${value}`;\n                                }\n                                const numValue = Number(value);\n                                if (Number.isNaN(numValue)) {\n                                    return;\n                                }\n                                if (value.startsWith(\"0\") && !value.startsWith(\"0.\")) {\n                                    props.onChange(value.slice(1));\n                                }\n                                else {\n                                    props.onChange(value);\n                                }\n                            }, style: {\n                                border: \"none\",\n                                fontSize: getBuyTokenAmountFontSize(props.value),\n                                boxShadow: \"none\",\n                                borderRadius: \"0\",\n                                padding: \"0\",\n                                paddingBlock: \"2px\",\n                                fontWeight: 600,\n                                textAlign: \"right\",\n                                width: getWidth(),\n                                maxWidth: \"calc(100% - 100px)\",\n                            } }), _jsx(TokenSymbol, { token: props.token, chain: props.chain, size: \"lg\", color: \"secondaryText\" })] }) }), _jsx(Container, { flex: \"row\", center: \"both\", style: {\n                    height: fontSize.xl,\n                }, children: _jsx(FiatValue, { tokenAmount: props.value, token: props.token, chain: props.chain, client: props.client, size: \"md\" }) }), !props.hideTokenSelector && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: \"md\" }), _jsx(Container, { flex: \"row\", center: \"x\", children: _jsx(TokenRow, { token: props.token, chain: props.chain, client: props.client, onSelectToken: props.onSelectToken, freezeChainAndToken: props.freezeChainAndToken }) })] }))] }));\n}\n//# sourceMappingURL=BuyTokenInput.js.map","import { useQuery, } from \"@tanstack/react-query\";\nimport { getBuyWithCryptoQuote, } from \"../../../../pay/buyWithCrypto/getQuote.js\";\n/**\n * Hook to get a price quote for performing a \"Buy with crypto\" transaction that allows users to buy a token with another token - aka a swap.\n *\n * The price quote is an object of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote).\n * This quote contains the information about the purchase such as token amounts, processing fees, estimated time etc.\n *\n * This hook is a React Query wrapper of the [`getBuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoQuote) function.\n * You can also use that function directly\n *\n * Once you have the quote, you can use the [`useSendTransaction`](https://portal.thirdweb.com/references/typescript/v5/useSendTransaction) function to send the purchase\n * and [`useBuyWithCryptoStatus`](https://portal.thirdweb.com/references/typescript/v5/useBuyWithCryptoStatus) function to get the status of the swap transaction.\n * @param params - object of type [`BuyWithCryptoQuoteQueryParams`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuoteQueryParams)\n * @param queryParams - options to configure the react query\n * @returns A React Query object which contains the data of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote)\n * @example\n * ```tsx\n * import { useBuyWithCryptoQuote, useBuyWithCryptoStatus, type BuyWithCryptoStatusQueryParams, useActiveAccount } from \"thirdweb/react\";\n * import { sendTransaction } from 'thirdweb';\n *\n * function Component() {\n *  const buyWithCryptoQuoteQuery = useBuyWithCryptoQuote(swapParams);\n *  const [buyTxHash, setBuyTxHash] = useState<BuyWithCryptoStatusQueryParams | undefined>();\n *  const buyWithCryptoStatusQuery = useBuyWithCryptoStatus(buyTxHash ? {\n *    client,\n *    transactionHash: buyTxHash,\n *  }: undefined);\n *\n *  async function handleBuyWithCrypto() {\n *    const account = useActiveAccount();\n *\n *    // if approval is required\n *    if (buyWithCryptoQuoteQuery.data.approval) {\n *      const approveTx = await sendTransaction({\n *        transaction: swapQuote.data.approval,\n *        account: account,\n *      });\n *      await waitForApproval(approveTx);\n *    }\n *\n *    // send the transaction to buy crypto\n *    // this promise is resolved when user confirms the transaction in the wallet and the transaction is sent to the blockchain\n *    const buyTx = await sendTransaction({\n *      transaction: swapQuote.data.transactionRequest,\n *      account: account,\n *    });\n *    await waitForApproval(buyTx);\n *\n *    // set buyTx.transactionHash to poll the status of the swap transaction\n *    setBuyWithCryptoTx(buyTx.transactionHash);\n *  }\n *\n *  return <button onClick={handleBuyWithCrypto}>Swap</button>\n * }\n * ```\n * @buyCrypto\n */\nexport function useBuyWithCryptoQuote(params, queryParams) {\n    return useQuery({\n        ...queryParams,\n        queryKey: [\"buyWithCryptoQuote\", params],\n        refetchInterval: 20_000,\n        queryFn: () => {\n            if (!params) {\n                throw new Error(\"Swap params are required\");\n            }\n            return getBuyWithCryptoQuote(params);\n        },\n        enabled: !!params,\n        retry: false,\n    });\n}\n//# sourceMappingURL=useBuyWithCryptoQuote.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useCustomTheme } from \"../../../../../../core/design-system/CustomThemeProvider.js\";\nimport { fontSize, radius, spacing, } from \"../../../../../../core/design-system/index.js\";\nimport { useWalletBalance } from \"../../../../../../core/hooks/others/useWalletBalance.js\";\nimport { Skeleton } from \"../../../../components/Skeleton.js\";\nimport { Container } from \"../../../../components/basic.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { TokenRow } from \"../../../../components/token/TokenRow.js\";\nimport { TokenSymbol } from \"../../../../components/token/TokenSymbol.js\";\nimport { formatTokenBalance } from \"../../formatTokenBalance.js\";\nimport { isNativeToken } from \"../../nativeToken.js\";\nimport { WalletRow } from \"./WalletRow.js\";\n/**\n * Shows an amount \"value\" and renders the selected token and chain\n * It also renders the buttons to select the token and chain\n * It also renders the balance of active wallet for the selected token in selected chain\n * @internal\n */\nexport function PayWithCryptoQuoteInfo(props) {\n    const theme = useCustomTheme();\n    const balanceQuery = useWalletBalance({\n        address: props.payerAccount.address,\n        chain: props.chain,\n        tokenAddress: isNativeToken(props.token)\n            ? undefined\n            : props.token?.address,\n        client: props.client,\n    }, {\n        enabled: !!props.chain && !!props.token,\n    });\n    return (_jsxs(Container, { bg: \"tertiaryBg\", style: {\n            borderRadius: radius.lg,\n            border: `1px solid ${theme.colors.borderColor}`,\n            ...(props.swapRequired\n                ? {\n                    borderBottom: \"none\",\n                    borderBottomLeftRadius: 0,\n                    borderBottomRightRadius: 0,\n                }\n                : {}),\n        }, children: [_jsxs(Container, { flex: \"row\", gap: \"sm\", style: {\n                    justifyContent: \"space-between\",\n                    padding: spacing.sm,\n                    borderBottom: `1px solid ${theme.colors.borderColor}`,\n                }, children: [_jsx(WalletRow, { client: props.client, address: props.payerAccount.address }), props.token && props.chain && balanceQuery.data ? (_jsxs(Container, { flex: \"row\", gap: \"3xs\", center: \"y\", children: [_jsx(Text, { size: \"xs\", color: \"secondaryText\", weight: 500, children: formatTokenBalance(balanceQuery.data, false, 4) }), _jsx(TokenSymbol, { token: props.token, chain: props.chain, size: \"xs\", color: \"secondaryText\" })] })) : props.token && props.chain && balanceQuery.isLoading ? (_jsx(Skeleton, { width: \"70px\", height: fontSize.xs })) : null] }), _jsx(TokenRow, { token: props.token, chain: props.chain, client: props.client, isLoading: props.isLoading, value: props.value, onSelectToken: props.onSelectToken, style: {\n                    border: \"none\",\n                    borderRadius: 0,\n                    borderBottomLeftRadius: !props.token || !props.chain || !props.swapRequired ? radius.lg : 0,\n                    borderBottomRightRadius: !props.token || !props.chain || !props.swapRequired ? radius.lg : 0,\n                } })] }));\n}\n//# sourceMappingURL=PayWithCrypto.js.map","import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useState } from \"react\";\nimport { getCachedChain } from \"../../../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../../../contract/contract.js\";\nimport { allowance } from \"../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { formatNumber } from \"../../../../../../../utils/formatNumber.js\";\nimport { useWalletBalance } from \"../../../../../../core/hooks/others/useWalletBalance.js\";\nimport { useBuyWithCryptoQuote } from \"../../../../../../core/hooks/pay/useBuyWithCryptoQuote.js\";\nimport { defaultMessage, getErrorMessage, } from \"../../../../../utils/errors.js\";\nimport { Drawer, DrawerOverlay, useDrawer, } from \"../../../../components/Drawer.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Spinner } from \"../../../../components/Spinner.js\";\nimport { SwitchNetworkButton } from \"../../../../components/SwitchNetwork.js\";\nimport { Container } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { TokenSymbol } from \"../../../../components/token/TokenSymbol.js\";\nimport { isNativeToken } from \"../../nativeToken.js\";\nimport { EstimatedTimeAndFees } from \"../EstimatedTimeAndFees.js\";\nimport { SwapFees } from \"./Fees.js\";\nimport { PayWithCryptoQuoteInfo } from \"./PayWithCrypto.js\";\nexport function SwapScreenContent(props) {\n    const { setScreen, payer, client, toChain, tokenAmount, toToken, fromChain, fromToken, payOptions, disableTokenSelection, } = props;\n    const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;\n    const receiverAddress = defaultRecipientAddress || props.activeAccount.address;\n    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = useDrawer();\n    const [drawerScreen, setDrawerScreen] = useState(\"fees\");\n    const fromTokenBalanceQuery = useWalletBalance({\n        address: payer.account.address,\n        chain: fromChain,\n        tokenAddress: isNativeToken(fromToken) ? undefined : fromToken?.address,\n        client,\n    }, {\n        enabled: !!fromChain && !!fromToken,\n    });\n    const fromTokenId = isNativeToken(fromToken)\n        ? NATIVE_TOKEN_ADDRESS\n        : fromToken?.address?.toLowerCase();\n    const toTokenId = isNativeToken(toToken)\n        ? NATIVE_TOKEN_ADDRESS\n        : toToken.address.toLowerCase();\n    const swapRequired = !!tokenAmount &&\n        !!fromChain &&\n        !!fromTokenId &&\n        !(fromChain?.id === toChain.id && fromTokenId === toTokenId);\n    const quoteParams = fromChain && fromToken && swapRequired\n        ? {\n            // wallets\n            fromAddress: payer.account.address,\n            toAddress: receiverAddress,\n            // from\n            fromChainId: fromChain.id,\n            fromTokenAddress: isNativeToken(fromToken)\n                ? NATIVE_TOKEN_ADDRESS\n                : fromToken.address,\n            // to\n            toChainId: toChain.id,\n            toTokenAddress: isNativeToken(toToken)\n                ? NATIVE_TOKEN_ADDRESS\n                : toToken.address,\n            toAmount: tokenAmount,\n            client,\n            purchaseData: payOptions.purchaseData,\n        }\n        : undefined;\n    const quoteQuery = useBuyWithCryptoQuote(quoteParams, {\n        // refetch every 30 seconds\n        staleTime: 30 * 1000,\n        refetchInterval: 30 * 1000,\n        gcTime: 30 * 1000,\n    });\n    const allowanceQuery = useQuery({\n        queryKey: [\n            \"allowance\",\n            payer.account.address,\n            quoteQuery.data?.approvalData,\n        ],\n        queryFn: () => {\n            if (!quoteQuery.data?.approvalData) {\n                return null;\n            }\n            return allowance({\n                contract: getContract({\n                    client: props.client,\n                    address: quoteQuery.data.swapDetails.fromToken.tokenAddress,\n                    chain: getCachedChain(quoteQuery.data.swapDetails.fromToken.chainId),\n                }),\n                spender: quoteQuery.data.approvalData.spenderAddress,\n                owner: props.payer.account.address,\n            });\n        },\n        enabled: !!quoteQuery.data?.approvalData,\n        refetchOnMount: true,\n    });\n    const sourceTokenAmount = swapRequired\n        ? quoteQuery.data?.swapDetails.fromAmount\n        : tokenAmount;\n    const isNotEnoughBalance = !!sourceTokenAmount &&\n        !!fromTokenBalanceQuery.data &&\n        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);\n    const disableContinue = !fromChain ||\n        !fromToken ||\n        (swapRequired && !quoteQuery.data) ||\n        isNotEnoughBalance ||\n        allowanceQuery.isLoading;\n    const switchChainRequired = props.payer.wallet.getChain()?.id !== fromChain?.id;\n    const errorMsg = !quoteQuery.isLoading && quoteQuery.error\n        ? getErrorMessage(quoteQuery.error)\n        : undefined;\n    function showSwapFlow() {\n        if ((props.payOptions.mode === \"direct_payment\" ||\n            props.payOptions.mode === \"fund_wallet\") &&\n            !isNotEnoughBalance &&\n            !swapRequired) {\n            // same currency, just direct transfer\n            setScreen({\n                id: \"transfer-flow\",\n            });\n        }\n        else if (props.payOptions.mode === \"transaction\" &&\n            !isNotEnoughBalance &&\n            !swapRequired) {\n            if (payer.account.address !== receiverAddress) {\n                // needs transfer from another wallet before executing the transaction\n                setScreen({\n                    id: \"transfer-flow\",\n                });\n            }\n            else {\n                // has enough balance to just do the transaction directly\n                props.onDone();\n            }\n            return;\n        }\n        if (!quoteQuery.data) {\n            return;\n        }\n        setScreen({\n            id: \"swap-flow\",\n            quote: quoteQuery.data,\n            approvalAmount: allowanceQuery.data ?? undefined,\n        });\n    }\n    function showFees() {\n        if (!quoteQuery.data) {\n            return;\n        }\n        setIsOpen(true);\n        setDrawerScreen(\"fees\");\n    }\n    return (_jsxs(Container, { flex: \"column\", gap: \"lg\", animate: \"fadein\", children: [isOpen && (_jsxs(_Fragment, { children: [_jsx(DrawerOverlay, { ref: drawerOverlayRef }), _jsx(Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: drawerScreen === \"fees\" && quoteQuery.data && (_jsxs(\"div\", { children: [_jsx(Text, { size: \"lg\", color: \"primaryText\", children: \"Fees\" }), _jsx(Spacer, { y: \"lg\" }), _jsx(SwapFees, { quote: quoteQuery.data })] })) })] })), _jsxs(Container, { flex: \"column\", gap: \"sm\", children: [_jsxs(Container, { flex: \"row\", gap: \"xxs\", center: \"y\", children: [_jsx(Text, { size: \"sm\", children: \"Pay with\" }), fromToken && fromChain ? (_jsx(TokenSymbol, { token: fromToken, chain: fromChain, size: \"sm\", color: \"secondaryText\" })) : (\"crypto\")] }), _jsxs(\"div\", { children: [_jsx(PayWithCryptoQuoteInfo, { value: sourceTokenAmount || \"\", chain: fromChain, token: fromToken, isLoading: quoteQuery.isLoading && !sourceTokenAmount, client: client, freezeChainAndTokenSelection: disableTokenSelection, payerAccount: props.payer.account, swapRequired: swapRequired, onSelectToken: props.showFromTokenSelector }), swapRequired && fromChain && fromToken && (_jsx(EstimatedTimeAndFees, { quoteIsLoading: quoteQuery.isLoading, estimatedSeconds: quoteQuery.data?.swapDetails.estimated.durationSeconds, onViewFees: showFees }))] }), errorMsg && (_jsx(\"div\", { children: errorMsg.data?.minimumAmountEth ? (_jsxs(Text, { color: \"danger\", size: \"xs\", center: true, multiline: true, children: [\"Minimum amount is\", \" \", formatNumber(Number(errorMsg.data.minimumAmountEth), 6), \" \", _jsx(TokenSymbol, { token: toToken, chain: toChain, size: \"sm\", inline: true, color: \"danger\" })] })) : (_jsx(Text, { color: \"danger\", size: \"xs\", center: true, multiline: true, children: errorMsg.message || defaultMessage })) })), !errorMsg && isNotEnoughBalance && (_jsx(\"div\", { children: _jsx(Text, { color: \"danger\", size: \"xs\", center: true, multiline: true, children: \"Insufficient funds\" }) }))] }), errorMsg?.data?.minimumAmountEth ? (_jsx(Button, { variant: \"accent\", fullWidth: true, onClick: () => {\n                    props.setTokenAmount(formatNumber(Number(errorMsg.data?.minimumAmountEth), 6).toString());\n                    props.setHasEditedAmount(true);\n                }, children: \"Set Minimum\" })) : isNotEnoughBalance || errorMsg ? (_jsx(Button, { variant: \"accent\", fullWidth: true, onClick: () => props.showFromTokenSelector(), children: \"Pay with another token\" })) : switchChainRequired &&\n                fromChain &&\n                !quoteQuery.isLoading &&\n                !allowanceQuery.isLoading &&\n                !isNotEnoughBalance &&\n                !quoteQuery.error ? (_jsx(SwitchNetworkButton, { variant: \"accent\", fullWidth: true, switchChain: async () => {\n                    await props.payer.wallet.switchChain(fromChain);\n                } })) : (_jsx(Button, { variant: disableContinue ? \"outline\" : \"accent\", fullWidth: true, \"data-disabled\": disableContinue, disabled: disableContinue, onClick: async () => {\n                    if (!disableContinue) {\n                        showSwapFlow();\n                    }\n                }, gap: \"xs\", children: quoteQuery.isLoading ? (_jsxs(_Fragment, { children: [\"Getting price quote\", _jsx(Spinner, { size: \"sm\", color: \"accentText\" })] })) : (\"Continue\") }))] }));\n}\n//# sourceMappingURL=SwapScreenContent.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport styled from \"@emotion/styled\";\nimport { CardStackIcon, ChevronRightIcon, Cross2Icon, } from \"@radix-ui/react-icons\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getCachedChain } from \"../../../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { getWalletBalance, } from \"../../../../../../../wallets/utils/getWalletBalance.js\";\nimport { useCustomTheme } from \"../../../../../../core/design-system/CustomThemeProvider.js\";\nimport { iconSize, radius, spacing, } from \"../../../../../../core/design-system/index.js\";\nimport { useChainMetadata, useChainName, } from \"../../../../../../core/hooks/others/useChainQuery.js\";\nimport { useActiveAccount } from \"../../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { useConnectedWallets } from \"../../../../../../core/hooks/wallets/useConnectedWallets.js\";\nimport { useDisconnect } from \"../../../../../../core/hooks/wallets/useDisconnect.js\";\nimport { LoadingScreen } from \"../../../../../wallets/shared/LoadingScreen.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { TextDivider } from \"../../../../components/TextDivider.js\";\nimport { TokenIcon } from \"../../../../components/TokenIcon.js\";\nimport { Container } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { OutlineWalletIcon } from \"../../../icons/OutlineWalletIcon.js\";\nimport { formatTokenBalance } from \"../../formatTokenBalance.js\";\nimport { isNativeToken } from \"../../nativeToken.js\";\nimport { FiatValue } from \"./FiatValue.js\";\nimport { WalletRow } from \"./WalletRow.js\";\nexport function TokenSelectorScreen(props) {\n    const connectedWallets = useConnectedWallets();\n    const activeAccount = useActiveAccount();\n    const chainInfo = useChainMetadata(props.toChain);\n    const theme = useCustomTheme();\n    const walletsAndBalances = useQuery({\n        queryKey: [\n            \"wallets-and-balances\",\n            props.sourceSupportedTokens,\n            props.toChain.id,\n            props.toToken,\n            props.tokenAmount,\n            props.mode,\n            activeAccount?.address,\n            connectedWallets.map((w) => w.getAccount()?.address),\n        ],\n        queryFn: async () => {\n            // in parallel, get the balances of all the wallets on each of the sourceSupportedTokens\n            const walletBalanceMap = new Map();\n            const balancePromises = connectedWallets.flatMap((wallet) => {\n                const account = wallet.getAccount();\n                if (!account)\n                    return [];\n                const walletKey = {\n                    id: wallet.id,\n                    address: account.address,\n                };\n                walletBalanceMap.set(walletKey, []);\n                // inject the destination token too since it can be used as well to pay/transfer\n                const toToken = isNativeToken(props.toToken)\n                    ? {\n                        address: NATIVE_TOKEN_ADDRESS,\n                        name: chainInfo.data?.nativeCurrency.name || \"\",\n                        symbol: chainInfo.data?.nativeCurrency.symbol || \"\",\n                        icon: chainInfo.data?.icon?.url,\n                    }\n                    : props.toToken;\n                const tokens = {\n                    ...props.sourceSupportedTokens,\n                    [props.toChain.id]: [\n                        toToken,\n                        ...(props.sourceSupportedTokens?.[props.toChain.id] || []),\n                    ],\n                };\n                return Object.entries(tokens).flatMap(([chainId, tokens]) => {\n                    return tokens.map(async (token) => {\n                        try {\n                            const chain = getCachedChain(Number(chainId));\n                            const balance = await getWalletBalance({\n                                address: account.address,\n                                chain,\n                                tokenAddress: isNativeToken(token) ? undefined : token.address,\n                                client: props.client,\n                            });\n                            // show the token if:\n                            // - its not the destination token and balance is greater than 0\n                            // - its the destination token and balance is greater than the token amount AND we the account is not the default account in fund_wallet mode\n                            const shouldInclude = token.address === toToken.address &&\n                                chain.id === props.toChain.id\n                                ? props.mode === \"fund_wallet\" &&\n                                    account.address === activeAccount?.address\n                                    ? false\n                                    : Number(balance.displayValue) > Number(props.tokenAmount)\n                                : balance.value > 0n;\n                            if (shouldInclude) {\n                                const existingBalances = walletBalanceMap.get(walletKey) || [];\n                                existingBalances.push({ balance, chain, token });\n                                existingBalances.sort((a, b) => {\n                                    if (a.chain.id === props.toChain.id &&\n                                        a.token.address === toToken.address)\n                                        return -1;\n                                    if (b.chain.id === props.toChain.id &&\n                                        b.token.address === toToken.address)\n                                        return 1;\n                                    if (a.chain.id === props.toChain.id)\n                                        return -1;\n                                    if (b.chain.id === props.toChain.id)\n                                        return 1;\n                                    return a.chain.id > b.chain.id ? 1 : -1;\n                                });\n                            }\n                        }\n                        catch (error) {\n                            console.error(`Failed to fetch balance for wallet ${wallet.id} on chain ${chainId} for token ${token.symbol}:`, error);\n                        }\n                    });\n                });\n            });\n            await Promise.all(balancePromises);\n            return walletBalanceMap;\n        },\n        enabled: !!props.sourceSupportedTokens && !!chainInfo.data,\n    });\n    if (walletsAndBalances.isLoading || !walletsAndBalances.data) {\n        return _jsx(LoadingScreen, {});\n    }\n    const filteredWallets = Array.from(walletsAndBalances.data.entries() || [])\n        .filter(([w]) => !props.hiddenWallets?.includes(w.id))\n        .filter(([, balances]) => {\n        const hasEnoughBalance = balances.some((b) => b.balance.value > 0);\n        return hasEnoughBalance;\n    });\n    return (_jsxs(Container, { animate: \"fadein\", style: {\n            minHeight: \"200px\",\n        }, children: [filteredWallets.length === 0 ? (_jsx(Container, { flex: \"column\", gap: \"xs\", py: \"lg\", children: _jsxs(Text, { size: \"xs\", color: \"secondaryText\", center: true, children: [\"No suitable payment token found\", _jsx(\"br\", {}), \"in connected wallets\"] }) })) : (_jsxs(Container, { flex: \"column\", gap: \"xs\", children: [_jsx(Text, { size: \"sm\", children: \"Select payment token\" }), _jsx(Spacer, { y: \"xs\" })] })), _jsx(Container, { scrollY: true, style: {\n                    maxHeight: \"350px\",\n                }, children: _jsxs(Container, { flex: \"column\", gap: \"sm\", children: [filteredWallets.map(([w, balances]) => {\n                            const address = w.address;\n                            const wallet = connectedWallets.find((w) => w.getAccount()?.address === address);\n                            if (!wallet)\n                                return null;\n                            return (_jsx(WalletRowWithBalances, { wallet: wallet, balances: balances, client: props.client, address: address, onClick: props.onSelectToken }, w.id));\n                        }), filteredWallets.length > 0 && _jsx(TextDivider, { text: \"OR\" }), _jsx(Button, { variant: \"secondary\", fullWidth: true, onClick: props.onConnect, bg: \"tertiaryBg\", style: {\n                                border: `1px solid ${theme.colors.borderColor}`,\n                                padding: spacing.sm,\n                            }, children: _jsxs(Container, { flex: \"row\", gap: \"sm\", center: \"y\", expand: true, color: \"secondaryIconColor\", children: [_jsx(OutlineWalletIcon, { size: iconSize.md }), _jsx(Text, { size: \"sm\", color: \"primaryText\", children: \"Pay with another wallet\" })] }) }), props.fiatSupported && (_jsx(Button, { variant: \"secondary\", fullWidth: true, onClick: props.onPayWithFiat, bg: \"tertiaryBg\", style: {\n                                border: `1px solid ${theme.colors.borderColor}`,\n                                padding: spacing.sm,\n                            }, children: _jsxs(Container, { flex: \"row\", gap: \"sm\", center: \"y\", expand: true, color: \"secondaryIconColor\", children: [_jsx(CardStackIcon, { width: iconSize.md, height: iconSize.md }), _jsx(Text, { size: \"sm\", color: \"primaryText\", children: \"Pay with credit card\" })] }) }))] }) })] }));\n}\nfunction WalletRowWithBalances(props) {\n    const theme = useCustomTheme();\n    const displayedBalances = props.balances;\n    const activeAccount = useActiveAccount();\n    const { disconnect } = useDisconnect();\n    const isActiveAccount = activeAccount?.address === props.address;\n    return (_jsxs(Container, { flex: \"column\", style: {\n            borderRadius: radius.lg,\n            border: `1px solid ${theme.colors.borderColor}`,\n        }, children: [_jsxs(Container, { flex: \"row\", gap: \"sm\", bg: \"tertiaryBg\", style: {\n                    justifyContent: \"space-between\",\n                    borderTopRightRadius: radius.lg,\n                    borderTopLeftRadius: radius.lg,\n                    padding: spacing.sm,\n                    paddingRight: spacing.xs,\n                    borderBottom: `1px solid ${theme.colors.borderColor}`,\n                }, children: [_jsx(WalletRow, { ...props }), !isActiveAccount && (_jsx(Button, { variant: \"ghost\", onClick: () => disconnect(props.wallet), style: {\n                            padding: spacing.xxs,\n                            color: theme.colors.secondaryText,\n                        }, children: _jsx(Cross2Icon, { width: iconSize.sm, height: iconSize.sm }) }))] }), _jsx(Container, { flex: \"column\", children: props.balances.length > 0 ? (displayedBalances.map((b, idx) => (_jsx(TokenBalanceRow, { client: props.client, onClick: () => props.onClick(props.wallet, b.token, b.chain), tokenBalance: b, wallet: props.wallet, style: {\n                        borderTopLeftRadius: 0,\n                        borderTopRightRadius: 0,\n                        borderBottomRightRadius: idx === displayedBalances.length - 1 ? radius.lg : 0,\n                        borderBottomLeftRadius: idx === displayedBalances.length - 1 ? radius.lg : 0,\n                        borderBottom: idx === displayedBalances.length - 1\n                            ? \"none\"\n                            : `1px solid ${theme.colors.borderColor}`,\n                    } }, `${b.token.address}-${b.chain.id}`)))) : (_jsx(Container, { style: { padding: spacing.sm }, children: _jsx(Text, { size: \"sm\", color: \"secondaryText\", children: \"Insufficient funds\" }) })) })] }));\n}\nfunction TokenBalanceRow(props) {\n    const { tokenBalance, wallet, onClick, client, style } = props;\n    const chainInfo = useChainName(tokenBalance.chain);\n    return (_jsxs(StyledButton, { onClick: () => onClick(tokenBalance.token, wallet), variant: \"secondary\", style: {\n            ...style,\n            display: \"flex\",\n            justifyContent: \"space-between\",\n            minWidth: 0, // Needed for text truncation to work\n        }, children: [_jsxs(Container, { flex: \"row\", center: \"y\", gap: \"sm\", style: {\n                    flex: \"1 1 50%\",\n                    minWidth: 0,\n                    maxWidth: \"50%\",\n                    overflow: \"hidden\",\n                    flexWrap: \"nowrap\",\n                }, children: [_jsx(TokenIcon, { token: tokenBalance.token, chain: tokenBalance.chain, size: \"md\", client: client }), _jsxs(Container, { flex: \"column\", gap: \"4xs\", style: { minWidth: 0 }, children: [_jsx(Text, { size: \"xs\", color: \"primaryText\", style: {\n                                    overflow: \"hidden\",\n                                    textOverflow: \"ellipsis\",\n                                    whiteSpace: \"nowrap\",\n                                }, children: tokenBalance.token.symbol }), chainInfo && (_jsx(Text, { size: \"xs\", style: {\n                                    overflow: \"hidden\",\n                                    textOverflow: \"ellipsis\",\n                                    whiteSpace: \"nowrap\",\n                                }, children: chainInfo.name }))] })] }), _jsxs(Container, { flex: \"row\", center: \"y\", gap: \"4xs\", color: \"secondaryText\", style: {\n                    flex: \"1 1 50%\",\n                    maxWidth: \"50%\",\n                    minWidth: 0,\n                    justifyContent: \"flex-end\",\n                    flexWrap: \"nowrap\",\n                }, children: [_jsxs(Container, { flex: \"column\", color: \"secondaryText\", gap: \"4xs\", style: {\n                            alignItems: \"flex-end\",\n                            minWidth: 0,\n                            overflow: \"hidden\",\n                        }, children: [_jsx(Text, { size: \"xs\", color: \"primaryText\", style: {\n                                    overflow: \"hidden\",\n                                    textOverflow: \"ellipsis\",\n                                    whiteSpace: \"nowrap\",\n                                }, children: formatTokenBalance(tokenBalance.balance, true, 2) }), _jsx(FiatValue, { tokenAmount: tokenBalance.balance.displayValue, token: tokenBalance.token, chain: tokenBalance.chain, client: client, size: \"xs\" })] }), _jsx(ChevronRightIcon, { width: iconSize.md, height: iconSize.md, style: { flexShrink: 0 } })] })] }));\n}\nconst StyledButton = /* @__PURE__ */ styled(Button)((props) => {\n    const theme = useCustomTheme();\n    return {\n        background: \"transparent\",\n        justifyContent: \"space-between\",\n        flexWrap: \"nowrap\",\n        flexDirection: \"row\",\n        padding: spacing.sm,\n        paddingRight: spacing.xs,\n        gap: spacing.sm,\n        \"&:hover\": {\n            background: theme.colors.secondaryButtonBg,\n            transform: \"scale(1.01)\",\n        },\n        transition: \"background 200ms ease, transform 150ms ease\",\n        ...props.style,\n    };\n});\n//# sourceMappingURL=TokenSelectorScreen.js.map","import { getCachedChain } from \"../../chains/utils.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { getPayBuyWithCryptoTransferEndpoint } from \"../utils/definitions.js\";\n/**\n * Get a quote of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) to facilitate a token transfer transaction.\n * Using this instead of a native transfer allows you to receive status and webhooks about successful or failed payments.\n *\n * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.\n * @param params - object of type [`GetBuyWithCryptoTransferParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoTransferParams)\n * @returns Object of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) which contains the information about the transfer\n * @example\n *\n * ```ts\n * import { getBuyWithCryptoTransfer } from \"thirdweb/pay\";\n *\n * const transfer = await getBuyWithCryptoTransfer({\n *  client,\n *  fromAddress: \"0x...\", // wallet address\n *  toAddress: \"0x...\", // recipient address - likely to be your wallet\n *  chainId: 10, // chain id of the token\n *  tokenAddress: \"0x...\", // address of the token\n *  amount: \"10\", // amount of token to transfer\n *  purchaseData: {  // any metadata for you to attribute this purchase\n *    \"customerId\": \"yourId\"\n *  }\n * });\n * ```\n * @buyCrypto\n */\nexport async function getBuyWithCryptoTransfer(params) {\n    try {\n        const clientFetch = getClientFetch(params.client);\n        const response = await clientFetch(getPayBuyWithCryptoTransferEndpoint(), {\n            method: \"POST\",\n            headers: {\n                Accept: \"application/json\",\n                \"Content-Type\": \"application/json\",\n            },\n            body: stringify({\n                fromAddress: params.fromAddress,\n                toAddress: params.toAddress,\n                chainId: params.chainId,\n                tokenAddress: params.tokenAddress,\n                amount: params.amount,\n                purchaseData: params.purchaseData,\n            }),\n        });\n        if (!response.ok) {\n            const errorObj = await response.json();\n            if (errorObj && \"error\" in errorObj) {\n                throw errorObj;\n            }\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = (await response.json()).result;\n        const transfer = {\n            transactionRequest: {\n                chain: getCachedChain(data.transactionRequest.chainId),\n                client: params.client,\n                data: data.transactionRequest.data,\n                to: data.transactionRequest.to,\n                value: BigInt(data.transactionRequest.value),\n                gas: BigInt(data.transactionRequest.gasLimit),\n            },\n            approvalData: data.approval,\n            fromAddress: data.fromAddress,\n            toAddress: data.toAddress,\n            paymentToken: data.paymentToken,\n            processingFee: data.processingFee,\n            estimatedGasCostUSDCents: data.estimatedGasCostUSDCents,\n            client: params.client,\n        };\n        return transfer;\n    }\n    catch (error) {\n        console.error(\"Error getting buy with crypto transfer\", error);\n        throw error;\n    }\n}\n//# sourceMappingURL=getTransfer.js.map","import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { CheckCircledIcon } from \"@radix-ui/react-icons\";\nimport { useState } from \"react\";\nimport { getCachedChain } from \"../../../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../../../contract/contract.js\";\nimport { allowance } from \"../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { getCurrencyMetadata, } from \"../../../../../../../extensions/erc20/read/getCurrencyMetadata.js\";\nimport { approve } from \"../../../../../../../extensions/erc20/write/approve.js\";\nimport { transfer } from \"../../../../../../../extensions/erc20/write/transfer.js\";\nimport { getBuyWithCryptoTransfer } from \"../../../../../../../pay/buyWithCrypto/getTransfer.js\";\nimport { sendAndConfirmTransaction } from \"../../../../../../../transaction/actions/send-and-confirm-transaction.js\";\nimport { sendTransaction } from \"../../../../../../../transaction/actions/send-transaction.js\";\nimport { prepareTransaction } from \"../../../../../../../transaction/prepare-transaction.js\";\nimport { toWei } from \"../../../../../../../utils/units.js\";\nimport { iconSize } from \"../../../../../../core/design-system/index.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Spinner } from \"../../../../components/Spinner.js\";\nimport { StepBar } from \"../../../../components/StepBar.js\";\nimport { SwitchNetworkButton } from \"../../../../components/SwitchNetwork.js\";\nimport { Container, ModalHeader } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { isNativeToken } from \"../../nativeToken.js\";\nimport { Step } from \"../Stepper.js\";\nimport { ConnectorLine } from \"./ConfirmationScreen.js\";\nimport { SwapSummary } from \"./SwapSummary.js\";\nexport function TransferConfirmationScreen(props) {\n    const { title, onBack, receiverAddress, client, payer, onDone, chain, token, tokenAmount, transactionMode, setTransactionHash, payOptions, } = props;\n    const [step, setStep] = useState(\"transfer\");\n    const [status, setStatus] = useState({ id: \"idle\" });\n    return (_jsxs(Container, { p: \"lg\", children: [_jsx(ModalHeader, { title: title, onBack: onBack }), _jsx(Spacer, { y: \"xl\" }), transactionMode ? (_jsxs(_Fragment, { children: [_jsx(StepBar, { steps: 2, currentStep: step === \"transfer\" ? 1 : 2 }), _jsx(Spacer, { y: \"sm\" }), _jsx(Text, { size: \"sm\", children: step === \"transfer\"\n                            ? \"Step 1 of 2 - Transfer funds\"\n                            : \"Step 2 of 2 - Finalize transaction\" }), _jsx(Spacer, { y: \"md\" })] })) : (_jsxs(_Fragment, { children: [_jsx(Text, { size: \"sm\", children: \"Confirm payment\" }), _jsx(Spacer, { y: \"md\" })] })), _jsx(SwapSummary, { sender: payer.account.address, receiver: receiverAddress, client: client, fromToken: token, fromChain: chain, toToken: token, toChain: chain, fromAmount: tokenAmount, toAmount: tokenAmount }), _jsx(Spacer, { y: \"lg\" }), transactionMode && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: \"sm\" }), _jsxs(Container, { gap: \"sm\", flex: \"row\", style: {\n                            justifyContent: \"space-between\",\n                        }, center: \"y\", color: \"accentText\", children: [_jsx(Step, { isDone: step === \"execute\", isActive: step === \"transfer\", label: step === \"transfer\" ? \"Transfer\" : \"Done\" }), _jsx(ConnectorLine, {}), _jsx(Step, { isDone: false, label: \"Finalize\", isActive: step === \"execute\" })] }), _jsx(Spacer, { y: \"lg\" })] })), status.id === \"error\" && (_jsxs(_Fragment, { children: [_jsx(Container, { flex: \"row\", gap: \"xs\", center: \"both\", color: \"danger\", children: _jsx(Text, { color: \"danger\", size: \"sm\", style: { textAlign: \"center\" }, children: step === \"transfer\"\n                                ? `${status.error || \"Failed to Transfer\"}`\n                                : \"Failed to Execute\" }) }), _jsx(Spacer, { y: \"md\" })] })), !transactionMode && step === \"execute\" && status.id === \"done\" && (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: \"row\", gap: \"xs\", center: \"both\", color: \"success\", children: [_jsx(CheckCircledIcon, { width: iconSize.sm, height: iconSize.sm }), _jsx(Text, { color: \"success\", size: \"sm\", children: \"Payment completed\" })] }), _jsx(Spacer, { y: \"md\" })] })), payer.chain.id !== chain.id ? (_jsx(SwitchNetworkButton, { fullWidth: true, variant: \"accent\", switchChain: async () => {\n                    await props.payer.wallet.switchChain(chain);\n                } })) : (_jsxs(Button, { variant: \"accent\", fullWidth: true, disabled: status.id === \"pending\", onClick: async () => {\n                    if (step === \"execute\") {\n                        onDone();\n                        return;\n                    }\n                    try {\n                        setStatus({ id: \"pending\" });\n                        // TRANSACTION MODE = transfer funds to another one of your wallets before executing the tx\n                        if (transactionMode) {\n                            const transaction = isNativeToken(token)\n                                ? prepareTransaction({\n                                    client,\n                                    chain,\n                                    to: receiverAddress,\n                                    value: toWei(tokenAmount),\n                                })\n                                : transfer({\n                                    contract: getContract({\n                                        address: token.address,\n                                        chain: chain,\n                                        client: client,\n                                    }),\n                                    to: receiverAddress,\n                                    amount: tokenAmount,\n                                });\n                            const [txResult, tokenMetadata] = await Promise.all([\n                                sendAndConfirmTransaction({\n                                    account: props.payer.account,\n                                    transaction,\n                                }),\n                                getCurrencyMetadata({\n                                    contract: getContract({\n                                        address: isNativeToken(token)\n                                            ? NATIVE_TOKEN_ADDRESS\n                                            : token.address,\n                                        chain: chain,\n                                        client: client,\n                                    }),\n                                }),\n                            ]);\n                            // its the last step before the transaction, so propagate onPurchaseSuccess here\n                            props.onSuccess?.(transferBuyWithCryptoQuote({\n                                token,\n                                chain,\n                                tokenMetadata,\n                                tokenAmount,\n                                fromAddress: payer.account.address,\n                                toAddress: receiverAddress,\n                                transaction: txResult,\n                            }));\n                            // switch to execute step\n                            setStep(\"execute\");\n                            setStatus({ id: \"idle\" });\n                        }\n                        else {\n                            const transferResponse = await getBuyWithCryptoTransfer({\n                                client,\n                                fromAddress: payer.account.address,\n                                toAddress: receiverAddress,\n                                chainId: chain.id,\n                                tokenAddress: isNativeToken(token)\n                                    ? NATIVE_TOKEN_ADDRESS\n                                    : token.address,\n                                amount: tokenAmount,\n                                purchaseData: payOptions?.purchaseData,\n                            });\n                            if (transferResponse.approvalData) {\n                                // check allowance\n                                const prevAllowance = await allowance({\n                                    contract: getContract({\n                                        client: client,\n                                        address: transferResponse.approvalData.tokenAddress,\n                                        chain: getCachedChain(transferResponse.approvalData.chainId),\n                                    }),\n                                    spender: transferResponse.approvalData\n                                        .spenderAddress,\n                                    owner: payer.account.address,\n                                });\n                                if (prevAllowance <\n                                    BigInt(transferResponse.approvalData.amountWei)) {\n                                    setStep(\"approve\");\n                                    const transaction = approve({\n                                        contract: getContract({\n                                            client: client,\n                                            address: transferResponse.approvalData.tokenAddress,\n                                            chain: getCachedChain(transferResponse.approvalData.chainId),\n                                        }),\n                                        spender: transferResponse.approvalData\n                                            .spenderAddress,\n                                        amountWei: BigInt(transferResponse.approvalData.amountWei),\n                                    });\n                                    // approve the transfer\n                                    await sendAndConfirmTransaction({\n                                        account: props.payer.account,\n                                        transaction,\n                                    });\n                                }\n                            }\n                            setStep(\"transfer\");\n                            // execute the transfer\n                            const transaction = transferResponse.transactionRequest;\n                            const tx = await sendTransaction({\n                                account: props.payer.account,\n                                transaction,\n                            });\n                            // switches to the status polling screen\n                            setTransactionHash(tx.transactionHash);\n                            setStatus({ id: \"idle\" });\n                        }\n                        // biome-ignore lint/suspicious/noExplicitAny: catch multiple errors\n                    }\n                    catch (e) {\n                        console.error(e);\n                        setStatus({\n                            id: \"error\",\n                            error: \"error\" in e ? e.error?.message : e?.message,\n                        });\n                    }\n                }, gap: \"xs\", children: [step === \"execute\" && (status.id === \"done\" ? \"Done\" : \"Continue\"), step === \"transfer\" &&\n                        (status.id === \"pending\" ? \"Confirming\" : \"Confirm\"), step === \"approve\" &&\n                        (status.id === \"pending\" ? \"Approving\" : \"Approve\"), status.id === \"pending\" && (_jsx(Spinner, { size: \"sm\", color: \"accentButtonText\" }))] }))] }));\n}\nfunction transferBuyWithCryptoQuote(args) {\n    const { token, chain, tokenMetadata, tokenAmount, fromAddress, toAddress, transaction, } = args;\n    return {\n        status: \"COMPLETED\",\n        subStatus: \"SUCCESS\",\n        swapType: \"TRANSFER\",\n        quote: {\n            createdAt: new Date().toISOString(),\n            fromToken: {\n                chainId: chain.id,\n                tokenAddress: isNativeToken(token)\n                    ? NATIVE_TOKEN_ADDRESS\n                    : token.address,\n                decimals: tokenMetadata.decimals,\n                symbol: tokenMetadata.symbol,\n                name: tokenMetadata.name,\n                priceUSDCents: 0,\n            },\n            toToken: {\n                chainId: chain.id,\n                tokenAddress: isNativeToken(token)\n                    ? NATIVE_TOKEN_ADDRESS\n                    : token.address,\n                decimals: tokenMetadata.decimals,\n                symbol: tokenMetadata.symbol,\n                name: tokenMetadata.name,\n                priceUSDCents: 0,\n            },\n            fromAmountWei: toWei(tokenAmount).toString(),\n            fromAmount: tokenAmount,\n            toAmountWei: toWei(tokenAmount).toString(),\n            toAmount: tokenAmount,\n            toAmountMin: tokenAmount,\n            toAmountMinWei: toWei(tokenAmount).toString(),\n            estimated: {\n                feesUSDCents: 0,\n                gasCostUSDCents: 0,\n                slippageBPS: 0,\n                toAmountMinUSDCents: 0,\n                toAmountUSDCents: 0,\n                fromAmountUSDCents: 0,\n                durationSeconds: 0,\n            },\n        },\n        fromAddress,\n        toAddress,\n        source: {\n            transactionHash: transaction.transactionHash,\n            amount: tokenAmount,\n            amountWei: toWei(tokenAmount).toString(),\n            amountUSDCents: 0,\n            completedAt: new Date().toISOString(),\n            token: {\n                chainId: chain.id,\n                tokenAddress: isNativeToken(token)\n                    ? NATIVE_TOKEN_ADDRESS\n                    : token.address,\n                decimals: tokenMetadata.decimals,\n                symbol: tokenMetadata.symbol,\n                name: tokenMetadata.name,\n                priceUSDCents: 0,\n            },\n        },\n    };\n}\n//# sourceMappingURL=TransferConfirmationScreen.js.map","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useState } from \"react\";\nimport { SwapStatusScreen } from \"./SwapStatusScreen.js\";\nimport { TransferConfirmationScreen } from \"./TransferConfirmationScreen.js\";\nexport function TransferFlow(props) {\n    const [transferTxHash, setTransferTxHash] = useState();\n    if (transferTxHash) {\n        return (_jsx(SwapStatusScreen, { title: props.title, onBack: props.onBack, onTryAgain: props.onTryAgain, swapTxHash: transferTxHash, fromChain: props.chain, client: props.client, onDone: props.onDone, transactionMode: false, isEmbed: props.isEmbed, quote: undefined, onSuccess: props.onSuccess }));\n    }\n    return (_jsx(TransferConfirmationScreen, { ...props, setTransactionHash: setTransferTxHash }));\n}\n//# sourceMappingURL=TransferFlow.js.map","import { useEffect, useState } from \"react\";\nimport { useActiveAccount } from \"../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { useActiveWallet } from \"../../../../../core/hooks/wallets/useActiveWallet.js\";\nimport { useActiveWalletChain } from \"../../../../../core/hooks/wallets/useActiveWalletChain.js\";\nexport function usePayerSetup() {\n    const wallet = useActiveWallet();\n    const account = useActiveAccount();\n    const activeChain = useActiveWalletChain();\n    const [_payer, setPayer] = useState();\n    useEffect(() => {\n        const wallet = _payer?.wallet;\n        function update() {\n            if (!wallet) {\n                setPayer(undefined);\n                return;\n            }\n            const account = wallet.getAccount();\n            const chain = wallet.getChain();\n            if (account && chain) {\n                setPayer({\n                    account,\n                    chain,\n                    wallet,\n                });\n            }\n            else {\n                setPayer(undefined);\n            }\n        }\n        if (wallet) {\n            const unsubChainChanged = wallet.subscribe(\"chainChanged\", update);\n            const unsubAccountChanged = wallet.subscribe(\"accountChanged\", update);\n            return () => {\n                unsubChainChanged();\n                unsubAccountChanged();\n            };\n        }\n        return undefined;\n    }, [_payer]);\n    const initialPayer = account && activeChain && wallet\n        ? { account, chain: activeChain, wallet }\n        : undefined;\n    // return the payer state if its set\n    // otherwise return the active wallet as payer\n    const payer = _payer || initialPayer;\n    return {\n        payer,\n        setPayer,\n    };\n}\n//# sourceMappingURL=usePayerSetup.js.map","import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../constants/addresses.js\";\nimport { formatNumber } from \"../../../../../../utils/formatNumber.js\";\nimport { fontSize, spacing, } from \"../../../../../core/design-system/index.js\";\nimport { useActiveAccount } from \"../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { invalidateWalletBalance } from \"../../../../../core/providers/invalidateWalletBalance.js\";\nimport { ErrorState } from \"../../../../wallets/shared/ErrorState.js\";\nimport { LoadingScreen } from \"../../../../wallets/shared/LoadingScreen.js\";\nimport { ChainName } from \"../../../components/ChainName.js\";\nimport { Spacer } from \"../../../components/Spacer.js\";\nimport { Container, Line, ModalHeader } from \"../../../components/basic.js\";\nimport { Button } from \"../../../components/buttons.js\";\nimport { Input } from \"../../../components/formElements.js\";\nimport { TokenSymbol } from \"../../../components/token/TokenSymbol.js\";\nimport { ConnectButton } from \"../../ConnectButton.js\";\nimport { ChainButton, NetworkSelectorContent } from \"../../NetworkSelector.js\";\nimport { TokenSelector } from \"../TokenSelector.js\";\nimport { WalletSwitcherConnectionScreen } from \"../WalletSwitcherConnectionScreen.js\";\nimport { isNativeToken } from \"../nativeToken.js\";\nimport { DirectPaymentModeScreen } from \"./DirectPaymentModeScreen.js\";\nimport { PayTokenIcon } from \"./PayTokenIcon.js\";\nimport { TransactionModeScreen } from \"./TransactionModeScreen.js\";\nimport { CurrencySelection } from \"./fiat/CurrencySelection.js\";\nimport { FiatScreenContent } from \"./fiat/FiatScreenContent.js\";\nimport { OnRampScreen } from \"./fiat/OnRampScreen.js\";\nimport { useEnabledPaymentMethods, } from \"./main/useEnabledPaymentMethods.js\";\nimport { useFiatCurrencySelectionStates, useFromTokenSelectionStates, useToTokenSelectionStates, } from \"./main/useUISelectionStates.js\";\nimport { BuyTokenInput } from \"./swap/BuyTokenInput.js\";\nimport { FiatValue } from \"./swap/FiatValue.js\";\nimport { SwapFlow } from \"./swap/SwapFlow.js\";\nimport { SwapScreenContent } from \"./swap/SwapScreenContent.js\";\nimport { TokenSelectorScreen } from \"./swap/TokenSelectorScreen.js\";\nimport { TransferFlow } from \"./swap/TransferFlow.js\";\nimport { useBuySupportedDestinations, useBuySupportedSources, } from \"./swap/useSwapSupportedChains.js\";\nimport { usePayerSetup } from \"./usePayerSetup.js\";\n/**\n * @internal\n */\nexport default function BuyScreen(props) {\n    const isTestMode = props.payOptions.buyWithCrypto\n        ? props.payOptions.buyWithCrypto.testMode\n        : undefined;\n    const supportedDestinationsQuery = useBuySupportedDestinations(props.client, isTestMode);\n    if (supportedDestinationsQuery.isError) {\n        return (_jsx(Container, { style: {\n                minHeight: \"350px\",\n            }, fullHeight: true, flex: \"row\", center: \"both\", children: _jsx(ErrorState, { title: \"Something went wrong\", onTryAgain: supportedDestinationsQuery.refetch }) }));\n    }\n    if (!supportedDestinationsQuery.data) {\n        return _jsx(LoadingScreen, {});\n    }\n    return (_jsx(BuyScreenContent, { ...props, supportedDestinations: supportedDestinationsQuery.data }));\n}\n/**\n * @internal\n */\nfunction BuyScreenContent(props) {\n    const { client, supportedDestinations, connectLocale, payOptions } = props;\n    const activeAccount = useActiveAccount();\n    const { payer, setPayer } = usePayerSetup();\n    const [screen, setScreen] = useState({\n        id: \"main\",\n    });\n    const { tokenAmount, setTokenAmount, toChain, setToChain, deferredTokenAmount, toToken, setToToken, } = useToTokenSelectionStates({\n        payOptions,\n        supportedDestinations,\n    });\n    const [hasEditedAmount, setHasEditedAmount] = useState(false);\n    const onDone = useCallback(() => {\n        setScreen({ id: \"main\" });\n        props.onDone();\n    }, [props.onDone]);\n    // check if the screen is expanded or not\n    // update supportedSources whenever toToken or toChain is updated\n    const supportedSourcesQuery = useBuySupportedSources({\n        client: props.client,\n        destinationChainId: toChain.id,\n        destinationTokenAddress: isNativeToken(toToken)\n            ? NATIVE_TOKEN_ADDRESS\n            : toToken.address,\n    });\n    const destinationSupportedTokens = useMemo(() => {\n        return createSupportedTokens(supportedDestinations, payOptions, props.supportedTokens);\n    }, [props.supportedTokens, supportedDestinations, payOptions]);\n    const sourceSupportedTokens = useMemo(() => {\n        if (!supportedSourcesQuery.data) {\n            return undefined;\n        }\n        const supportedSources = supportedSourcesQuery.data;\n        return createSupportedTokens(supportedSources, payOptions, props.supportedTokens);\n    }, [props.supportedTokens, supportedSourcesQuery.data, payOptions]);\n    const { fromChain, setFromChain, fromToken, setFromToken } = useFromTokenSelectionStates({\n        payOptions,\n        supportedSources: supportedSourcesQuery.data || [],\n    });\n    const { selectedCurrency, setSelectedCurrency } = useFiatCurrencySelectionStates({\n        payOptions,\n    });\n    const enabledPaymentMethods = useEnabledPaymentMethods({\n        payOptions: props.payOptions,\n        supportedDestinations: props.supportedDestinations,\n        toChain: toChain,\n        toToken: toToken,\n    });\n    const payDisabled = enabledPaymentMethods.buyWithCryptoEnabled === false &&\n        enabledPaymentMethods.buyWithFiatEnabled === false;\n    // screens ----------------------------\n    const queryClient = useQueryClient();\n    const onSwapSuccess = useCallback((_status) => {\n        props.payOptions.onPurchaseSuccess?.({\n            type: \"crypto\",\n            status: _status,\n        });\n        invalidateWalletBalance(queryClient);\n    }, [props.payOptions.onPurchaseSuccess, queryClient]);\n    const onFiatSuccess = useCallback((_status) => {\n        props.payOptions.onPurchaseSuccess?.({\n            type: \"fiat\",\n            status: _status,\n        });\n        invalidateWalletBalance(queryClient);\n    }, [props.payOptions.onPurchaseSuccess, queryClient]);\n    if (screen.id === \"connect-payer-wallet\") {\n        return (_jsx(WalletSwitcherConnectionScreen, { accountAbstraction: props.connectOptions?.accountAbstraction, appMetadata: props.connectOptions?.appMetadata, chain: props.connectOptions?.chain, chains: props.connectOptions?.chains, client: props.client, connectLocale: props.connectLocale, isEmbed: props.isEmbed, onBack: () => setScreen(screen.backScreen), onSelect: (w) => {\n                const account = w.getAccount();\n                const chain = w.getChain();\n                if (w && account && chain) {\n                    setPayer({\n                        account,\n                        chain,\n                        wallet: w,\n                    });\n                }\n            }, hiddenWallets: props.hiddenWallets, recommendedWallets: props.connectOptions?.recommendedWallets, showAllWallets: props.connectOptions?.showAllWallets === undefined\n                ? true\n                : props.connectOptions?.showAllWallets, walletConnect: props.connectOptions?.walletConnect, wallets: props.connectOptions?.wallets?.filter((w) => w.id !== \"inApp\") }));\n    }\n    if (screen.id === \"swap-flow\" && payer) {\n        return (_jsx(SwapFlow, { title: props.title, transactionMode: payOptions.mode === \"transaction\", isEmbed: props.isEmbed, client: client, onBack: () => {\n                setScreen({\n                    id: \"buy-with-crypto\",\n                });\n            }, buyWithCryptoQuote: screen.quote, payer: payer, isFiatFlow: false, onDone: onDone, onTryAgain: () => {\n                setScreen({\n                    id: \"buy-with-crypto\",\n                });\n            }, onSuccess: onSwapSuccess, approvalAmount: screen.approvalAmount }));\n    }\n    if (screen.id === \"fiat-flow\" && payer) {\n        const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;\n        const receiverAddress = defaultRecipientAddress || payer.account.address;\n        return (_jsx(OnRampScreen, { title: props.title, transactionMode: payOptions.mode === \"transaction\", quote: screen.quote, onBack: () => {\n                setScreen({\n                    id: \"buy-with-fiat\",\n                });\n            }, client: client, testMode: props.payOptions.buyWithFiat !== false &&\n                props.payOptions.buyWithFiat?.testMode === true, theme: typeof props.theme === \"string\" ? props.theme : props.theme.type, onDone: onDone, isEmbed: props.isEmbed, payer: payer, receiverAddress: receiverAddress, onSuccess: onFiatSuccess }));\n    }\n    if (screen.id === \"transfer-flow\" && payer && activeAccount) {\n        const goBack = () => setScreen({ id: \"buy-with-crypto\" });\n        // TODO (pay) pass it via screen props\n        const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;\n        const receiverAddress = defaultRecipientAddress || activeAccount.address;\n        return (_jsx(TransferFlow, { title: props.title, onBack: goBack, payer: payer, client: props.client, chain: toChain, token: toToken, tokenAmount: tokenAmount, receiverAddress: receiverAddress, transactionMode: props.payOptions.mode === \"transaction\", payOptions: payOptions, isEmbed: props.isEmbed, onDone: onDone, onTryAgain: () => {\n                setScreen({\n                    id: \"buy-with-crypto\",\n                });\n            }, onSuccess: onSwapSuccess }));\n    }\n    if (screen.id === \"select-currency\") {\n        const goBack = () => setScreen(screen.backScreen);\n        return (_jsx(CurrencySelection, { onSelect: (currency) => {\n                goBack();\n                setSelectedCurrency(currency);\n            }, onBack: goBack }));\n    }\n    if (screen.id === \"select-to-token\") {\n        const chains = supportedDestinations.map((x) => x.chain);\n        const goBack = () => setScreen(screen.backScreen);\n        const allowEdits = payOptions?.prefillBuy\n            ?.allowEdits;\n        // if token selection is disabled - only show network selector screen\n        if (allowEdits?.token === false) {\n            return (_jsx(ChainSelectionScreen, { chains: chains, client: props.client, connectLocale: props.connectLocale, setChain: setToChain, goBack: goBack }));\n        }\n        return (_jsx(TokenSelector, { onBack: goBack, tokenList: ((toChain?.id ? destinationSupportedTokens[toChain.id] : undefined) ||\n                []).filter((x) => x.address !== NATIVE_TOKEN_ADDRESS), onTokenSelect: (tokenInfo) => {\n                setToToken(tokenInfo);\n                goBack();\n            }, chain: toChain, chainSelection: \n            // hide chain selection if it's disabled\n            allowEdits?.chain !== false\n                ? {\n                    chains: chains,\n                    select: (c) => {\n                        setToChain(c);\n                    },\n                }\n                : undefined, connectLocale: connectLocale, client: client, modalTitle: props.title }));\n    }\n    return (_jsx(Container, { animate: \"fadein\", children: _jsxs(\"div\", { children: [screen.id === \"main\" && (_jsx(MainScreen, { title: props.title, payerAccount: payer?.account, client: client, onSelectBuyToken: () => setScreen({ id: \"select-to-token\", backScreen: screen }), payOptions: payOptions, setTokenAmount: setTokenAmount, setToChain: setToChain, setToToken: setToToken, setFromChain: setFromChain, setFromToken: setFromToken, toChain: toChain, toToken: toToken, tokenAmount: tokenAmount, connectOptions: props.connectOptions, setScreen: setScreen, supportedDestinations: supportedDestinations, onBack: props.onBack, theme: props.theme, hasEditedAmount: hasEditedAmount, setHasEditedAmount: setHasEditedAmount, enabledPaymentMethods: enabledPaymentMethods })), (screen.id === \"select-payment-method\" ||\n                    screen.id === \"buy-with-crypto\" ||\n                    screen.id === \"buy-with-fiat\" ||\n                    screen.id === \"select-from-token\") &&\n                    payer && (_jsxs(TokenSelectedLayout, { disabled: (\"prefillBuy\" in payOptions &&\n                        payOptions.prefillBuy?.allowEdits?.amount === false) ||\n                        payOptions.mode !== \"fund_wallet\", title: props.title, selectedChain: toChain, selectedToken: toToken, tokenAmount: tokenAmount, setTokenAmount: setTokenAmount, client: client, onBack: () => {\n                        if (screen.id === \"buy-with-crypto\" ||\n                            screen.id === \"buy-with-fiat\") {\n                            setScreen({\n                                id: \"select-from-token\",\n                                backScreen: { id: \"main\" },\n                            });\n                        }\n                        else if (screen.id === \"select-from-token\") {\n                            setScreen(screen.backScreen);\n                        }\n                        else {\n                            setScreen({ id: \"main\" });\n                        }\n                    }, children: [screen.id === \"buy-with-crypto\" && activeAccount && (_jsx(SwapScreenContent, { setScreen: setScreen, tokenAmount: deferredTokenAmount, toChain: toChain, toToken: toToken, fromChain: fromChain, fromToken: fromToken, showFromTokenSelector: () => {\n                                setScreen({\n                                    id: \"select-from-token\",\n                                    backScreen: screen,\n                                });\n                            }, payer: payer, client: client, isEmbed: props.isEmbed, onDone: onDone, payOptions: payOptions, connectLocale: connectLocale, connectOptions: props.connectOptions, setPayer: setPayer, \n                            // pass it even though we are passing payer, because payer might be different\n                            activeAccount: activeAccount, setTokenAmount: setTokenAmount, setHasEditedAmount: setHasEditedAmount, disableTokenSelection: payDisabled === true ||\n                                (payOptions.buyWithCrypto !== false &&\n                                    payOptions.buyWithCrypto?.prefillSource?.allowEdits\n                                        ?.chain === false &&\n                                    payOptions.buyWithCrypto?.prefillSource?.allowEdits\n                                        ?.token === false) })), screen.id === \"buy-with-fiat\" && (_jsx(FiatScreenContent, { setScreen: setScreen, tokenAmount: deferredTokenAmount, toChain: toChain, toToken: toToken, selectedCurrency: selectedCurrency, client: client, isEmbed: props.isEmbed, onDone: onDone, payOptions: payOptions, theme: props.theme, showCurrencySelector: () => {\n                                setScreen({\n                                    id: \"select-currency\",\n                                    backScreen: screen,\n                                });\n                            }, payer: payer, setTokenAmount: setTokenAmount, setHasEditedAmount: setHasEditedAmount })), screen.id === \"select-from-token\" &&\n                            supportedSourcesQuery.data &&\n                            sourceSupportedTokens && (_jsx(TokenSelectorScreen, { fiatSupported: props.payOptions.buyWithFiat !== false, client: props.client, sourceTokens: sourceSupportedTokens, sourceSupportedTokens: sourceSupportedTokens, toChain: toChain, toToken: toToken, tokenAmount: tokenAmount, mode: payOptions.mode, hiddenWallets: props.hiddenWallets, onConnect: () => {\n                                setScreen({\n                                    id: \"connect-payer-wallet\",\n                                    backScreen: screen,\n                                });\n                            }, onPayWithFiat: () => {\n                                setScreen({\n                                    id: \"buy-with-fiat\",\n                                });\n                            }, onSelectToken: (w, token, chain) => {\n                                const account = w.getAccount();\n                                if (account) {\n                                    setPayer({\n                                        account,\n                                        chain,\n                                        wallet: w,\n                                    });\n                                    setFromToken(token);\n                                    setFromChain(chain);\n                                }\n                                setScreen({ id: \"buy-with-crypto\" });\n                            } }))] }))] }) }));\n}\nfunction SelectedTokenInfo(props) {\n    const getWidth = () => {\n        const amount = formatNumber(Number(props.tokenAmount), 5).toString();\n        let chars = amount.replace(\".\", \"\").length;\n        const hasDot = amount.includes(\".\");\n        if (hasDot) {\n            chars += 0.3;\n        }\n        return `calc(${`${Math.max(1, chars)}ch + 2px`})`;\n    };\n    return (_jsx(\"div\", { children: _jsxs(Container, { flex: \"row\", gap: \"sm\", center: \"y\", style: {\n                justifyContent: \"space-between\",\n            }, children: [_jsxs(Container, { flex: \"row\", gap: \"xxs\", center: \"y\", children: [_jsx(Input, { variant: \"outline\", pattern: \"^[0-9]*[.,]?[0-9]*$\", inputMode: \"decimal\", tabIndex: -1, placeholder: \"0\", type: \"text\", \"data-placeholder\": props.tokenAmount === \"\", value: props.tokenAmount || \"0\", disabled: props.disabled, onClick: (e) => {\n                                // put cursor at the end of the input\n                                if (props.tokenAmount === \"\") {\n                                    e.currentTarget.setSelectionRange(e.currentTarget.value.length, e.currentTarget.value.length);\n                                }\n                            }, onChange: (e) => {\n                                let value = e.target.value;\n                                // Replace comma with period if it exists\n                                value = value.replace(\",\", \".\");\n                                if (value.startsWith(\".\")) {\n                                    value = `0${value}`;\n                                }\n                                if (value.length > 10) {\n                                    return;\n                                }\n                                const numValue = Number(value);\n                                if (Number.isNaN(numValue)) {\n                                    return;\n                                }\n                                if (value.startsWith(\"0\") && !value.startsWith(\"0.\")) {\n                                    props.setTokenAmount(value.slice(1));\n                                }\n                                else {\n                                    props.setTokenAmount(value);\n                                }\n                            }, style: {\n                                border: \"none\",\n                                fontSize: fontSize.lg,\n                                boxShadow: \"none\",\n                                borderRadius: \"0\",\n                                padding: \"0\",\n                                paddingBlock: \"2px\",\n                                fontWeight: 600,\n                                textAlign: \"left\",\n                                width: getWidth(),\n                            } }), _jsxs(Container, { flex: \"row\", gap: \"xxs\", center: \"y\", children: [_jsx(TokenSymbol, { token: props.selectedToken, chain: props.selectedChain, size: \"md\", color: \"secondaryText\" }), _jsx(PayTokenIcon, { chain: props.selectedChain, client: props.client, size: \"sm\", token: props.selectedToken })] }), _jsx(FiatValue, { chain: props.selectedChain, client: props.client, tokenAmount: props.tokenAmount, token: props.selectedToken, size: \"sm\" })] }), _jsx(ChainName, { chain: props.selectedChain, client: props.client, size: \"sm\", short: true })] }) }));\n}\nfunction MainScreen(props) {\n    const { setTokenAmount, setToChain, setToToken, setFromChain, setFromToken, payerAccount, client, tokenAmount, payOptions, toToken, toChain, supportedDestinations, enabledPaymentMethods, } = props;\n    const { buyWithCryptoEnabled, buyWithFiatEnabled } = enabledPaymentMethods;\n    const disableContinue = !tokenAmount;\n    switch (payOptions.mode) {\n        case \"transaction\": {\n            return (_jsx(TransactionModeScreen, { supportedDestinations: supportedDestinations, payUiOptions: payOptions, payerAccount: payerAccount, connectOptions: props.connectOptions, client: client, onContinue: (tokenAmount, toChain, toToken) => {\n                    setTokenAmount(tokenAmount);\n                    setToChain(toChain);\n                    setFromChain(toChain);\n                    setFromToken(toToken);\n                    setToToken(toToken);\n                    if (buyWithFiatEnabled && !buyWithCryptoEnabled) {\n                        props.setScreen({ id: \"buy-with-fiat\" });\n                    }\n                    else {\n                        props.setScreen({\n                            id: \"select-from-token\",\n                            backScreen: { id: \"main\" },\n                        });\n                    }\n                } }));\n        }\n        case \"direct_payment\": {\n            return (_jsx(DirectPaymentModeScreen, { client: client, payUiOptions: payOptions, payerAccount: payerAccount, connectOptions: props.connectOptions, supportedDestinations: supportedDestinations, onContinue: (tokenAmount, toChain, toToken) => {\n                    setTokenAmount(tokenAmount);\n                    setToChain(toChain);\n                    setFromChain(toChain);\n                    setFromToken(toToken);\n                    setToToken(toToken);\n                    if (buyWithFiatEnabled && !buyWithCryptoEnabled) {\n                        props.setScreen({ id: \"buy-with-fiat\" });\n                    }\n                    else {\n                        props.setScreen({\n                            id: \"select-from-token\",\n                            backScreen: { id: \"main\" },\n                        });\n                    }\n                } }));\n        }\n        default: {\n            return (_jsxs(Container, { p: \"lg\", children: [_jsx(ModalHeader, { title: props.title, onBack: props.onBack }), _jsx(Spacer, { y: \"xl\" }), _jsx(BuyTokenInput, { value: tokenAmount, onChange: async (value) => {\n                            props.setHasEditedAmount(true);\n                            setTokenAmount(value);\n                        }, freezeAmount: payOptions.prefillBuy?.allowEdits?.amount === false, freezeChainAndToken: (payOptions.prefillBuy?.allowEdits?.chain === false &&\n                            payOptions.prefillBuy?.allowEdits?.token === false) ||\n                            (payOptions.buyWithCrypto !== false &&\n                                payOptions.buyWithCrypto?.prefillSource?.allowEdits?.token ===\n                                    false &&\n                                payOptions.buyWithCrypto?.prefillSource?.allowEdits?.chain ===\n                                    false), token: toToken, chain: toChain, onSelectToken: props.onSelectBuyToken, client: props.client }), _jsx(Spacer, { y: \"md\" }), _jsx(Container, { flex: \"column\", gap: \"sm\", children: !payerAccount ? (_jsx(\"div\", { children: _jsx(ConnectButton, { ...props.connectOptions, client: props.client, theme: props.theme, connectButton: {\n                                    style: {\n                                        width: \"100%\",\n                                    },\n                                } }) })) : (_jsx(Button, { variant: \"accent\", fullWidth: true, disabled: disableContinue, \"data-disabled\": disableContinue, onClick: () => {\n                                if (buyWithFiatEnabled && !buyWithCryptoEnabled) {\n                                    props.setScreen({ id: \"buy-with-fiat\" });\n                                }\n                                else {\n                                    props.setScreen({\n                                        id: \"select-from-token\",\n                                        backScreen: { id: \"main\" },\n                                    });\n                                }\n                            }, children: \"Continue\" })) })] }));\n        }\n    }\n}\nfunction TokenSelectedLayout(props) {\n    return (_jsxs(Container, { children: [_jsx(Container, { p: \"lg\", children: _jsx(ModalHeader, { title: props.title, onBack: props.onBack }) }), _jsxs(Container, { px: \"lg\", style: {\n                    paddingBottom: spacing.lg,\n                }, children: [_jsx(Spacer, { y: \"xs\" }), _jsx(SelectedTokenInfo, { selectedToken: props.selectedToken, selectedChain: props.selectedChain, tokenAmount: props.tokenAmount, setTokenAmount: props.setTokenAmount, client: props.client, disabled: props.disabled }), _jsx(Spacer, { y: \"sm\" }), _jsx(Line, {}), _jsx(Spacer, { y: \"sm\" }), props.children] })] }));\n}\nfunction createSupportedTokens(data, payOptions, supportedTokensOverrides) {\n    // dev override\n    if (supportedTokensOverrides) {\n        return supportedTokensOverrides;\n    }\n    const tokens = {};\n    const isBuyWithFiatDisabled = payOptions.buyWithFiat === false;\n    const isBuyWithCryptoDisabled = payOptions.buyWithCrypto === false;\n    for (const x of data) {\n        tokens[x.chain.id] = x.tokens.filter((t) => {\n            // for source tokens, data is not provided, so we include all of them\n            if (t.buyWithCryptoEnabled === undefined &&\n                t.buyWithFiatEnabled === undefined) {\n                return true;\n            }\n            // it token supports both - include it\n            if (t.buyWithCryptoEnabled && t.buyWithFiatEnabled) {\n                return true;\n            }\n            // if buyWithFiat is disabled, and buyWithCrypto is not supported by token - exclude the token\n            if (!t.buyWithCryptoEnabled && isBuyWithFiatDisabled) {\n                return false;\n            }\n            // if buyWithCrypto is disabled, and buyWithFiat is not supported by token - exclude the token\n            if (!t.buyWithFiatEnabled && isBuyWithCryptoDisabled) {\n                return false;\n            }\n            return true; // include the token\n        });\n    }\n    return tokens;\n}\nfunction ChainSelectionScreen(props) {\n    return (_jsx(NetworkSelectorContent, { client: props.client, connectLocale: props.connectLocale, showTabs: false, onBack: props.goBack, chains: props.chains, closeModal: props.goBack, networkSelector: {\n            renderChain(renderChainProps) {\n                return (_jsx(ChainButton, { chain: renderChainProps.chain, confirming: false, switchingFailed: false, onClick: () => {\n                        props.setChain(renderChainProps.chain);\n                        props.goBack();\n                    }, client: props.client, connectLocale: props.connectLocale }));\n            },\n        } }));\n}\n//# sourceMappingURL=BuyScreen.js.map","import { withCache } from \"../../../utils/promise/withCache.js\";\nimport { decimals as generatedDecimals } from \"../__generated__/IERC20/read/decimals.js\";\nexport { isDecimalsSupported } from \"../__generated__/IERC20/read/decimals.js\";\n/**\n * Retrieves the number of decimal places for a given ERC20 contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the number of decimal places.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const tokenDecimals = await decimals({ contract });\n * ```\n */\nexport async function decimals(options) {\n    return withCache(() => generatedDecimals(options), {\n        cacheKey: `${options.contract.chain.id}:${options.contract.address}:decimals`,\n        // can never change, so cache forever\n        cacheTime: Number.POSITIVE_INFINITY,\n    });\n}\n//# sourceMappingURL=decimals.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0x313ce567\";\nconst FN_INPUTS = [];\nconst FN_OUTPUTS = [\n    {\n        type: \"uint8\",\n    },\n];\n/**\n * Checks if the `decimals` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `decimals` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isDecimalsSupported } from \"thirdweb/extensions/erc20\";\n * const supported = isDecimalsSupported([\"0x...\"]);\n * ```\n */\nexport function isDecimalsSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Decodes the result of the decimals function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeDecimalsResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeDecimalsResultResult(\"...\");\n * ```\n */\nexport function decodeDecimalsResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"decimals\" function on the contract.\n * @param options - The options for the decimals function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const result = await decimals({\n *  contract,\n * });\n *\n * ```\n */\nexport async function decimals(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [],\n    });\n}\n//# sourceMappingURL=decimals.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0x06fdde03\";\nconst FN_INPUTS = [];\nconst FN_OUTPUTS = [\n    {\n        type: \"string\",\n    },\n];\n/**\n * Checks if the `name` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `name` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isNameSupported } from \"thirdweb/extensions/common\";\n * const supported = isNameSupported([\"0x...\"]);\n * ```\n */\nexport function isNameSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Decodes the result of the name function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeNameResult } from \"thirdweb/extensions/common\";\n * const result = decodeNameResultResult(\"...\");\n * ```\n */\nexport function decodeNameResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"name\" function on the contract.\n * @param options - The options for the name function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const result = await name({\n *  contract,\n * });\n *\n * ```\n */\nexport async function name(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [],\n    });\n}\n//# sourceMappingURL=name.js.map","import { withCache } from \"../../../utils/promise/withCache.js\";\nimport { name as generatedName } from \"../__generated__/IContractMetadata/read/name.js\";\nexport { isNameSupported } from \"../__generated__/IContractMetadata/read/name.js\";\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { name } from \"thirdweb/extensions/common\";\n *\n * const contractName = await name({ contract });\n * ```\n */\nexport async function name(options) {\n    return withCache(() => generatedName(options), {\n        cacheKey: `${options.contract.chain.id}:${options.contract.address}:name`,\n        // can never change, so cache forever\n        cacheTime: Number.POSITIVE_INFINITY,\n    });\n}\n//# sourceMappingURL=name.js.map","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nexport const FN_SELECTOR = \"0x95d89b41\";\nconst FN_INPUTS = [];\nconst FN_OUTPUTS = [\n    {\n        type: \"string\",\n    },\n];\n/**\n * Checks if the `symbol` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `symbol` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isSymbolSupported } from \"thirdweb/extensions/common\";\n * const supported = isSymbolSupported([\"0x...\"]);\n * ```\n */\nexport function isSymbolSupported(availableSelectors) {\n    return detectMethod({\n        availableSelectors,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n    });\n}\n/**\n * Decodes the result of the symbol function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension COMMON\n * @example\n * ```ts\n * import { decodeSymbolResult } from \"thirdweb/extensions/common\";\n * const result = decodeSymbolResultResult(\"...\");\n * ```\n */\nexport function decodeSymbolResult(result) {\n    return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n/**\n * Calls the \"symbol\" function on the contract.\n * @param options - The options for the symbol function.\n * @returns The parsed result of the function call.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const result = await symbol({\n *  contract,\n * });\n *\n * ```\n */\nexport async function symbol(options) {\n    return readContract({\n        contract: options.contract,\n        method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],\n        params: [],\n    });\n}\n//# sourceMappingURL=symbol.js.map","import { withCache } from \"../../../utils/promise/withCache.js\";\nimport { symbol as generatedSymbol } from \"../__generated__/IContractMetadata/read/symbol.js\";\nexport { isSymbolSupported } from \"../__generated__/IContractMetadata/read/symbol.js\";\n/**\n * Retrieves the name associated with the given contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the name associated with the contract.\n * @extension COMMON\n * @example\n * ```ts\n * import { symbol } from \"thirdweb/extensions/common\";\n *\n * const contractSymbol = await symbol({ contract });\n * ```\n */\nexport async function symbol(options) {\n    return withCache(() => generatedSymbol(options), {\n        cacheKey: `${options.contract.chain.id}:${options.contract.address}:symbol`,\n        // can never change, so cache forever\n        cacheTime: Number.POSITIVE_INFINITY,\n    });\n}\n//# sourceMappingURL=symbol.js.map","import { isNativeTokenAddress } from \"../../../constants/addresses.js\";\nimport { name } from \"../../common/read/name.js\";\nimport { symbol } from \"../../common/read/symbol.js\";\nimport { decimals } from \"../__generated__/IERC20/read/decimals.js\";\n/**\n * Retrieves the metadata of a currency.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to an object containing the currency metadata.\n * @extension ERC20\n * @example\n * ```ts\n * import { getCurrencyMetadata } from \"thirdweb/extensions/erc20\";\n *\n * const currencyMetadata = await getCurrencyMetadata({ contract });\n * ```\n */\nexport async function getCurrencyMetadata(options) {\n    // if the contract is the native token, return the native currency metadata\n    if (isNativeTokenAddress(options.contract.address)) {\n        return {\n            name: \"Ether\",\n            symbol: \"ETH\",\n            decimals: 18,\n            // overwrite with native currency of the chain if available\n            ...options.contract.chain.nativeCurrency,\n        };\n    }\n    try {\n        const [name_, symbol_, decimals_] = await Promise.all([\n            name(options).catch(() => \"\"),\n            symbol(options),\n            decimals(options),\n        ]);\n        return {\n            name: name_,\n            symbol: symbol_,\n            decimals: decimals_,\n        };\n    }\n    catch {\n        throw new Error(\"Invalid currency token\");\n    }\n}\n//# sourceMappingURL=getCurrencyMetadata.js.map"],"names":[],"sourceRoot":""}