{"version":3,"file":"58734.js","mappings":"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mBACA,eACA,YACA,YACA,MAAoB,kBAAY,IAChC,WAAiD,qBAAmB,EACpE,WAEA,yBAEA,QAAqB,QAAc,GAAS,IAAK,GACxC,EACT,EAAsB,GAAR,CAAiC,EAAjC,KAAQ,cAEtB,KADwB,QAAQ,oBAEhC,EAA+B,QAAQ,iCACvC,GAAgC,GAAR,CAA6C,EAA7C,KAAQ,2BAChC,QAEA,UAEA,CACA,OACA,MACA,eACA,uBACA,eACA,CACA,CACA,oBACA,IAAY,sBAAoB,EAChC,6BACQ,YAAM,IACN,OAAoB,OACpB,OAAoB,UACpB,OAAoB,WAC5B,EACA,mBACA,OACA,OACA,KACA,OACA,QACA,gBACA,YACA,KACA,wBACA,8CAAsE,KAAU,IAChF,CAAS,CACT,WACA,CACA,oCCvJO,sBACP,gBACA,gCACA,WACK,CACL,kECVO,cACP,OAAW,IAAc,MACzB,4DC4BO,cACP,2CACA,6BACA,2EAAuF,GAAO,UAAU,SAAa,UAErH,wBACA,OAAsB,QAAe,KAErC,SACA,CACO,aACP,mBACA,KACA,iBACA,iBACA,sBACA,+DACA","sources":["webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/encoding/toRlp.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/utils/hash/sha256.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/constants/number.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/zksync/constants/number.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/zksync/errors/bytecode.js","webpack://unreal/./node_modules/.pnpm/viem@2.23.10_typescript@5.8.2_zod@3.22.3/node_modules/viem/_esm/zksync/utils/hashBytecode.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/transaction/actions/zksync/getEip721Domain.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/transaction/actions/zksync/send-eip712-transaction.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/rpc/actions/eth_sendRawTransaction.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/encoding/helpers/concat-hex.js","webpack://unreal/./node_modules/.pnpm/thirdweb@5.93.5_@aws-sdk+client-lambda@3.777.0_@types+react-dom@19.0.4_@types+react@19.0.12___ouklnsjwvogyqsuwnvucv7k7o4/node_modules/thirdweb/dist/esm/utils/bigint.js"],"sourcesContent":["import { BaseError } from '../../errors/base.js';\nimport { createCursor, } from '../cursor.js';\nimport { hexToBytes } from './toBytes.js';\nimport { bytesToHex } from './toHex.js';\nexport function toRlp(bytes, to = 'hex') {\n    const encodable = getEncodable(bytes);\n    const cursor = createCursor(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (to === 'hex')\n        return bytesToHex(cursor.bytes);\n    return cursor.bytes;\n}\nexport function bytesToRlp(bytes, to = 'bytes') {\n    return toRlp(bytes, to);\n}\nexport function hexToRlp(hex, to = 'hex') {\n    return toRlp(hex, to);\n}\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length < 2 ** 8)\n        return 1;\n    if (length < 2 ** 16)\n        return 2;\n    if (length < 2 ** 24)\n        return 3;\n    if (length < 2 ** 32)\n        return 4;\n    throw new BaseError('Length is too large.');\n}\n//# sourceMappingURL=toRlp.js.map","import { sha256 as noble_sha256 } from '@noble/hashes/sha256';\nimport { isHex } from '../data/isHex.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toHex } from '../encoding/toHex.js';\nexport function sha256(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = noble_sha256(isHex(value, { strict: false }) ? toBytes(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return toHex(bytes);\n}\n//# sourceMappingURL=sha256.js.map","export const maxInt8 = 2n ** (8n - 1n) - 1n;\nexport const maxInt16 = 2n ** (16n - 1n) - 1n;\nexport const maxInt24 = 2n ** (24n - 1n) - 1n;\nexport const maxInt32 = 2n ** (32n - 1n) - 1n;\nexport const maxInt40 = 2n ** (40n - 1n) - 1n;\nexport const maxInt48 = 2n ** (48n - 1n) - 1n;\nexport const maxInt56 = 2n ** (56n - 1n) - 1n;\nexport const maxInt64 = 2n ** (64n - 1n) - 1n;\nexport const maxInt72 = 2n ** (72n - 1n) - 1n;\nexport const maxInt80 = 2n ** (80n - 1n) - 1n;\nexport const maxInt88 = 2n ** (88n - 1n) - 1n;\nexport const maxInt96 = 2n ** (96n - 1n) - 1n;\nexport const maxInt104 = 2n ** (104n - 1n) - 1n;\nexport const maxInt112 = 2n ** (112n - 1n) - 1n;\nexport const maxInt120 = 2n ** (120n - 1n) - 1n;\nexport const maxInt128 = 2n ** (128n - 1n) - 1n;\nexport const maxInt136 = 2n ** (136n - 1n) - 1n;\nexport const maxInt144 = 2n ** (144n - 1n) - 1n;\nexport const maxInt152 = 2n ** (152n - 1n) - 1n;\nexport const maxInt160 = 2n ** (160n - 1n) - 1n;\nexport const maxInt168 = 2n ** (168n - 1n) - 1n;\nexport const maxInt176 = 2n ** (176n - 1n) - 1n;\nexport const maxInt184 = 2n ** (184n - 1n) - 1n;\nexport const maxInt192 = 2n ** (192n - 1n) - 1n;\nexport const maxInt200 = 2n ** (200n - 1n) - 1n;\nexport const maxInt208 = 2n ** (208n - 1n) - 1n;\nexport const maxInt216 = 2n ** (216n - 1n) - 1n;\nexport const maxInt224 = 2n ** (224n - 1n) - 1n;\nexport const maxInt232 = 2n ** (232n - 1n) - 1n;\nexport const maxInt240 = 2n ** (240n - 1n) - 1n;\nexport const maxInt248 = 2n ** (248n - 1n) - 1n;\nexport const maxInt256 = 2n ** (256n - 1n) - 1n;\nexport const minInt8 = -(2n ** (8n - 1n));\nexport const minInt16 = -(2n ** (16n - 1n));\nexport const minInt24 = -(2n ** (24n - 1n));\nexport const minInt32 = -(2n ** (32n - 1n));\nexport const minInt40 = -(2n ** (40n - 1n));\nexport const minInt48 = -(2n ** (48n - 1n));\nexport const minInt56 = -(2n ** (56n - 1n));\nexport const minInt64 = -(2n ** (64n - 1n));\nexport const minInt72 = -(2n ** (72n - 1n));\nexport const minInt80 = -(2n ** (80n - 1n));\nexport const minInt88 = -(2n ** (88n - 1n));\nexport const minInt96 = -(2n ** (96n - 1n));\nexport const minInt104 = -(2n ** (104n - 1n));\nexport const minInt112 = -(2n ** (112n - 1n));\nexport const minInt120 = -(2n ** (120n - 1n));\nexport const minInt128 = -(2n ** (128n - 1n));\nexport const minInt136 = -(2n ** (136n - 1n));\nexport const minInt144 = -(2n ** (144n - 1n));\nexport const minInt152 = -(2n ** (152n - 1n));\nexport const minInt160 = -(2n ** (160n - 1n));\nexport const minInt168 = -(2n ** (168n - 1n));\nexport const minInt176 = -(2n ** (176n - 1n));\nexport const minInt184 = -(2n ** (184n - 1n));\nexport const minInt192 = -(2n ** (192n - 1n));\nexport const minInt200 = -(2n ** (200n - 1n));\nexport const minInt208 = -(2n ** (208n - 1n));\nexport const minInt216 = -(2n ** (216n - 1n));\nexport const minInt224 = -(2n ** (224n - 1n));\nexport const minInt232 = -(2n ** (232n - 1n));\nexport const minInt240 = -(2n ** (240n - 1n));\nexport const minInt248 = -(2n ** (248n - 1n));\nexport const minInt256 = -(2n ** (256n - 1n));\nexport const maxUint8 = 2n ** 8n - 1n;\nexport const maxUint16 = 2n ** 16n - 1n;\nexport const maxUint24 = 2n ** 24n - 1n;\nexport const maxUint32 = 2n ** 32n - 1n;\nexport const maxUint40 = 2n ** 40n - 1n;\nexport const maxUint48 = 2n ** 48n - 1n;\nexport const maxUint56 = 2n ** 56n - 1n;\nexport const maxUint64 = 2n ** 64n - 1n;\nexport const maxUint72 = 2n ** 72n - 1n;\nexport const maxUint80 = 2n ** 80n - 1n;\nexport const maxUint88 = 2n ** 88n - 1n;\nexport const maxUint96 = 2n ** 96n - 1n;\nexport const maxUint104 = 2n ** 104n - 1n;\nexport const maxUint112 = 2n ** 112n - 1n;\nexport const maxUint120 = 2n ** 120n - 1n;\nexport const maxUint128 = 2n ** 128n - 1n;\nexport const maxUint136 = 2n ** 136n - 1n;\nexport const maxUint144 = 2n ** 144n - 1n;\nexport const maxUint152 = 2n ** 152n - 1n;\nexport const maxUint160 = 2n ** 160n - 1n;\nexport const maxUint168 = 2n ** 168n - 1n;\nexport const maxUint176 = 2n ** 176n - 1n;\nexport const maxUint184 = 2n ** 184n - 1n;\nexport const maxUint192 = 2n ** 192n - 1n;\nexport const maxUint200 = 2n ** 200n - 1n;\nexport const maxUint208 = 2n ** 208n - 1n;\nexport const maxUint216 = 2n ** 216n - 1n;\nexport const maxUint224 = 2n ** 224n - 1n;\nexport const maxUint232 = 2n ** 232n - 1n;\nexport const maxUint240 = 2n ** 240n - 1n;\nexport const maxUint248 = 2n ** 248n - 1n;\nexport const maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=number.js.map","import { maxUint16 } from '../../constants/number.js';\nexport const gasPerPubdataDefault = 50000n;\nexport const maxBytecodeSize = maxUint16 * 32n;\nexport const requiredL1ToL2GasPerPubdataLimit = 800n;\n//# sourceMappingURL=number.js.map","import { BaseError } from '../../errors/base.js';\nexport class BytecodeLengthExceedsMaxSizeError extends BaseError {\n    constructor({ givenLength, maxBytecodeSize, }) {\n        super(`Bytecode cannot be longer than ${maxBytecodeSize} bytes. Given length: ${givenLength}`, { name: 'BytecodeLengthExceedsMaxSizeError' });\n    }\n}\nexport class BytecodeLengthInWordsMustBeOddError extends BaseError {\n    constructor({ givenLengthInWords }) {\n        super(`Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`, { name: 'BytecodeLengthInWordsMustBeOddError' });\n    }\n}\nexport class BytecodeLengthMustBeDivisibleBy32Error extends BaseError {\n    constructor({ givenLength }) {\n        super(`The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`, { name: 'BytecodeLengthMustBeDivisibleBy32Error' });\n    }\n}\n//# sourceMappingURL=bytecode.js.map","import { pad } from '../../utils/data/pad.js';\nimport { toBytes } from '../../utils/encoding/toBytes.js';\nimport { sha256 } from '../../utils/hash/sha256.js';\nimport { maxBytecodeSize } from '../constants/number.js';\nimport { BytecodeLengthExceedsMaxSizeError, BytecodeLengthInWordsMustBeOddError, BytecodeLengthMustBeDivisibleBy32Error, } from '../errors/bytecode.js';\nexport function hashBytecode(bytecode) {\n    const bytecodeBytes = toBytes(bytecode);\n    if (bytecodeBytes.length % 32 !== 0)\n        throw new BytecodeLengthMustBeDivisibleBy32Error({\n            givenLength: bytecodeBytes.length,\n        });\n    if (bytecodeBytes.length > maxBytecodeSize)\n        throw new BytecodeLengthExceedsMaxSizeError({\n            givenLength: bytecodeBytes.length,\n            maxBytecodeSize,\n        });\n    const hashStr = sha256(bytecodeBytes);\n    const hash = toBytes(hashStr);\n    // Note that the length of the bytecode\n    // should be provided in 32-byte words.\n    const bytecodeLengthInWords = bytecodeBytes.length / 32;\n    if (bytecodeLengthInWords % 2 === 0) {\n        throw new BytecodeLengthInWordsMustBeOddError({\n            givenLengthInWords: bytecodeLengthInWords,\n        });\n    }\n    const bytecodeLength = toBytes(bytecodeLengthInWords);\n    // The bytecode should always take the first 2 bytes of the bytecode hash,\n    // so we pad it from the left in case the length is smaller than 2 bytes.\n    const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 });\n    const codeHashVersion = new Uint8Array([1, 0]);\n    hash.set(codeHashVersion, 0);\n    hash.set(bytecodeLengthPadded, 2);\n    return hash;\n}\n//# sourceMappingURL=hashBytecode.js.map","import { hashBytecode } from \"viem/zksync\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nexport const gasPerPubdataDefault = 50000n;\nexport const getEip712Domain = (transaction) => {\n    const message = transactionToMessage(transaction);\n    return {\n        domain: {\n            name: \"zkSync\",\n            version: \"2\",\n            chainId: transaction.chainId,\n        },\n        types: {\n            Transaction: [\n                { name: \"txType\", type: \"uint256\" },\n                { name: \"from\", type: \"uint256\" },\n                { name: \"to\", type: \"uint256\" },\n                { name: \"gasLimit\", type: \"uint256\" },\n                { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n                { name: \"maxFeePerGas\", type: \"uint256\" },\n                { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n                { name: \"paymaster\", type: \"uint256\" },\n                { name: \"nonce\", type: \"uint256\" },\n                { name: \"value\", type: \"uint256\" },\n                { name: \"data\", type: \"bytes\" },\n                { name: \"factoryDeps\", type: \"bytes32[]\" },\n                { name: \"paymasterInput\", type: \"bytes\" },\n            ],\n        },\n        primaryType: \"Transaction\",\n        message: message,\n    };\n};\nfunction transactionToMessage(transaction) {\n    const { gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, paymaster, paymasterInput, gasPerPubdata, data, factoryDeps, } = transaction;\n    return {\n        txType: 113n,\n        from: BigInt(from),\n        to: to ? BigInt(to) : 0n,\n        gasLimit: gas ?? 0n,\n        gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n        maxFeePerGas: maxFeePerGas ?? 0n,\n        maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n        paymaster: paymaster ? BigInt(paymaster) : 0n,\n        nonce: nonce ? BigInt(nonce) : 0n,\n        value: value ?? 0n,\n        data: data ? data : \"0x0\",\n        factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],\n        paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n    };\n}\n//# sourceMappingURL=getEip721Domain.js.map","import { hexToBytes, toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../utils/address.js\";\nimport { replaceBigInts, toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport { gasPerPubdataDefault, getEip712Domain, } from \"./getEip721Domain.js\";\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(options) {\n    const { account, transaction } = options;\n    const eip712Transaction = await populateEip712Transaction(options);\n    const hash = await signEip712Transaction({\n        account,\n        eip712Transaction,\n        chainId: transaction.chain.id,\n    });\n    const rpc = getRpcClient(transaction);\n    const result = await eth_sendRawTransaction(rpc, hash);\n    return {\n        transactionHash: result,\n        chain: transaction.chain,\n        client: transaction.client,\n    };\n}\nexport async function signEip712Transaction(options) {\n    const { account, eip712Transaction, chainId } = options;\n    // EIP712 signing of the serialized tx\n    const eip712Domain = getEip712Domain(eip712Transaction);\n    const customSignature = await account.signTypedData({\n        // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n        ...eip712Domain,\n    });\n    return serializeTransactionEIP712({\n        ...eip712Transaction,\n        chainId,\n        customSignature,\n    });\n}\n/**\n * Populate a prepared transaction to be serialized as a EIP712 transaction\n * @param options\n * @internal\n */\nexport async function populateEip712Transaction(options) {\n    const { account, transaction } = options;\n    const { gas, maxFeePerGas, maxPriorityFeePerGas, gasPerPubdata } = await getZkGasFees({ transaction, from: getAddress(account.address) });\n    // serialize the transaction (with fees, gas, nonce)\n    const serializableTransaction = await toSerializableTransaction({\n        transaction: {\n            ...transaction,\n            gas,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n        },\n        from: account.address,\n    });\n    return {\n        ...serializableTransaction,\n        ...transaction.eip712,\n        gasPerPubdata,\n        from: account.address,\n    };\n}\nfunction serializeTransactionEIP712(transaction) {\n    const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data, } = transaction;\n    const serializedTransaction = [\n        nonce ? toHex(nonce) : \"0x\",\n        maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n        maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n        gas ? toHex(gas) : \"0x\",\n        to ?? \"0x\",\n        value ? toHex(value) : \"0x\",\n        data ?? \"0x0\",\n        toHex(chainId),\n        toHex(\"\"),\n        toHex(\"\"),\n        toHex(chainId),\n        from ?? \"0x\",\n        gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n        factoryDeps ?? [],\n        customSignature ?? \"0x\", // EIP712 signature\n        paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n    ];\n    // @ts-ignore - TODO: fix types\n    return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\nexport async function getZkGasFees(args) {\n    const { transaction, from } = args;\n    let [gas, maxFeePerGas, maxPriorityFeePerGas, eip712] = await Promise.all([\n        resolvePromisedValue(transaction.gas),\n        resolvePromisedValue(transaction.maxFeePerGas),\n        resolvePromisedValue(transaction.maxPriorityFeePerGas),\n        resolvePromisedValue(transaction.eip712),\n    ]);\n    let gasPerPubdata = eip712?.gasPerPubdata;\n    if (gas === undefined ||\n        maxFeePerGas === undefined ||\n        maxPriorityFeePerGas === undefined) {\n        const rpc = getRpcClient(transaction);\n        const params = await formatTransaction({ transaction, from });\n        const result = (await rpc({\n            // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n            method: \"zks_estimateFee\",\n            // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n            params: [replaceBigInts(params, toHex)],\n        }));\n        gas = toBigInt(result.gas_limit) * 2n; // overestimating to avoid issues when not accounting for paymaster extra gas ( we should really pass the paymaster input above for better accuracy )\n        const baseFee = toBigInt(result.max_fee_per_gas);\n        maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n        maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n        gasPerPubdata = toBigInt(result.gas_per_pubdata_limit) * 2n; // doubling for fast inclusion;\n        if (gasPerPubdata < 50000n) {\n            // enforce a minimum gas per pubdata limit\n            gasPerPubdata = 50000n;\n        }\n    }\n    return {\n        gas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        gasPerPubdata,\n    };\n}\nasync function formatTransaction(args) {\n    const { transaction, from } = args;\n    const [data, to, value, eip712] = await Promise.all([\n        encode(transaction),\n        resolvePromisedValue(transaction.to),\n        resolvePromisedValue(transaction.value),\n        resolvePromisedValue(transaction.eip712),\n    ]);\n    const gasPerPubdata = eip712?.gasPerPubdata;\n    return {\n        from,\n        to,\n        data,\n        value,\n        gasPerPubdata,\n        eip712Meta: {\n            ...eip712,\n            gasPerPubdata: gasPerPubdata || 50000n,\n            factoryDeps: eip712?.factoryDeps?.map((dep) => Array.from(hexToBytes(dep))),\n        },\n        type: \"0x71\",\n    };\n}\n//# sourceMappingURL=send-eip712-transaction.js.map","/**\n * Sends a raw transaction to the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param signedTransaction - The signed transaction in hex format.\n * @returns A promise that resolves to the transaction hash.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_sendRawTransaction } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionHash = await eth_sendRawTransaction(rpcRequest, \"0x...\");\n * ```\n */\nexport async function eth_sendRawTransaction(request, signedTransaction) {\n    return await request({\n        method: \"eth_sendRawTransaction\",\n        params: [signedTransaction],\n    });\n}\n//# sourceMappingURL=eth_sendRawTransaction.js.map","import * as ox__Hex from \"ox/Hex\";\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values) {\n    return ox__Hex.concat(...values);\n}\n//# sourceMappingURL=concat-hex.js.map","import { uint8ArrayToHex } from \"./encoding/hex.js\";\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a, b) {\n    return a < b ? a : b;\n}\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a, b) {\n    return a > b ? a : b;\n}\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value) {\n    if ([\"string\", \"number\"].includes(typeof value) &&\n        !Number.isInteger(Number(value))) {\n        throw new Error(`Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`);\n    }\n    if (value instanceof Uint8Array) {\n        return BigInt(uint8ArrayToHex(value));\n    }\n    return BigInt(value);\n}\nexport const replaceBigInts = (obj, replacer) => {\n    if (typeof obj === \"bigint\")\n        return replacer(obj);\n    if (Array.isArray(obj))\n        return obj.map((x) => replaceBigInts(x, replacer));\n    if (obj && typeof obj === \"object\")\n        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, replaceBigInts(v, replacer)]));\n    return obj;\n};\n//# sourceMappingURL=bigint.js.map"],"names":[],"sourceRoot":""}